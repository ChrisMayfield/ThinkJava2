%
% NOTE: all chapter, section, and exercise numbers in this file refer to V6
%


%%% Section 2.9
\section{Composition}

\index{composition}

So far we have looked at the elements of a programming language -- variables, expressions, and statements -- in isolation, without talking about how to put them together.

One of the most useful features of programming languages is their ability to take small building blocks and {\bf compose} them.
For example, we know how to multiply numbers and we know how to display values.
We can combine these operations into a single statement:

\begin{code}
System.out.println(17 * 3);
\end{code}

Any arithmetic expression can be used inside a print statement.
We've already seen one example:

\begin{code}
System.out.println(hour * 60 + minute);
\end{code}

You can also put arbitrary expressions on the right side of an assignment:

\begin{code}
int percentage;
percentage = (minute * 100) / 60;
\end{code}

The left side of an assignment must be a variable name, not an expression.
That's because the left side indicates where the result will be stored, and expressions do not represent storage locations.

\begin{code}
hour = minute + 1;  // correct
minute + 1 = hour;  // compiler error
\end{code}

\index{readability}

The ability to compose operations may not seem impressive now, but we will see examples later on that allow us to write complex computations neatly and concisely.
But don't get too carried away.
Large, complex expressions can be hard to read and debug.

%Before you get too carried away with composition, keep in mind that other people will be reading your source code.
%In practice, software developers spend the vast majority of their time {\em understanding} and {\em modifying} existing code.
%Thus it's far more important to write code that is readable than to write code that is (or appears to be) optimal.
%There is much beauty in simplicity.
%In general, each line of code should be a single step of the algorithm.


%%% Chapter 4 (commented out)
\begin{exercise}

What is the difference between a variable and a method?
In terms of their syntax, how does the Java compiler tell the difference between the two?

%A variable is a {\em location of data}, whereas a method is a {\em location of code}.
%In Java, methods always have parentheses, even if they have no arguments like \java{System.out.println()}.

\end{exercise}


%%% Chapter 4 (commented out)
%ABD: We don't need this anymore since we used this as an example
\begin{exercise}

Draw a stack diagram that shows the state of the program in Section~\ref{stack} when \java{main} invokes \java{printTime} with the arguments \java{11} and \java{59}.

\end{exercise}


%%% Chapter 8 (commented out)
% CSM: we now discuss binary search in Chapter 12
\begin{exercise}

In Section~\ref{traversal} we wrote a method called \java{search} that traverses an array and returns the index of a given value, or -1 if the value is not in the array.

If the elements of the array are sorted, we can make this method more efficient using a ``binary search''.
You can read about it at \url{https://en.wikipedia.org/wiki/Binary_search_algorithm}.

Write a method called \java{binarySearch} that implements this algorithm.
{\it Hint:} You might find it easier to write this method recursively.

\end{exercise}


%%% Chapter 9 (commented out)

\term{traverse}
To iterate through the elements of a set performing a similar operation on each.

\term{index}
A variable or value used to indicate one of the members of a collection, like a character from a string.

\term{counter}
A variable used to count something, usually initialized to zero and then incremented.

\term{exception}
A runtime error like ArithmeticException or IndexOutOfBoundsException.

%TODO: find a place to explain how to read a stack trace, ideally with a
% non-trivial call stack (this one is important -- right now we have nothing)

\term{stack trace}
An error message that shows the state of a program when an exception occurs.

\term{utility method}
A method that provides commonly needed functionality.


%%% Chapter 12 (commented out)
% NOTE: this is not a very good exercise
\begin{exercise}

In Blackjack the object of the game is to get a collection of cards with a score of 21.
The score for a hand is the sum of scores for all cards.
The score for an ace is 1, for all face cards is ten, and for all other cards the score is the same as the rank.
For example, the hand (Ace, 10, Jack, 3) has a total score of 1 + 10 + 10 + 3 = 24.

Write a method called \java{handScore} that takes an array of cards as an argument and that returns the total score.

\end{exercise}


\begin{exercise}  %%V6 Ex4.2

The point of this exercise is to make sure you understand how to write and invoke methods that take parameters.

\begin{enumerate}
\item Write the first line of a method named \java{zool} that takes three parameters: an \java{int} and two \java{String}s.

\item Write a line of code that calls \java{zool}, passing as arguments the value \java{11}, the name of your first pet, and the name of the street you grew up on.
\end{enumerate}

\end{exercise}


\begin{exercise}  %%V6 Ex5.3

Draw a stack diagram that shows the state of the program in Section~\ref{recursion} after \java{main} invokes \java{nLines} with the parameter \java{n == 4}, just before the last invocation of \java{nLines} returns.

\end{exercise}


\begin{exercise}  %%V6 Ex6.2

Write a method named \java{isDivisible} that takes two integers, \java{n} and \java{m}, and that returns \java{true} if \java{n} is divisible by \java{m}, and \java{false} otherwise.

\end{exercise}


\begin{exercise}  %%V6 Ex7.3

In Exercise~\ref{ex.power} we wrote a recursive version of \java{power}, which takes a double \java{x} and an integer \java{n} and returns $x^n$.
Now write an iterative method to perform the same calculation.

\end{exercise}


\begin{exercise}  %%V6 Ex7.4

Section~\ref{factorial} presents a recursive method that computes the factorial function.
Write an iterative version of \java{factorial}.

\end{exercise}
