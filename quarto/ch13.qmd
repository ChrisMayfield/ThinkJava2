---
chapter: 13
---

# Objects of Arrays {#objects-of-arrays}

In the previous chapter, we defined a class to represent cards and used
an array of `Card`{.java} objects to represent a deck. In this chapter,
we take additional steps toward object-oriented programming.

First we define a class to represent a deck of cards. Then we present
algorithms for shuffling and sorting decks. Finally, we introduce
`ArrayList`{.java} from the Java library and use it to represent
collections of cards.

## Decks of Cards {#deck}

Here is the beginning of a `Deck`{.java} class that encapsulates an
array of `Card`{.java} objects:

``` {.java language="Java"}
public class Deck {
    private Card[] cards;

    public Deck(int n) {
        this.cards = new Card[n];
    }

    public Card[] getCards() {
        return this.cards;
    }
}
```

The constructor initializes the instance variable with an array of
`n`{.java} cards, but it doesn't create any `Card`{.java} objects.
Figure [13.1](#fig.deckobject){reference-type="ref"
reference="fig.deckobject"} shows what a `Deck`{.java} looks like with
no cards.

<figure id="fig.deckobject">
<div class="center">
<p><img src="figs/deckobject-.svg"
alt="Memory diagram showing a Deck object with a cards array containing null references, representing an unpopulated deck" /></p>
</div>
<figcaption>Memory diagram of an unpopulated <code
class="sourceCode java">Deck</code> object.</figcaption>
</figure>

We'll add another constructor that creates a standard 52-card array and
populates it with `Card`{.java} objects:

``` {.java language="Java"}
public Deck() {
    this.cards = new Card[52];
    int index = 0;
    for (int suit = 0; suit <= 3; suit++) {
        for (int rank = 1; rank <= 13; rank++) {
            this.cards[index] = new Card(rank, suit);
            index++;
        }
    }
}
```

This method is similar to the example in
Section [12.6](#cardarray){reference-type="ref" reference="cardarray"};
we just turned it into a constructor. We can use it to create a complete
`Deck`{.java} like this:

``` {.java language="Java"}
Deck deck = new Deck();
```

Now that we have a `Deck`{.java} class, we have a logical place to put
methods that pertain to decks. Looking at the methods we have written so
far, one obvious candidate is `printDeck`{.java} from
Section [12.6](#cardarray){reference-type="ref" reference="cardarray"}.
Here's how it looks, rewritten as an instance method of `Deck`{.java}:

``` {.java language="Java"}
public void print() {
    for (Card card : this.cards) {
        System.out.println(card);
    }
}
```

Notice that when we transform a static method into an instance method,
the code is shorter. Here's how we invoke it:

``` {.java language="Java"}
deck.print();
```

## Shuffling Decks {#shuffle}

For most card games, you have to shuffle the deck; that is, put the
cards in a random order. In Section [7.6](#random){reference-type="ref"
reference="random"} you saw how to generate random numbers, but it is
not obvious how to use them to shuffle a deck.

One possibility is to model the way humans shuffle; for example, we
could divide the deck in two halves and then choose alternately from
each one. Humans usually don't shuffle perfectly, so after about seven
iterations, the order of the deck is pretty well randomized.

But a computer program would have the annoying property of doing a
perfect shuffle every time, which is not very random. In fact, after
eight perfect shuffles, you would find the deck back in the order you
started in! For more on this, see
<https://en.wikipedia.org/wiki/Faro_shuffle>.

A better shuffling algorithm is to traverse the deck one card at a time,
and at each iteration, choose two cards and swap them. To outline this
algorithm, we'll use a combination of Java statements and English
comments. This technique is sometimes called **pseudocode**:

``` {.java language="Java"}
public void shuffle() {
    for each index i {
        // choose a random number between i and length - 1
        // swap the ith card and the randomly-chosen card
    }
}
```

The nice thing about pseudocode is that it often makes clear what other
methods you are going to need. In this case, we need a method that
chooses a random integer in a given range and a method that takes two
indexes and swaps the cards at those positions:

``` {.java language="Java"}
private static int randomInt(int low, int high) {
    // return a random number between low and high,
    // including both
}

private void swapCards(int i, int j) {
    // swap the ith and the jth cards in the array
}
```

Methods like `randomInt`{.java} and `swapCards`{.java} are called
**helper methods**, because they help you solve parts of the problem.
Helper methods are often `private`{.java}, because they are used only by
methods in the class and are not needed by methods in other classes.

The process of writing pseudocode first and then writing helper methods
to make it work is a kind of **top-down design** (see
<https://en.wikipedia.org/wiki/Top-down_and_bottom-up_design>). It is an
alternative to "incremental development" and "encapsulation and
generalization", the other design processes you have seen in this book.

One of the exercises at the end of the chapter asks you to write the
helper methods `randomInt`{.java} and `swapCards`{.java}, and use them
to implement `shuffle`{.java}.

When you do the exercise, notice that `randomInt`{.java} is a class
method and `swapCards`{.java} is an instance method. Do you understand
why?

## Selection Sort {#sorting}

Now that we have shuffled the deck, we need a way to put it back in
order. There is an algorithm for sorting that is ironically similar to
the algorithm for shuffling. It's called **selection sort**, because it
works by traversing the array repeatedly and selecting the lowest (or
highest) remaining card each time.

During the first iteration, we find the lowest card and swap it with the
card in the zeroth position. During the $i$th iteration, we find the
lowest card to the right of $i$ and swap it with the $i$th card. Here is
pseudocode for selection sort:

``` {.java language="Java"}
public void selectionSort() {
    for each index i {
        // find the lowest card at or to the right of i
        // swap the ith card and the lowest card found
    }
}
```

Again, the pseudocode helps with the design of the helper methods. For
this algorithm, we can reuse `swapCards`{.java} from the previous
section, so we need only a method to find the lowest card; we'll call it
`indexLowest`{.java}:

``` {.java language="Java"}
private int indexLowest(int low, int high) {
    // find the lowest card between low and high
}
```

One of the exercises at the end of the chapter asks you to write
`indexLowest`{.java}, and then use it and `swapCards`{.java} to
implement `selectionSort`{.java}.

## Merge Sort {#mergesort}

Selection sort is a simple algorithm, but it is not very efficient. To
sort $n$ items, it has to traverse the array $n-1$ times. Each traversal
takes an amount of time proportional to $n$. The total time, therefore,
is proportional to $n^2$.

We will develop a more efficient algorithm called **merge sort**. To
sort $n$ items, merge sort takes time proportional to $n \log_2 n$. That
may not seem impressive, but as $n$ gets big, the difference between
$n^2$ and $n \log_2 n$ can be enormous.

For example, $\log_2$ of one million is around 20. So if you had to sort
a million numbers, merge sort would require 20 million steps. But
selection sort would require one trillion steps!

The idea behind merge sort is this: if you have two decks, each of which
has already been sorted, you can quickly merge them into a single,
sorted deck. Try this out with a deck of cards:

1.  Form two decks with about 10 cards each, and sort them so they are
    face up with the lowest cards on top. Place the decks in front of
    you.

2.  Compare the top card from each deck and choose the lower one. Flip
    it over and add it to the merged deck.

3.  Repeat step 2 until one of the decks is empty. Then take the
    remaining cards and add them to the merged deck.

The result should be a single sorted deck. In the next few sections,
we'll explain how to implement this algorithm in Java.

## Subdecks

[]{#subdeck label="subdeck"}

The first step of merge sort is to split the deck into two "subdecks",
each with about half of the cards. So we need a method that takes a
deck, and a range of indexes, and returns a new deck that contains the
specified subset of cards:

``` {.java language="Java"}
public Deck subdeck(int low, int high) {
    Deck sub = new Deck(high - low + 1);
    for (int i = 0; i < sub.cards.length; i++) {
        sub.cards[i] = this.cards[low + i];
    }
    return sub;
}
```

The first line creates an unpopulated `Deck`{.java} object that contains
an array of `null`{.java} references. Inside the `for`{.java} loop, the
subdeck gets populated with references to `Card`{.java} objects.

The length of the subdeck is `high - low + 1`{.java}, because both the
low card and the high card are included. This sort of computation can be
confusing, and forgetting the "`+ 1`{.java}" often leads to
**off-by-one** errors. Drawing a picture is usually the best way to
avoid them.

Figure [13.2](#fig.subdeck){reference-type="ref"
reference="fig.subdeck"} is a memory diagram of a subdeck with
`low = 0`{.java} and `high = 4`{.java}. The result is a hand with five
cards that are *shared* with the original deck; that is, they are
aliased.

<figure id="fig.subdeck">
<div class="center">
<p><img src="figs/subdeck-.svg"
alt="Memory diagram showing a subdeck with low=0 and high=4, containing 5 cards that are aliased (shared) with the original deck" /></p>
</div>
<figcaption>Memory diagram showing the effect of <code
class="sourceCode java">subdeck</code>.</figcaption>
</figure>

Aliasing might not be a good idea, because changes to shared cards would
be reflected in multiple decks. But since `Card`{.java} objects are
immutable, this kind of aliasing is not a problem. And it saves some
memory because we don't create duplicate `Card`{.java} objects.

## Merging Decks

The next helper method we need is `merge`{.java}, which takes two sorted
subdecks and returns a new deck containing all cards from both decks, in
order. Here's what the algorithm looks like in pseudocode, assuming the
subdecks are named `d1`{.java} and `d2`{.java}:

``` {.java language="Java"}
private static Deck merge(Deck d1, Deck d2) {
    // create a new deck, d3, big enough for all the cards

    // use the index i to keep track of where we are at in
    // the first deck, and the index j for the second deck
    int i = 0;
    int j = 0;

    // the index k traverses the result deck
    for (int k = 0; k < d3.length; k++) {
        // if d1 is empty, use top card from d2
        // if d2 is empty, use top card from d1
        // otherwise, compare the top two cards

        // add lowest card to the new deck at k
        // increment i or j (depending on card)
    }
    // return the new deck
}
```

An exercise at the end of the chapter asks you to implement
`merge`{.java}. It's a little tricky, so be sure to test it with
different subdecks. Once your `merge`{.java} method is working, you can
use it to write a simplified version of merge sort:

``` {.java language="Java"}
public Deck almostMergeSort() {
    // divide the deck into two subdecks
    // sort the subdecks using selectionSort
    // merge the subdecks, return the result
}
```

If you have working versions of `subdeck`{.java},
`selectionSort`{.java}, and `merge`{.java}, you should have no trouble
getting this method working. But it is still not very efficient, because
it uses `selectionSort`{.java} to sort the subdecks. We can make it more
efficient if we use `mergeSort`{.java} instead, but that means we have
to make it recursive!

## Adding Recursion

To make `mergeSort`{.java} work recursively, you have to add a base
case; otherwise, it repeats forever. The simplest base case is a subdeck
with one card. If there is only one card, it can't be out of order, so
we consider it sorted. And if it is already sorted, we can just return
it.

And it will turn out to be convenient if we handle another base case, a
subdeck with zero cards. By the same logic, if there are no cards, they
can't be out of order. So we consider an empty deck to be sorted, and
return it.

With these base cases, a recursive version of `mergeSort`{.java} looks
like this:

``` {.java language="Java"}
public Deck mergeSort() {
    // if the deck has 0 or 1 cards, return it
    // otherwise, divide the deck into two subdecks
    // sort the subdecks using mergeSort
    // merge the subdecks
    // return the result
}
```

As usual, there are two ways to think about recursive programs: you can
follow the flow of execution, or you can make the "leap of faith" (see
Section [8.4](#leap_of_faith){reference-type="ref"
reference="leap_of_faith"}). This example should encourage you to make
the leap of faith.

When you use `selectionSort`{.java} to sort the subdecks, you don't feel
compelled to follow the flow of execution. You assume it works because
you already debugged it. When you make `mergeSort`{.java} recursive, you
just replace one sorting algorithm with another. There is no reason to
read the program differently.

Well, almost. You have to think about the base cases and make sure that
you reach them. But other than that, writing the recursive version
should be no problem. As an exercise at the end of this chapter, you'll
have a chance to finish off this example.

## Static Context

Figure [13.3](#fig.deck){reference-type="ref" reference="fig.deck"}
shows a UML class diagram for `Deck`{.java}, including the instance
variable, `cards`{.java}, and the methods we have so far. In UML
diagrams, `private`{.java} attributes and methods begin with a minus
sign (`-`{.java}) and `static`{.java} methods are underlined.

<figure id="fig.deck">
<div class="center">
<p><img src="figs/deck-.svg"
alt="UML class diagram showing Deck class with private cards array attribute and public methods including constructors, print, shuffle, selectionSort, mergeSort, and subdeck" /></p>
</div>
<figcaption>UML diagram for the <code
class="sourceCode java">Deck</code> class.</figcaption>
</figure>

The helper methods `randomInt`{.java} and `merge`{.java} are
`static`{.java}, because they do not read or write any instance
variables. All other methods are instance methods, because they access
the instance variable, `cards`{.java}.

When you have static methods and instance methods in the same class, it
is easy to get them confused.

To invoke an instance method, you need an instance:

``` {.java language="Java"}
Deck deck = new Deck();
deck.print();  // correct
```

`Deck`{.java} with a capital `D`{.java} is a class, and `deck`{.java}
with a lowercase `d`{.java} is an object.

Say you try to invoke `print`{.java} like this:

``` {.java language="Java"}
Deck.print();  // wrong!
```

You get a compiler error like this:

    Non-static method print() cannot be referenced from a
    static context.

By "static context", the compiler means you are trying to invoke a
method in a context that requires a static method.

On the other hand, if you have a `Deck`{.java} object, you can use it to
invoke a static method:

``` {.java language="Java"}
Deck deck = new Deck();
int i = deck.randomInt(0, 51);  // legal, but not good style
```

This is legal, but it is not considered good style, because someone
reading this code would expect `randomInt`{.java} to be an instance
method.

Another common error is to use `this`{.java} in a static method. For
example, say you write something like this:

``` {.java language="Java"}
private static Deck merge(Deck d1, Deck d2) {
    return this.cards;  // wrong!
}
```

You get a compiler error like this:

    Non-static variable this cannot be referenced from a
    static context.

The problem is that `cards`{.java} is an instance variable, so it is
*non-static*; therefore, you can't access it from a static method. In
general, you can't use `this`{.java} in a static method, because a
static method is not invoked on an object.

For beginners, error messages about non-static context can be confusing
and frustrating. We hope this section helps.

## Piles of Cards

Now that we have classes that represent cards and decks, let's use them
to make a game. One of the simplest card games that children play is
called "War" (see <https://en.wikipedia.org/wiki/War_(card_game)>).

Initially, the deck is divided evenly into two piles, one for each
player. During each round, each player takes the top card from their
pile and places it, face up, in the center. Whoever has the
highest-ranking card, ignoring suit, takes the two cards and adds them
to the bottom of their pile. The game continues until one player has won
the entire deck.

We could use the `Deck`{.java} class to represent the individual piles.
However, our implementation of `Deck`{.java} uses a `Card`{.java} array,
and the length of an array can't change. As the game progresses, we need
to be able to add and remove cards from the piles.

We can solve this problem with an `ArrayList`{.java}, which is in the
`java.util`{.java} package. An `ArrayList`{.java} is a **collection**,
which is an object that contains other objects. It provides methods to
add and remove elements, and it grows and shrinks automatically.

We define a new class named `Pile`{.java} to represent a pile of cards.
It uses an `ArrayList`{.java} to store `Card`{.java} objects:

``` {.java language="Java"}
public class Pile {
    private ArrayList<Card> cards;

    public Pile() {
        this.cards = new ArrayList<Card>();
    }
}
```

When you declare an `ArrayList`{.java}, you specify the type it contains
in angle brackets (`<>`{.java}). This declaration says that
`cards`{.java} is not just an `ArrayList`{.java}; it's an
`ArrayList`{.java} of `Card`{.java} objects. The constructor initializes
`this.cards`{.java} with an empty `ArrayList`{.java}.

Now let's think about the methods we need to play the game. At the
beginning of each round, each player draws a card from the top of their
pile. So we define a method to do that:

``` {.java language="Java"}
public Card popCard() {
    return this.cards.remove(0);  // from the top of the pile
}
```

`popCard`{.java} removes the `Card`{.java} at the beginning of the
`ArrayList`{.java}, which we think of as the top of the pile. Because we
use `ArrayList.remove`{.java}, it automatically shifts the remaining
cards to fill the gap.

At the end of each round, the winner adds cards to the bottom of their
pile. So we define a method to do that:

``` {.java language="Java"}
public void addCard(Card card) {
    this.cards.add(card);        // to the bottom of the pile
}
```

`ArrayList`{.java} provides a method, `add`{.java}, that adds an element
to the end of the collection, which we think of as the bottom of the
pile.

To know when to stop the game, we have to check if one of the piles is
empty. Here's a method to do that:

``` {.java language="Java"}
public boolean isEmpty() {
    return this.cards.isEmpty();
}
```

So far, these methods don't do very much; they just invoke methods on
the instance variable, `cards`{.java}. Methods like these are called
**wrapper methods** because they wrap one method with another.

Finally, to start the game, we need to divide the deck into two equal
parts. We can do that with `subdeck`{.java} from
Section [\[subdeck\]](#subdeck){reference-type="ref"
reference="subdeck"} and a new method, `addDeck`{.java}:

``` {.java language="Java"}
public void addDeck(Deck deck) {
    for (Card card : deck.getCards()) {
        this.cards.add(card);
    }
}
```

`addDeck`{.java} takes a `Deck`{.java} object, loops through the cards,
and adds them to the `Pile`{.java}. Notice that it does not remove the
cards from the `Deck`{.java}, so the `Deck`{.java} and the `Pile`{.java}
share cards. But that won't be a problem because cards are immutable.

## Playing War

Now we can use `Deck`{.java} and `Pile`{.java} to implement the game.
We'll start by creating a deck and shuffling:

``` {.java language="Java"}
Deck deck = new Deck();
deck.shuffle();
```

Then we divide the `Deck`{.java} into two piles:

``` {.java language="Java"}
Pile p1 = new Pile();
p1.addDeck(deck.subdeck(0, 25));

Pile p2 = new Pile();
p2.addDeck(deck.subdeck(26, 51));
```

The game itself is a loop that repeats until one of the piles is empty.
At each iteration, we draw a card from each pile and compare their
ranks:

``` {.java language="Java"}
while (!p1.isEmpty() && !p2.isEmpty()) {
    // pop a card from each pile
    Card c1 = p1.popCard();
    Card c2 = p2.popCard();

    // compare the cards
    int diff = c1.getRank() - c2.getRank();
    if (diff > 0) {
        p1.addCard(c1);
        p1.addCard(c2);
    } else if (diff < 0) {
        p2.addCard(c1);
        p2.addCard(c2);
    } else {
        // it's a tie
    }
```

If the two cards have the same rank, it's a tie. In that case, each
player draws four more cards. Whoever has the higher fourth card takes
all cards in play. If there's another tie, they draw another four cards,
and so on.

One of the exercises at the end of this chapter asks you to implement
the `else`{.java} block when there's a tie.

After the `while`{.java} loop ends, we display the winner based on which
pile is not empty:

``` {.java language="Java"}
if (p2.isEmpty()) {
    System.out.println("Player 1 wins!");
} else {
    System.out.println("Player 2 wins!");
}
```

`ArrayList`{.java} provides many other methods that we didn't use for
this example. Take a minute to read the documentation, which you can
find by doing a web search for "Java ArrayList".

## Vocabulary

pseudocode:

:   A way of designing programs by writing rough drafts in a combination
    of English and Java.

helper method:

:   A method that implements part of a more complex algorithm; often it
    is not particularly useful on its own.

top-down design:

:   Breaking down a problem into subproblems, and solving each
    subproblem one at a time.

selection sort:

:   A simple sorting algorithm that searches for the smallest or largest
    element $n$ times.

merge sort:

:   A recursive sorting algorithm that divides an array into two parts,
    sorts each part (using merge sort), and merges the results.

off-by-one:

:   A common programming mistake that results in iterating one time too
    many, or too few.

static context:

:   The parts of a class that run without reference to a specific
    instance of the class.

collection:

:   A Java library class, like `ArrayList`{.java}, that represents a
    group of objects.

wrapper method:

:   A method that calls another method without doing much additional
    work.

## Exercises

The code for this chapter is in the *ch13* directory of
*ThinkJavaCode2*. See page  for instructions on how to download the
repository. Before you start the exercises, we recommend that you
compile and run the examples.

::: exercise
**Exercise 13.1**. *Write a `toString`{.java} method for the
`Deck`{.java} class. It should return a single string that represents
the cards in the deck. When it's printed, this string should display the
same results as the `print`{.java} method in
Section [13.1](#deck){reference-type="ref" reference="deck"}.*

**Hint:* You can use the `+`{.java} operator to concatenate strings, but
that is not very efficient. Consider using `StringBuilder`{.java}
instead; see Section [10.11](#stringbuilder){reference-type="ref"
reference="stringbuilder"}.*
:::

::: {#ex.shuffle .exercise}
**Exercise 13.2**.

*The goal of this exercise is to implement the shuffling algorithm from
this chapter.*

1.  *In the repository for this book, you should find the file named
    *Deck.java*. Check that you can compile it in your environment.*

2.  *Implement the `randomInt`{.java} method. You can use the
    `nextInt`{.java} method provided by `java.util.Random`{.java}, which
    you saw in Section [7.6](#random){reference-type="ref"
    reference="random"}.*

    **Hint:* To avoid creating a `Random`{.java} object every time
    `randomInt`{.java} is invoked, consider defining a class variable.*

3.  *Write a `swapCards`{.java} method that takes two indexes and swaps
    the cards at the given locations.*

4.  *Fill in the `shuffle`{.java} method by using the algorithm in
    Section [13.2](#shuffle){reference-type="ref" reference="shuffle"}.*
:::

::: exercise
**Exercise 13.3**. *The goal of this exercise is to implement the
sorting algorithms from this chapter. Use the *Deck.java* file from the
previous exercise or create a new one from scratch.*

1.  *Implement the `indexLowest`{.java} method. Use the
    `Card.compareTo`{.java} method to find the lowest card in a given
    range of the deck, from `lowIndex`{.java} to `highIndex`{.java},
    including both.*

2.  *Fill in `selectionSort`{.java} by using the algorithm in
    Section [13.3](#sorting){reference-type="ref" reference="sorting"}.*

3.  *Using the pseudocode in
    Section [13.4](#mergesort){reference-type="ref"
    reference="mergesort"}, implement the `merge`{.java} method. The
    best way to test it is to build and shuffle a deck. Then use
    `subdeck`{.java} to form two small subdecks, and use selection sort
    to sort them. Finally, pass the two halves to `merge`{.java} and see
    if it works.*

4.  *Fill in `almostMergeSort`{.java}, which divides the deck in half,
    then uses `selectionSort`{.java} to sort the two halves, and uses
    `merge`{.java} to create a new, sorted deck. You should be able to
    reuse code from the previous step.*

5.  *Implement `mergeSort`{.java} recursively. Remember that
    `selectionSort`{.java} is `void`{.java} and `mergeSort`{.java}
    returns a new `Deck`{.java}, which means that they get invoked
    differently:*

    ``` {.java language="Java"}
    deck.selectionSort();      // modifies an existing deck
    deck = deck.mergeSort();   // replaces old deck with new
    ```
:::

::: exercise
**Exercise 13.4**. *You can learn more about the sorting algorithms
presented in this chapter at
<https://www.toptal.com/developers/sorting-algorithms>. This site
provides explanations of the algorithms, along with animations that show
how they work. It also includes an analysis of their efficiency.*

*For example, "insertion sort" is an algorithm that inserts elements
into place, one at a time. Read about it on the website and play the
animations. Then write a method named `insertionSort`{.java} that
implements this algorithm.*

*One goal of this exercise is to practice top-down design. Your solution
should use a helper method, named `insert`{.java}, that implements the
inner loop of the algorithm. `insertionSort`{.java} should invoke this
method $n-1$ times.*
:::

::: exercise
**Exercise 13.5**. *Find and open the file *War.java* in the repository.
The `main`{.java} method contains all the code from the last section of
this chapter. Check that you can compile and run this code before
proceeding.*

*The program is incomplete; it does not handle the case when two cards
have the same rank. Finish implementing the `main`{.java} method,
beginning at the line that says: `// it's a tie`{.java}.*

*When there's a tie, draw three cards from each pile and store them in a
collection, along with the original two. Then draw one more card from
each pile and compare them. Whoever wins the tie takes all ten of these
cards.*

*If one pile does not have at least four cards, the game ends
immediately. If a tie ends with a tie, draw three more cards, and so
on.*

*Notice that this program depends on `Deck.shuffle`{.java}, so you might
have to do Exercise [13.2](#ex.shuffle){reference-type="ref"
reference="ex.shuffle"} first.*
:::
