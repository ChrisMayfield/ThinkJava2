[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Think Java",
    "section": "",
    "text": "Preface\nThink Java is an introduction to computer science and programming intended for readers with little or no experience. We start with the most basic concepts and are careful to define all terms when they are first used. The book presents each new idea in a logical progression. Larger topics, like control flow statements and object-oriented programming, are divided into smaller examples and introduced over the course of several chapters.\nThis book is intentionally concise. Each chapter is 12–14 pages and covers the material for one week of a college course. It is not meant to be a comprehensive presentation of Java, but rather, an initial exposure to programming constructs and techniques. We begin with small problems and basic algorithms and work up to object-oriented design. In the vocabulary of computer science pedagogy, this book uses the “objects late” approach.",
    "crumbs": [
      "Front Matter",
      "Preface"
    ]
  },
  {
    "objectID": "index.html#the-philosophy-behind-the-book",
    "href": "index.html#the-philosophy-behind-the-book",
    "title": "Think Java",
    "section": "The Philosophy Behind the Book",
    "text": "The Philosophy Behind the Book\nHere are the guiding principles that make the book the way it is:\n\nOne concept at a time:\n\nWe break down topics that give beginners trouble into a series of small steps, so that they can exercise each new concept in isolation before continuing.\n\nBalance of Java and concepts:\n\nThe book is not primarily about Java; it uses code examples to demonstrate computer science. Most chapters start with language features and end with concepts.\n\nConciseness:\n\nAn important goal of the book is to be small enough so that students can read and understand the entire text in a one-semester college or AP course.\n\nEmphasis on vocabulary:\n\nWe try to introduce the minimum number of terms and define them carefully when they are first used. We also organize them in glossaries at the end of each chapter.\n\nProgram development:\n\nThere are many strategies for writing programs, including bottom-up, top-down, and others. We demonstrate multiple program development techniques, allowing readers to choose methods that work best for them.\n\nMultiple learning curves:\n\nTo write a program, you have to understand the algorithm, know the programming language, and be able to debug errors. We discuss these and other aspects throughout the book and summarize our advice in Appendix 21.",
    "crumbs": [
      "Front Matter",
      "Preface"
    ]
  },
  {
    "objectID": "index.html#object-oriented-programming",
    "href": "index.html#object-oriented-programming",
    "title": "Think Java",
    "section": "Object-Oriented Programming",
    "text": "Object-Oriented Programming\nSome Java books introduce classes and objects immediately; others begin with procedural programming and transition to object-oriented more gradually.\nMany of Java’s object-oriented features are motivated by problems with previous languages, and their implementations are influenced by this history. Some of these features are hard to explain when people aren’t familiar with the problems they solve.\nWe get to object-oriented programming as quickly as possible (beginning with Chapter 9). But we introduce concepts one at a time, as clearly as possible, in a way that allows readers to practice each idea in isolation before moving on. So it takes some time to get there.\nYou can’t write Java programs (even Hello World) without encountering object-oriented features. In some cases we explain a feature briefly when it first appears, and then explain it more deeply later on.\nIf you read the entire book, you will see nearly every topic required for Java SE Programmer I certification. Supplemental lessons are available in the official Java tutorials on Oracle’s website (https://thinkjava.org/tutorial).\nThis book is also well suited to prepare high school students for the AP Computer Science A exam, which includes object-oriented design and implementation. (AP is a registered trademark of The College Board.) A mapping of Think Java section numbers to the AP course is available on our website: https://thinkjava.org/.",
    "crumbs": [
      "Front Matter",
      "Preface"
    ]
  },
  {
    "objectID": "index.html#changes-to-the-second-edition",
    "href": "index.html#changes-to-the-second-edition",
    "title": "Think Java",
    "section": "Changes to the Second Edition",
    "text": "Changes to the Second Edition\nThis new edition was written over several years, with feedback from dozens of instructors and hundreds of students. A complete history of all changes is available on GitHub. Here are some of the highlights:\n\nChapters 1–4:\n\nWe reordered the material in Chapter 1 to present a more interesting balance of theory and practice. Chapters 2–3 are much cleaner now too. Methods are now presented in a single chapter, along with additional in-depth examples.\n\nChapters 5–8:\n\nWe rearranged these chapters a lot, added many examples and new figures, and removed unnecessary details. Strings are covered earlier (before arrays) so that readers can apply them to loop problems. The material on recursion is now a chapter, and we added new sections to explain binary numbers and CodingBat.\n\nChapters 9–12:\n\nOur main goal for these chapters was to provide better explanations and more diagrams. Chapters 9–10 focus more on immutable versus mutable objects, and we added new sections on BigInteger and StringBuilder. The other content is largely the same, but it should be easier to understand now.\n\nChapters 13–17:\n\nWe balanced the amount of content in Chapters 13–14 by moving ArrayLists earlier, and we implement the “War” card game as another example. Chapters 15–17 are brand new in this edition; they cover more advanced topics including 2D arrays, graphics, exceptions, abstract classes, interfaces, and events.\n\nAppendixes:\n\nWe added Appendix 19 to explain documentation comments and Javadoc in more detail. The other three appendixes that were present in the first edition have been revised for clarity and layout.",
    "crumbs": [
      "Front Matter",
      "Preface"
    ]
  },
  {
    "objectID": "index.html#about-the-appendixes",
    "href": "index.html#about-the-appendixes",
    "title": "Think Java",
    "section": "About the Appendixes",
    "text": "About the Appendixes\nThe chapters of this book are meant to be read in order, because each one builds on the previous one. We also include several appendixes with material that can be read at any time:\n\nAppendix A, “Tools”\n\nThis appendix explains how to download and install Java so you can compile programs on your computer. It also provides a brief introduction to DrJava—an integrated development environment designed primarily for students—and other development tools, including Checkstyle for code quality and JUnit for testing.\n\nAppendix B, “Javadoc”\n\nIt’s important to document your classes and methods so that other programmers (including yourself in the future) will know how to use them. This appendix explains how to read documentation, how to write documentation, and how to use the Javadoc tool.\n\nAppendix C, “Graphics”\n\nJava provides libraries for working with graphics and animation, and these topics can be engaging for students. The libraries require object-oriented features that students will not completely understand until after Chapter 10, but they can be used much earlier.\n\nAppendix D, “Debugging”\n\nWe provide debugging suggestions throughout the book, but this appendix provides many more suggestions on how to debug your programs. We recommend that you review this appendix frequently as you work through the book.",
    "crumbs": [
      "Front Matter",
      "Preface"
    ]
  },
  {
    "objectID": "index.html#code",
    "href": "index.html#code",
    "title": "Think Java",
    "section": "Using the Code Examples",
    "text": "Using the Code Examples\nMost of the code examples in this book are available from a Git repository at https://github.com/ChrisMayfield/ThinkJavaCode2. Git is a “version control system” that allows you to keep track of the files that make up a project. A collection of files under Git’s control is called a “repository”.\nGitHub is a hosting service that provides storage for Git repositories and a convenient web interface. It provides several ways to work with the code:\n\nYou can create a copy of the repository on GitHub by clicking the Fork button. If you don’t already have a GitHub account, you’ll need to create one. After forking, you’ll have your own repository on GitHub that you can use to keep track of code you write. Then you can “clone” the repository, which downloads a copy of the files to your computer.\nAlternatively, you could clone the original repository without forking. If you choose this option, you don’t need a GitHub account, but you won’t be able to save your changes on GitHub.\nIf you don’t want to use Git at all, you can download the code in a ZIP archive using the Clone button on the GitHub page, or this link: https://thinkjava.org/code2zip.\n\nAfter you clone the repository or unzip the ZIP file, you should have a directory named ThinkJavaCode2 with a subdirectory for each chapter in the book.\nThe examples in this book were developed and tested using OpenJDK 11. If you are using a more recent version, everything should still work. If you are using an older version, some of the examples might not.",
    "crumbs": [
      "Front Matter",
      "Preface"
    ]
  },
  {
    "objectID": "index.html#acknowledgments",
    "href": "index.html#acknowledgments",
    "title": "Think Java",
    "section": "Acknowledgments",
    "text": "Acknowledgments\nMany people have sent corrections and suggestions over the years, and we appreciate their valuable feedback! This list begins with Version 4.0 of the open source edition, so it omits those who contributed to earlier versions:\n\nEllen Hildreth used this book to teach Data Structures at Wellesley College and submitted a whole stack of corrections and suggestions.\nTania Passfield pointed out that some glossaries had leftover terms that no longer appeared in the text.\nElizabeth Wiethoff noticed that the series expansion of \\(\\exp(-x^2)\\) was wrong. She has also worked on a Ruby version of the book.\nMatt Crawford sent in a whole patch file full of corrections.\nChi-Yu Li pointed out a typo and an error in one of the code examples.\nDoan Thanh Nam corrected an example.\nMuhammad Saied translated the book into Arabic and found several errors in the process.\nMarius Margowski found an inconsistency in a code example.\nLeslie Klein discovered another error in the series expansion of \\(\\exp(-x^2)\\), identified typos in card array figures, and helped clarify several exercises.\nMicah Lindstrom reported half a dozen typos and sent corrections.\nJames Riely ported the textbook source from LaTeX to Sphinx.\nhttp://fpl.cs.depaul.edu/jriely/thinkapjava/\nPeter Knaggs ported the book to C#.\nhttps://www.rigwit.co.uk/think/sharp/\nHeidi Gentry-Kolen recorded several video lectures that follow the book.\nhttps://www.youtube.com/user/digipipeline\nWaldo Ribeiro submitted a pull request that corrected a dozen typos.\nMichael Stewart made several suggestions for improving the first half of the book.\nSteven Richardson adapted the book for an online course and contributed many ideas for improving the text.\nFazl Rahman provided detailed feedback, chapter by chapter, and offered many suggestions for improving the text.\n\nWe are especially grateful to the technical reviewers of the O’Reilly Media first edition: Blythe Samuels, David Wisneski, and Stephen Rose. They found errors, made many great suggestions, and helped make the book much better.\nLikewise, we thank Marc Loy for his thorough review of the O’Reilly Media second edition. He contributed many corrections, insights, and clarifications.\nMany students have given exceptional feedback, including Ian Staton, Tanner Wernecke, Jacob Green, Rasha Abuhantash, Nick Duncan, Kylie Davidson, Shirley Jiang, Elena Trafton, Jennifer Gregorio, and Azeem Mufti.\nOther contributors who found one or more typos: Stijn Debrouwere, Guy Driesen, Andai Velican, Chris Kuszmaul, Daniel Kurikesu, Josh Donath, Rens Findhammer, Elisa Abedrapo, Yousef BaAfif, Bruce Hill, Matt Underwood, Isaac Sultan, Dan Rice, Robert Beard, Daniel Pierce, Michael Giftthaler, Chris Fox, Min Zeng, Markus Geuss, Mauricio Gonzalez, Enrico Sartirana, Kasem Satitwiwat, Jason Miller, Kevin Molloy, Cory Culbertson, Will Crawford, Shawn Brenneman, Tom Nguyen, and Ala-Uddin Mohammad.\nIf you have additional comments or ideas about the text, please send them to: feedback@greenteapress.com.\nAllen Downey and Chris Mayfield",
    "crumbs": [
      "Front Matter",
      "Preface"
    ]
  },
  {
    "objectID": "ch01.html",
    "href": "ch01.html",
    "title": "1  Computer Programming",
    "section": "",
    "text": "1.1 What Is a Computer?\nWhen people hear the word computer, they often think of a desktop or a laptop. Not surprisingly, searching for “computer” on Google Images (https://images.google.com/) displays rows and rows of these types of machines. However, in a more general sense, a computer can be any type of device that stores and processes data.\nDictionary.com defines a computer as “a programmable electronic device designed to accept data, perform prescribed mathematical and logical operations at high speed, and display the results of these operations. Mainframes, desktop and laptop computers, tablets, and smartphones are some of the different types of computers.”\nEach type of computer has its own unique design, but internally they all share the same type of hardware. The two most important hardware components are processors (or CPUs) that perform simple calculations and memory (or RAM) that temporarily stores information. Figure 1.1 shows what these components look like.\nUsers generally see and interact with touchscreens, keyboards, and monitors, but it’s the processors and memory that perform the actual computation. Nowadays it’s fairly standard, even for a smartphone, to have at least eight processors and four gigabytes (four billion cells) of memory.",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Computer Programming</span>"
    ]
  },
  {
    "objectID": "ch01.html#what-is-a-computer",
    "href": "ch01.html#what-is-a-computer",
    "title": "1  Computer Programming",
    "section": "",
    "text": "Example processor and memory hardware.",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Computer Programming</span>"
    ]
  },
  {
    "objectID": "ch01.html#what-is-programming",
    "href": "ch01.html#what-is-programming",
    "title": "1  Computer Programming",
    "section": "1.2 What Is Programming?",
    "text": "1.2 What Is Programming?\nA program is a sequence of instructions that specifies how to perform a computation on computer hardware. The computation might be something mathematical, like solving a system of equations or finding the roots of a polynomial. It could also be a symbolic computation, like searching and replacing text in a document or (strangely enough) compiling a program.\nThe details look different in different languages, but a few basic instructions appear in just about every language:\n\ninput:\n\nGet data from the keyboard, a file, a sensor, or some other device.\n\noutput:\n\nDisplay data on the screen, or send data to a file or other device.\n\nmath:\n\nPerform basic mathematical operations like addition and division.\n\ndecision:\n\nCheck for certain conditions and execute the appropriate code.\n\nrepetition:\n\nPerform an action repeatedly, usually with some variation.\n\n\nBelieve it or not, that’s pretty much all there is to it. Every program you’ve ever used, no matter how complicated, is made up of small instructions that look much like these. So you can think of programming as the process of breaking down a large, complex task into smaller and smaller subtasks. The process continues until the subtasks are simple enough to be performed with the electronic circuits provided by the hardware.",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Computer Programming</span>"
    ]
  },
  {
    "objectID": "ch01.html#hello",
    "href": "ch01.html#hello",
    "title": "1  Computer Programming",
    "section": "1.3 The Hello World Program",
    "text": "1.3 The Hello World Program\nTraditionally, the first program you write when learning a new programming language is called the “Hello World” program. All it does is output the words Hello, World! to the screen. In Java, it looks like this:\npublic class Hello {\n\n    public static void main(String[] args) {\n        // generate some simple output\n        System.out.println(\"Hello, World!\");\n    }\n}\nWhen this program runs, it displays the following:\nHello, World!\nNotice that the output does not include the quotation marks.\nJava programs are made up of class and method definitions, and methods are made up of statements. A statement is a line of code that performs a basic action. In the Hello World program, this line is a print statement that displays a message to the user:\nSystem.out.println(\"Hello, World!\");\nSystem.out.println displays results on the screen; the name println stands for “print line”. Confusingly, print can mean both “display on the screen” and “send to the printer”. In this book, we’ll try to say “display” when we mean output to the screen. Like most statements, the print statement ends with a semicolon (;).\nJava is “case-sensitive”, which means that uppercase and lowercase are not the same. In the Hello World program, System has to begin with an uppercase letter; system and SYSTEM won’t work.\nA method is a named sequence of statements. This program defines one method named main:\npublic static void main(String[] args)\nThe name and format of main is special: when the program runs, it starts at the first statement in main and ends when it finishes the last statement. Later, you will see programs that define more than one method.\nThis program defines a class named Hello. For now, a class is a collection of methods; we’ll have more to say about this later. You can give a class any name you like, but it is conventional to start with a capital letter. The name of the class has to match the name of the file it is in, so this class has to be in a file named Hello.java.\nJava uses curly braces (\\{ and \\}) to group things together. In Hello.java, the outermost braces contain the class definition, and the inner braces contain the method definition.\nThe line that begins with two slashes (//) is a comment, which is a bit of English text that explains the code. When Java sees //, it ignores everything from there until the end of the line. Comments have no effect on the execution of the program, but they make it easier for other programmers (and your future self) to understand what you meant to do.",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Computer Programming</span>"
    ]
  },
  {
    "objectID": "ch01.html#compiling-java-programs",
    "href": "ch01.html#compiling-java-programs",
    "title": "1  Computer Programming",
    "section": "1.4 Compiling Java Programs",
    "text": "1.4 Compiling Java Programs\nThe programming language you will learn in this book is Java, which is a high-level language. Other high-level languages you may have heard of include Python, C and C++, PHP, Ruby, and JavaScript.\nBefore they can run, programs in high-level languages have to be translated into a low-level language, also called “machine language”. This translation takes some time, which is a small disadvantage of high-level languages. But high-level languages have two major advantages:\n\nIt is much easier to program in a high-level language. Programs take less time to write, they are shorter and easier to read, and they are more likely to be correct.\nHigh-level languages are portable, meaning they can run on different kinds of computers with few or no modifications. Low-level programs can run on only one kind of computer.\n\nTwo kinds of programs translate high-level languages into low-level languages: interpreters and compilers. An interpreter reads a high-level program and executes it, meaning that it does what the program says. It processes the program a little at a time, alternately reading lines and performing computations. Figure 1.2 shows the structure of an interpreter.\n\n\n\n\n\n\n\nHow interpreted languages are executed.\n\n\nIn contrast, a compiler reads the entire program and translates it completely before the program starts running. The high-level program is called the source code. The translated program is called the object code, or the executable. Once a program is compiled, you can execute it repeatedly without further translation of the source code. As a result, compiled programs often run faster than interpreted programs.\nNote that object code, as a low-level language, is not portable. You cannot run an executable compiled for a Windows laptop on an Android phone, for example. To run a program on different types of machines, it must be compiled multiple times. It can be difficult to write source code that compiles and runs correctly on different types of machines.\nTo address this issue, Java is both compiled and interpreted. Instead of translating source code directly into an executable, the Java compiler generates code for a virtual machine. This “imaginary” machine has the functionality common to desktops, laptops, tablets, phones, etc. Its language, called Java byte code, looks like object code and is easy and fast to interpret.\nAs a result, it’s possible to compile a Java program on one machine, transfer the byte code to another machine, and run the byte code on that other machine. Figure 1.3 shows the steps of the development process. The Java compiler is a program named javac. It translates .java files into .class files that store the resulting byte code. The Java interpreter is another program, named java, which is short for “Java Virtual Machine” (JVM).\n\n\n\n\n\n\n\nThe process of compiling and running a Java program.\n\n\nThe programmer writes source code in the file Hello.java and uses javac to compile it. If there are no errors, the compiler saves the byte code in the file Hello.class. To run the program, the programmer uses java to interpret the byte code. The result of the program is then displayed on the screen.\nAlthough it might seem complicated, these steps are automated for you in most development environments. Usually, you only have to press a button or type a single command to compile and interpret your program. On the other hand, it is important to know what steps are happening in the background, so if something goes wrong you can figure out what it is.",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Computer Programming</span>"
    ]
  },
  {
    "objectID": "ch01.html#displaying-two-messages",
    "href": "ch01.html#displaying-two-messages",
    "title": "1  Computer Programming",
    "section": "1.5 Displaying Two Messages",
    "text": "1.5 Displaying Two Messages\nYou can put as many statements as you like in the main method. For example, to display more than one line of output:\npublic class Hello2 {\n\n    public static void main(String[] args) {\n        // generate some simple output\n        System.out.println(\"Hello, World!\");  // first line\n        System.out.println(\"How are you?\");   // another line\n    }\n}\nAs this example also shows, you can put comments at the end of a line as well as on lines all by themselves.\nPhrases that appear in quotation marks are called strings, because they contain a sequence of characters strung together in memory. Characters can be letters, numbers, punctuation marks, symbols, spaces, tabs, etc.\nSystem.out.println appends a special character, called a newline, that moves to the beginning of the next line. If you don’t want a newline at the end, you can use print instead of println:\npublic class Goodbye {\n\n    public static void main(String[] args) {\n        System.out.print(\"Goodbye, \");\n        System.out.println(\"cruel world\");\n    }\n}\n\nIn this example, the first statement does not add a newline, so the output appears on a single line:\nGoodbye, cruel world\nNotice that there is a space at the end of the first string, which appears in the output just before the word cruel.",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Computer Programming</span>"
    ]
  },
  {
    "objectID": "ch01.html#formatting",
    "href": "ch01.html#formatting",
    "title": "1  Computer Programming",
    "section": "1.6 Formatting Source Code",
    "text": "1.6 Formatting Source Code\nIn Java source code, some spaces are required. For example, you need at least one space between words, so this program is not legal:\npublicclassGoodbye{\n\n    publicstaticvoidmain(String[] args) {\n        System.out.print(\"Goodbye, \");\n        System.out.println(\"cruel world\");\n    }\n}\nBut most other spaces are optional. For example, this program is legal:\npublic class Goodbye {\npublic static void main(String[] args) {\nSystem.out.print(\"Goodbye, \");\nSystem.out.println(\"cruel world\");\n}\n}\nThe newlines are optional, too. So we could just write this:\npublic class Goodbye { public static void main(String[] args)\n{ System.out.print(\"Goodbye, \"); System.out.println\n(\"cruel world\");}}\nIt still works, but the program is getting harder and harder to read. Newlines and spaces are important for visually organizing your program, making it easier to understand the program and find errors when they occur.\nMany editors will automatically format source code with consistent indenting and line breaks. For example, in DrJava (see Appendix 18.1) you can indent your code by selecting all text (Ctrl+A) and pressing the Tab key.\nOrganizations that do a lot of software development usually have strict guidelines on how to format source code. For example, Google publishes its Java coding standards for use in open source projects: https://google.github.io/styleguide/javaguide.html.\nYou probably won’t understand these guidelines now, because they refer to language features you haven’t yet seen. But you might want to refer to them periodically as you read this book.",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Computer Programming</span>"
    ]
  },
  {
    "objectID": "ch01.html#using-escape-sequences",
    "href": "ch01.html#using-escape-sequences",
    "title": "1  Computer Programming",
    "section": "1.7 Using Escape Sequences",
    "text": "1.7 Using Escape Sequences\nIt’s possible to display multiple lines of output with only one line of code. You just have to tell Java where to put the line breaks:\npublic class Hello3 {\n\n    public static void main(String[] args) {\n        System.out.print(\"Hello!\\nHow are you doing?\\n\");\n    }\n}\nThe output is two lines, each ending with a newline character:\nHello!\nHow are you doing?\nEach \\n is an escape sequence, or two characters of source code that represent a single character. (The backslash allows you to escape the string to write special characters.) Notice there is no space between \\n and How. If you add a space there, there will be a space at the beginning of the second line.\n\n\n\nCommon escape sequences\n\n\n\\n\nnewline\n\n\n\n\n\\t\ntab\n\n\n\\\"\ndouble quote\n\n\n\\\\\nbackslash\n\n\n\n\n\nJava has a total of eight escape sequences, and the four most commonly used ones are listed in Table 1.1. For example, to write quotation marks inside of strings, you need to escape them with a backslash:\nSystem.out.println(\"She said \\\"Hello!\\\" to me.\");\nThe result is as follows:\nShe said \"Hello!\" to me.",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Computer Programming</span>"
    ]
  },
  {
    "objectID": "ch01.html#what-is-computer-science",
    "href": "ch01.html#what-is-computer-science",
    "title": "1  Computer Programming",
    "section": "1.8 What Is Computer Science?",
    "text": "1.8 What Is Computer Science?\nThis book intentionally omits some details about the Java language (such as the other escape sequences), because our main goal is teaching you how to think like a computer scientist. Being able to understand computation is much more valuable than just learning how to write code.\nIf you’re interested in learning more about Java itself, Oracle maintains an official set of tutorials on its website (https://thinkjava.org/tutorial). The “Language Basics” tutorial, found under “Learning the Java Language”, is a good place to start.\nOne of the most interesting aspects of writing programs is deciding how to solve a particular problem, especially when there are multiple solutions. For example, there are numerous ways to sort a list of numbers, and each way has its advantages. In order to determine which way is best for a given situation, we need techniques for describing and analyzing solutions formally.\nAn algorithm is a sequence of steps that specifies how to solve a problem. Some algorithms are faster than others, and some use less space in computer memory. Computer science is the science of algorithms, including their discovery and analysis. As you learn to develop algorithms for problems you haven’t solved before, you will learn to think like a computer scientist.\nDesigning algorithms and writing code is difficult and error-prone. For historical reasons, programming errors are called bugs, and the process of tracking them down and correcting them is called debugging. As you learn to debug your programs, you will develop new problem-solving skills. You will need to think creatively when unexpected errors happen.\nAlthough it can be frustrating, debugging is an intellectually rich, challenging, and interesting part of computer science. In some ways, debugging is like detective work. You are confronted with clues, and you have to infer the processes and events that led to the results you see. Thinking about how to correct programs and improve their performance sometimes even leads to the discovery of new algorithms.",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Computer Programming</span>"
    ]
  },
  {
    "objectID": "ch01.html#sec:examples",
    "href": "ch01.html#sec:examples",
    "title": "1  Computer Programming",
    "section": "1.9 Debugging Programs",
    "text": "1.9 Debugging Programs\nIt is a good idea to read this book in front of a computer so you can try out the examples as you go. You can run many of the examples directly in DrJava’s Interactions pane (see Appendix 18.2). But if you put the code in a source file, it will be easier to try out variations.\nWhenever you are experimenting with a new feature, you should also try to make mistakes. For example, in the Hello World program, what happens if you leave out one of the quotation marks? What if you leave out both? What if you spell println wrong? These kinds of experiments help you remember what you read. They also help with debugging, because you learn what the error messages mean. It is better to make mistakes now and on purpose than later on and accidentally.\nDebugging is like an experimental science: once you have an idea about what is going wrong, you modify your program and try again. If your hypothesis was correct, then you can predict the result of the modification, and you take a step closer to a working program. If your hypothesis was wrong, you have to come up with a new one.\nProgramming and debugging should go hand in hand. Don’t just write a bunch of code and then perform trial-and-error debugging until it all works. Instead, start with a program that does something and make small modifications, debugging them as you go, until the program does what you want. That way, you will always have a working program, and isolating errors will be easier.\nA great example of this principle is the Linux operating system, which contains millions of lines of code. It started out as a simple program Linus Torvalds used to explore the Intel 80386 chip. According to Larry Greenfield in The Linux Users’ Guide, “One of Linus’s earlier projects was a program that would switch between printing AAAA and BBBB. This later evolved to Linux.”\nFinally, programming sometimes brings out strong emotions. If you are struggling with a difficult bug, you might feel angry, despondent, or embarrassed. Remember that you are not alone, and virtually every programmer has had similar experiences. Don’t hesitate to reach out to a friend and ask questions!",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Computer Programming</span>"
    ]
  },
  {
    "objectID": "ch01.html#vocabulary",
    "href": "ch01.html#vocabulary",
    "title": "1  Computer Programming",
    "section": "1.10 Vocabulary",
    "text": "1.10 Vocabulary\nThroughout the book, we try to define each term the first time we use it. At the end of each chapter, we include the new terms and their definitions in order of appearance. If you spend some time learning this vocabulary, you will have an easier time reading the following chapters.\n\nproblem solving:\n\nThe process of formulating a problem, finding a solution, and expressing the solution.\n\nhardware:\n\nThe electronic and mechanical components of a computer, such as CPUs, RAM, and hard disks.\n\nprocessor:\n\nA computer chip that performs simple instructions like basic arithmetic and logic.\n\nmemory:\n\nCircuits that store data as long as the computer is turned on. Not to be confused with permanent storage devices like hard disks and flash.\n\nprogram:\n\nA sequence of instructions that specifies how to perform tasks on a computer. Also known as “software”.\n\nprogramming:\n\nThe application of problem solving to creating executable computer programs.\n\nstatement:\n\nPart of a program that specifies one step of an algorithm.\n\nprint statement:\n\nA statement that causes output to be displayed on the screen.\n\nmethod:\n\nA named sequence of statements.\n\nclass:\n\nFor now, a collection of related methods. (You will see later that there is a lot more to it.)\n\ncomment:\n\nA part of a program that contains information about the program but has no effect when the program runs.\n\nhigh-level language:\n\nA programming language that is designed to be easy for humans to read and write.\n\nlow-level language:\n\nA programming language that is designed to be easy for a computer to run. Also called “machine language”.\n\nportable:\n\nThe ability of a program to run on more than one kind of computer.\n\ninterpret:\n\nTo run a program in a high-level language by translating it one line at a time and immediately executing the corresponding instructions.\n\ncompile:\n\nTo translate a program in a high-level language into a low-level language, all at once, in preparation for later execution.\n\nsource code:\n\nA program in a high-level language, before being compiled.\n\nobject code:\n\nThe output of the compiler, after translating the program.\n\nexecutable:\n\nAnother name for object code that is ready to run on specific hardware.\n\nvirtual machine:\n\nAn emulation of a real machine. The JVM enables a computer to run Java programs.\n\nbyte code:\n\nA special kind of object code used for Java programs. Byte code is similar to object code, but it is portable like a high-level language.\n\nstring:\n\nA sequence of characters; the primary data type for text.\n\nnewline:\n\nA special character signifying the end of a line of text. Also known as “line ending”, “end of line” (EOL), or “line break”.\n\nescape sequence:\n\nA sequence of code that represents a special character when used inside a string.\n\nalgorithm:\n\nA procedure or formula for solving a problem, with or without a computer.\n\ncomputer science:\n\nThe scientific and practical approach to computation and its applications.\n\nbug:\n\nAn error in a program.\n\ndebugging:\n\nThe process of finding and removing errors.",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Computer Programming</span>"
    ]
  },
  {
    "objectID": "ch01.html#exercises",
    "href": "ch01.html#exercises",
    "title": "1  Computer Programming",
    "section": "1.11 Exercises",
    "text": "1.11 Exercises\nAt the end of each chapter, we include exercises you can do with the things you’ve learned. We encourage you to at least attempt every problem. You can’t learn to program only by reading about it; you have to practice.\nBefore you can compile and run Java programs, you might have to download and install a few tools. There are many good options, but we recommend DrJava, which is an “integrated development environment” (IDE) well suited for beginners. Instructions for getting started are in Appendix 18.\nThe code for this chapter is in the ch01 directory of ThinkJavaCode2. See page  for instructions on how to download the repository. Before you start the exercises, we recommend that you compile and run the examples.\n\nExercise 1.1. Computer scientists have the annoying habit of using common English words to mean something other than their common English meanings. For example, in English, statements and comments are the same thing, but in programs they are different.\n\nIn computer jargon, what’s the difference between a statement* and a comment?*\nWhat does it mean to say that a program is portable?\nIn common English, what does the word compile* mean?*\nWhat is an executable? Why is that word used as a noun?\n\nThe vocabulary section at the end of each chapter is intended to highlight words and phrases that have special meanings in computer science. When you see familiar words, don’t assume that you know what they mean!\n\n\nExercise 1.2. Before you do anything else, find out how to compile and run a Java program. Some environments provide sample programs similar to the example in Section 1.3.\n\nType in the Hello World program; then compile and run it.\nAdd a print statement that displays a second message after the Hello, World!. Say something witty like, How are you?. Compile and run the program again.\nAdd a comment to the program (anywhere), recompile, and run it again. The new comment should not affect the result.\n\nThis exercise may seem trivial, but it is the starting place for many of the programs we will work with. To debug with confidence, you will need to have confidence in your programming environment.\nIn some environments, it is easy to lose track of which program is executing. You might find yourself trying to debug one program while you are accidentally running another. Adding (and changing) print statements is a simple way to be sure that the program you are looking at is the program you are running.\n\n\nExercise 1.3. It is a good idea to commit as many errors as you can think of, so that you see what error messages the compiler produces. Sometimes the compiler tells you exactly what is wrong, and all you have to do is fix it. But sometimes the error messages are misleading. Over time you will develop a sense for when you can trust the compiler and when you have to figure things out yourself.\nStarting with the Hello World program, try out each of the following errors. After you make each change, compile the program, read the error message (if there is one), and then fix the error.\n\nRemove one of the opening curly braces.\nRemove one of the closing curly braces.\nInstead of main, write mian.\nRemove the word static.\nRemove the word public.\nRemove the word System.\nReplace println with Println.\nReplace println with print.\nDelete one parenthesis.\nAdd an extra parenthesis.",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Computer Programming</span>"
    ]
  },
  {
    "objectID": "ch02.html",
    "href": "ch02.html",
    "title": "2  Variables and Operators",
    "section": "",
    "text": "2.1 Declaring Variables\nOne of the most powerful features of a programming language is the ability to define and manipulate variables. A variable is a named location in memory that stores a value. Values may be numbers, text, images, sounds, and other types of data. To store a value, you first have to declare a variable:\nThis statement is called a declaration, because it declares that the variable message has the type String. Each variable has a type that determines what kind of values it can store. For example, the int type can store integers like 1 and -5, and the char type can store characters like 'A' and 'z'.\nSome types begin with a capital letter and some with lowercase. You will learn the significance of this distinction later, but for now you should take care to get it right. There is no such type as Int or string.\nTo declare an integer variable named x, you simply type this:\nNote that x is an arbitrary name for the variable. In general, you should use names that indicate what the variables mean:\nThis example declares two variables with type String and two with type int. The last line shows how to declare multiple variables with the same type: hour and minute are both integers. Note that each declaration statement ends with a semicolon (;).\nVariable names usually begin with a lowercase letter, in contrast to class names (like Hello) that start with a capital letter. When a variable name contains more than one word (like firstName), it is conventional to capitalize the first letter of each subsequent word. Variable names are case-sensitive, so firstName is not the same as firstname or FirstName.\nYou can use any name you want for a variable. But there are about 50 reserved words, called keywords, that you are not allowed to use as variable names. These words include public, class, static, void, and int, which are used by the compiler to analyze the structure of the program.\nYou can see the full list of keywords (https://thinkjava.org/keywords), but you don’t have to memorize them. Most programming editors provide “syntax highlighting”, which makes different parts of the program appear in different colors. And the compiler will complain even if one does sneak past you and your editor.",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Variables and Operators</span>"
    ]
  },
  {
    "objectID": "ch02.html#declaring-variables",
    "href": "ch02.html#declaring-variables",
    "title": "2  Variables and Operators",
    "section": "",
    "text": "String message;\n\n\n\nint x;\n\nString firstName;\nString lastName;\nint hour, minute;",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Variables and Operators</span>"
    ]
  },
  {
    "objectID": "ch02.html#assigning-variables",
    "href": "ch02.html#assigning-variables",
    "title": "2  Variables and Operators",
    "section": "2.2 Assigning Variables",
    "text": "2.2 Assigning Variables\nNow that we have declared some variables, we can use them to store values. We do that with an assignment statement:\nmessage = \"Hello!\";  // give message the value \"Hello!\"\nhour = 11;           // assign the value 11 to hour\nminute = 59;         // set minute to 59\nThis example shows three assignments, and the comments illustrate different ways people sometimes talk about assignment statements. The vocabulary can be confusing here, but the idea is straightforward:\n\nWhen you declare a variable, you create a named storage location.\nWhen you make an assignment to a variable, you update its value.\n\nAs a general rule, a variable has to have the same type as the value you assign to it. For example, you cannot store a string in minute or an integer in message. We will show some examples that seem to break this rule, but we’ll get to that later.\nA common source of confusion is that some strings look like integers, but they are not. For example, message can contain the string \"123\", which is made up of the characters '1', '2', and '3'. But that is not the same thing as the integer 123:\nmessage = \"123\";     // legal\nmessage = 123;       // not legal\nVariables must be initialized (assigned for the first time) before they can be used. You can declare a variable and then assign a value later, as in the previous example. You can also declare and initialize on the same line:\nString message = \"Hello!\";\nint hour = 11;\nint minute = 59;",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Variables and Operators</span>"
    ]
  },
  {
    "objectID": "ch02.html#state",
    "href": "ch02.html#state",
    "title": "2  Variables and Operators",
    "section": "2.3 Memory Diagrams",
    "text": "2.3 Memory Diagrams\nBecause Java uses the = symbol for assignment, it is tempting to interpret the statement a = b as a statement of equality. It is not!\nEquality is commutative, and assignment is not. For example, in mathematics if \\(a = 7\\), then \\(7 = a\\). In Java a = 7; is a legal assignment statement, but 7 = a; is not. The left side of an assignment statement has to be a variable name (storage location).\nAlso, in mathematics, a statement of equality is true for all time. If \\(a = b\\) now, \\(a\\) is always equal to \\(b\\). In Java, an assignment statement can make two variables equal, but they don’t have to stay that way:\nint a = 5;\nint b = a;     // a and b are now equal\na = 3;         // a and b are no longer equal\nThe third line changes the value of a, but it does not change the value of b, so they are no longer equal.\nTaken together, the variables in a program and their current values make up the program’s state. Figure 2.1 shows the state of the program after these assignment statements run.\n\n\n\n\n\n\n\nMemory diagram of the variables a and b.\n\n\nDiagrams like this one that show the state of the program are called memory diagrams. Each variable is represented with a box showing the name of the variable on the outside and its current value inside.\nAs the program runs, the state of memory changes, so memory diagrams show only a particular point in time. For example, if we added the line int c = 0; to the previous example, the memory diagram would look like Figure 2.2.\n\n\n\n\n\n\n\nMemory diagram of the variables a, b, and c.",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Variables and Operators</span>"
    ]
  },
  {
    "objectID": "ch02.html#sec:printvar",
    "href": "ch02.html#sec:printvar",
    "title": "2  Variables and Operators",
    "section": "2.4 Printing Variables",
    "text": "2.4 Printing Variables\nYou can display the current value of a variable by using print or println. The following statements declare a variable named firstLine, assign it the value \"Hello, again!\", and display that value:\nString firstLine = \"Hello, again!\";\nSystem.out.println(firstLine);\nWhen we talk about displaying a variable, we generally mean the value of the variable. To display the name of a variable, you have to put it in quotes:\nSystem.out.print(\"The value of firstLine is \");\nSystem.out.println(firstLine);\nFor this example, the output is as follows:\nThe value of firstLine is Hello, again!\nConveniently, the code for displaying a variable is the same regardless of its type. For example:\nint hour = 11;\nint minute = 59;\nSystem.out.print(\"The current time is \");\nSystem.out.print(hour);\nSystem.out.print(\":\");\nSystem.out.print(minute);\nSystem.out.println(\".\");\nThe output of this program is shown here:\nThe current time is 11:59.\nTo output multiple values on the same line, it’s common to use several print statements followed by println at the end. But don’t forget the println! On many computers, the output from print is stored without being displayed until println is run; then the entire line is displayed at once. If you omit the println, the program might display the stored output at unexpected times or even terminate without displaying anything.",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Variables and Operators</span>"
    ]
  },
  {
    "objectID": "ch02.html#arithmetic-operators",
    "href": "ch02.html#arithmetic-operators",
    "title": "2  Variables and Operators",
    "section": "2.5 Arithmetic Operators",
    "text": "2.5 Arithmetic Operators\nOperators are symbols that represent simple computations. For example, the addition operator is +, subtraction is -, multiplication is *, and division is /.\nThe following program converts a time of day to minutes:\nint hour = 11;\nint minute = 59;\nSystem.out.print(\"Number of minutes since midnight: \");\nSystem.out.println(hour * 60 + minute);\nThe output is as follows:\nNumber of minutes since midnight: 719\nIn this program, hour * 60 + minute is an expression, which represents a single value to be computed (719). When the program runs, each variable is replaced by its current value, and then the operators are applied. The values that operators work with are called operands.\nExpressions are generally a combination of numbers, variables, and operators. When compiled and executed, they become a single value. For example, the expression 1 + 1 has the value 2. In the expression hour - 1, Java replaces the variable with its value, yielding 11 - 1, which has the value 10.\nIn the expression hour * 60 + minute, both variables get replaced, yielding 11 * 60 + 59. The multiplication happens first, yielding 660 + 59. Then the addition yields 719.\nAddition, subtraction, and multiplication all do what you expect, but you might be surprised by division. For example, the following fragment tries to compute the fraction of an hour that has elapsed:\nSystem.out.print(\"Fraction of the hour that has passed: \");\nSystem.out.println(minute / 60);\nThe output is as follows:\nFraction of the hour that has passed: 0\nThis result often confuses people. The value of minute is 59, and 59 divided by 60 should be 0.98333, not 0. The problem is that Java performs integer division when the operands are integers. By design, integer division always rounds toward zero, even in cases like this one where the next integer is close.\nAs an alternative, we can calculate a percentage rather than a fraction:\nSystem.out.print(\"Percent of the hour that has passed: \");\nSystem.out.println(minute * 100 / 60);\nThe new output is as follows:\nPercent of the hour that has passed: 98\nAgain the result is rounded down, but at least now it’s approximately correct.",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Variables and Operators</span>"
    ]
  },
  {
    "objectID": "ch02.html#floating-point-numbers",
    "href": "ch02.html#floating-point-numbers",
    "title": "2  Variables and Operators",
    "section": "2.6 Floating-Point Numbers",
    "text": "2.6 Floating-Point Numbers\nA more general solution is to use floating-point numbers, which represent values with decimal places. In Java, the default floating-point type is called double, which is short for “double-precision”. You can create double variables and assign values to them the same way we did for the other types:\ndouble pi;\npi = 3.14159;\nJava performs floating-point division when one or more operands are double values. So we can solve the problem from the previous section:\ndouble minute = 59.0;\nSystem.out.print(\"Fraction of the hour that has passed: \");\nSystem.out.println(minute / 60.0);\nThe output is shown here:\nFraction of the hour that has passed: 0.9833333333333333\nAlthough floating-point numbers are useful, they can be a source of confusion. For example, Java distinguishes the integer value 1 from the floating-point value 1.0, even though they seem to be the same number. They belong to different data types, and strictly speaking, you are not allowed to make assignments between types.\nThe following is illegal because the variable on the left is an int and the value on the right is a double:\nint x = 1.1;  // compiler error\nIt is easy to forget this rule, because in many cases Java automatically converts from one type to another:\ndouble y = 1;  // legal, but bad style\nThe preceding example should be illegal, but Java allows it by converting the int value 1 to the double value 1.0 automatically. This leniency is convenient, but it often causes problems for beginners. For example:\ndouble y = 1 / 3;  // common mistake\nYou might expect the variable y to get the value 0.333333, which is a legal floating-point value. But instead it gets the value 0.0. The expression on the right divides two integers, so Java does integer division, which yields the int value 0. Converted to double, the value assigned to y is 0.0.\nOne way to solve this problem (once you figure out the bug) is to make the right-hand side a floating-point expression. The following sets y to 0.333333, as expected:\ndouble y = 1.0 / 3.0;  // correct\nAs a matter of style, you should always assign floating-point values to floating-point variables. The compiler won’t make you do it, but you never know when a simple mistake will come back and haunt you.",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Variables and Operators</span>"
    ]
  },
  {
    "objectID": "ch02.html#rounderr",
    "href": "ch02.html#rounderr",
    "title": "2  Variables and Operators",
    "section": "2.7 Rounding Errors",
    "text": "2.7 Rounding Errors\nMost floating-point numbers are only approximately correct. Some numbers, like reasonably sized integers, can be represented exactly. But repeating fractions, like \\(1/3\\), and irrational numbers, like \\(\\pi\\), cannot. To represent these numbers, computers have to round off to the nearest floating-point number.\nThe difference between the number we want and the floating-point number we get is called rounding error. For example, the following two statements should be equivalent:\nSystem.out.println(0.1 * 10);\nSystem.out.println(0.1 + 0.1 + 0.1 + 0.1 + 0.1\n                 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1);\nBut on many machines, the output is as follows:\n1.0\n0.9999999999999999\nThe problem is that 0.1 is a repeating fraction when converted into binary. So its floating-point representation stored in memory is only approximate. When we add up the approximations, the rounding errors accumulate.\nFor many applications (like computer graphics, encryption, statistical analysis, and multimedia rendering), floating-point arithmetic has benefits that outweigh the costs. But if you need absolute precision, use integers instead. For example, consider a bank account with a balance of $123.45:\ndouble balance = 123.45;  // potential rounding error\nIn this example, balances will become inaccurate over time as the variable is used in arithmetic operations like deposits and withdrawals. The result would be angry customers and potential lawsuits. You can avoid the problem by representing the balance as an integer:\nint balance = 12345;      // total number of cents\nThis solution works as long as the number of cents doesn’t exceed the largest int, which is about 2 billion.",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Variables and Operators</span>"
    ]
  },
  {
    "objectID": "ch02.html#operators-for-strings",
    "href": "ch02.html#operators-for-strings",
    "title": "2  Variables and Operators",
    "section": "2.8 Operators for Strings",
    "text": "2.8 Operators for Strings\nIn general, you cannot perform mathematical operations on strings, even if the strings look like numbers. The following expressions are illegal:\n\"Hello\" - 1     \"World\" / 123     \"Hello\" * \"World\"\nThe + operator works with strings, but it might not do what you expect. For strings, the + operator performs concatenation, which means joining end-to-end. So \"Hello, \" + \"World!\" yields the string \"Hello, World!\".\nLikewise if you have a variable called name that has type String, the expression \"Hello, \" + name appends the value of name to the hello string, which creates a personalized greeting.\nSince addition is defined for both numbers and strings, Java performs automatic conversions you may not expect:\nSystem.out.println(1 + 2 + \"Hello\");\n// the output is 3Hello\n\nSystem.out.println(\"Hello\" + 1 + 2);\n// the output is Hello12\nJava executes these operations from left to right. In the first line, 1 + 2 is 3, and 3 + \"Hello\" is \"3Hello\". But in the second line, \"Hello\" + 1 is \"Hello1\", and \"Hello1\" + 2 is \"Hello12\".\nWhen more than one operator appears in an expression, they are evaluated according to the order of operations. Generally speaking, Java evaluates operators from left to right (as you saw in the previous section). But for numeric operators, Java follows mathematical conventions:\n\nMultiplication and division take “precedence” over addition and subtraction, which means they happen first. So 1 + 2 * 3 yields 7, not 9, and 2 + 4 / 2 yields 4, not 3.\nIf the operators have the same precedence, they are evaluated from left to right. So in the expression minute * 100 / 60, the multiplication happens first; if the value of minute is 59, we get 5900 / 60, which yields 98. If these same operations had gone from right to left, the result would have been 59 * 1, which is incorrect.\nAnytime you want to override the order of operations (or you are not sure what it is) you can use parentheses. Expressions in parentheses are evaluated first, so (1 + 2) * 3 is 9. You can also use parentheses to make an expression easier to read, as in (minute * 100) / 60, even though it doesn’t change the result.\n\nSee the official Java tutorials for a complete table of operator precedence (https://thinkjava.org/operators). If the order of operations is not obvious when looking at an expression, you can always add parentheses to make it more clear. But over time, you should internalize these kinds of details about the Java language.",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Variables and Operators</span>"
    ]
  },
  {
    "objectID": "ch02.html#compiler-error-messages",
    "href": "ch02.html#compiler-error-messages",
    "title": "2  Variables and Operators",
    "section": "2.9 Compiler Error Messages",
    "text": "2.9 Compiler Error Messages\nThree kinds of errors can occur in a program: compile-time errors, run-time errors, and logic errors. It is useful to distinguish among them in order to track them down more quickly.\nCompile-time errors occur when you violate the rules of the Java language. For example, parentheses and braces have to come in matching pairs. So (1 + 2) is legal, but 8) is not. In the latter case, the program cannot be compiled, and the compiler displays a “syntax error”.\nError messages from the compiler usually indicate where in the program the error occurred. Sometimes they can tell you exactly what the error is. As an example, let’s get back to the Hello World program from Section 1.3:\npublic class Hello {\n\n    public static void main(String[] args) {\n        // generate some simple output\n        System.out.println(\"Hello, World!\");\n    }\n}\nIf you forget the semicolon at the end of the print statement, you might get an error message like this:\nFile: Hello.java  [line: 5]\nError: ';' expected\nThat’s pretty good: the location of the error is correct, and the error message tells you what’s wrong. But error messages are not always easy to understand. Sometimes the compiler reports the place in the program where the error was detected, not where it actually occurred. And sometimes the description of the problem is more confusing than helpful.\nFor example, if you forget the closing brace at the end of main (line 6), you might get a message like this:\nFile: Hello.java  [line: 7]\nError: reached end of file while parsing\nThere are two problems here. First, the error message is written from the compiler’s point of view, not yours. Parsing is the process of reading a program before translating; if the compiler gets to the end of the file while still parsing, that means something was omitted. But the compiler doesn’t know what. It also doesn’t know where. The compiler discovers the error at the end of the program (line 7), but the missing brace should be on the previous line.\nError messages contain useful information, so you should make an effort to read and understand them. But don’t take them too literally. During the first few weeks of your programming career, you will probably spend a lot of time tracking down syntax and other compile-time errors. As you gain experience, you will make fewer mistakes and find them more quickly.",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Variables and Operators</span>"
    ]
  },
  {
    "objectID": "ch02.html#exception",
    "href": "ch02.html#exception",
    "title": "2  Variables and Operators",
    "section": "2.10 Other Types of Errors",
    "text": "2.10 Other Types of Errors\nThe second type of error is a run-time error, so-called because it does not appear until after the program has started running. In Java, these errors occur while the interpreter is executing byte code and something goes wrong. These errors are also called “exceptions” because they usually indicate that something unexpected has happened.\nRun-time errors are rare in the simple programs you will see in the first few chapters, so it might be a while before you encounter one. When a run-time error occurs, the program “crashes” (terminates) and displays an error message that explains what happened and where. For example, if you accidentally divide by zero, you will get a message like this:\n\nException in thread \"main\" java.lang.ArithmeticException: / by zero\n    at Hello.main(Hello.java:5)\n\nError messages are very useful for debugging. The first line includes the name of the exception, ArithmeticException, and a message that indicates more specifically what happened, division by zero. The next line shows the method where the error occurred; Hello.main indicates the method main in the class Hello. It also reports the file where the method is defined, Hello.java, and the line number where the error occurred, 5.\nThe third type of error is a logic error. If your program has a logic error, it will compile and run without generating error messages, but it will not do the right thing. Instead, it will do exactly what you told it to do. For example, here is a version of the Hello World program with a logic error:\npublic class Hello {\n\n    public static void main(String[] args) {\n        System.out.println(\"Hello, \");\n        System.out.println(\"World!\");\n    }\n}\nThis program compiles and runs just fine, but the output is as follows:\nHello,\nWorld!\nAssuming that we wanted the output on one line, this is not correct. The problem is that the first line uses println, when we probably meant to use print (see the “Goodbye, cruel world” example of Section [goodbye]).\nIdentifying logic errors can be hard because you have to work backward, looking at the output of the program, trying to figure out why it is doing the wrong thing, and how to make it do the right thing. Usually, the compiler and the interpreter can’t help you, since they don’t know what the right thing is.",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Variables and Operators</span>"
    ]
  },
  {
    "objectID": "ch02.html#vocabulary",
    "href": "ch02.html#vocabulary",
    "title": "2  Variables and Operators",
    "section": "2.11 Vocabulary",
    "text": "2.11 Vocabulary\n\nvariable:\n\nA named storage location for values. All variables have a type, which is declared when the variable is created.\n\nvalue:\n\nA number, string, or other data that can be stored in a variable. Every value belongs to a type (e.g., int or String).\n\ntype:\n\nMathematically speaking, a set of values. The type of a variable determines which values it can have.\n\ndeclaration:\n\nA statement that creates a new variable and specifies its type.\n\nkeyword:\n\nA reserved word used by the compiler to analyze programs. You cannot use keywords (like public, class, and void) as variable names.\n\nassignment:\n\nA statement that gives a value to a variable.\n\ninitialize:\n\nTo assign a variable for the first time.\n\nstate:\n\nThe variables in a program and their current values.\n\nmemory diagram:\n\nA graphical representation of the state of a program at a point in time.\n\noperator:\n\nA symbol that represents a computation like addition, multiplication, or string concatenation.\n\noperand:\n\nOne of the values on which an operator operates. Most operators in Java require two operands.\n\nexpression:\n\nA combination of variables, operators, and values that represents a single value. Expressions also have types, as determined by their operators and operands.\n\nfloating-point:\n\nA data type that represents numbers with an integer part and a fractional part. In Java, the default floating-point type is double.\n\nrounding error:\n\nThe difference between the number we want to represent and the nearest floating-point number.\n\nconcatenate:\n\nTo join two values, often strings, end to end.\n\norder of operations:\n\nThe rules that determine in what order expressions are evaluated. Also known as “operator precedence”.\n\ncompile-time error:\n\nAn error in the source code that makes it impossible to compile. Also called a “syntax error”.\n\nparse:\n\nTo analyze the structure of a program; what the compiler does first.\n\nrun-time error:\n\nAn error in a program that makes it impossible to run to completion. Also called an “exception”.\n\nlogic error:\n\nAn error in a program that makes it do something other than what the programmer intended.",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Variables and Operators</span>"
    ]
  },
  {
    "objectID": "ch02.html#exercises",
    "href": "ch02.html#exercises",
    "title": "2  Variables and Operators",
    "section": "2.12 Exercises",
    "text": "2.12 Exercises\nThe code for this chapter is in the ch02 directory of ThinkJavaCode2. See page  for instructions on how to download the repository. Before you start the exercises, we recommend that you compile and run the examples.\nIf you have not already read Appendix 18.2, now might be a good time. It describes the DrJava Interactions pane, which is a useful way to develop and test short fragments of code without writing a complete class definition.\n\nExercise 2.1. If you are using this book in a class, you might enjoy this exercise. Find a partner and play Stump the Chump:\nStart with a program that compiles and runs correctly. One player looks away, while the other player adds an error to the program. Then the first player tries to find and fix the error. You get two points if you find the error without compiling the program, one point if you find it using the compiler, and your opponent gets a point if you don’t find it.\n\n\nExercise 2.2.\nThe point of this exercise is (1) to use string concatenation to display values with different types (int and String), and (2) to practice developing programs gradually by adding a few statements at a time.\n\nCreate a new program named Date.java. Copy or type in something like the Hello World program and make sure you can compile and run it.\nFollowing the example in Section 2.4, write a program that creates variables named day, date, month, and year. The variable day will contain the day of the week (like Friday), and date will contain the day of the month (like the 13th). Assign values to those variables that represent today’s date.\nDisplay the value of each variable on a line by itself. This is an intermediate step that is useful for checking that everything is working so far. Compile and run your program before moving on.\nModify the program so that it displays the date in standard American format; for example: Thursday, July 18, 2019.\nModify the program so it also displays the date in European format. The final output should be as follows:\nAmerican format: Thursday, July 18, 2019\nEuropean format: Thursday 18 July 2019\n\n\n\nExercise 2.3. The point of this exercise is to (1) use some of the arithmetic operators, and (2) start thinking about compound entities (like time of day) that are represented with multiple values.\n\nCreate a new program called Time.java. From now on, we won’t remind you to start with a small, working program, but you should.\nFollowing the example program in Section 2.4, create variables named hour, minute, and second. Assign values that are roughly the current time. Use a 24-hour clock so that at 2:00 PM the value of hour is 14.\nMake the program calculate and display the number of seconds since midnight.\nCalculate and display the number of seconds remaining in the day.\nCalculate and display the percentage of the day that has passed. You might run into problems when computing percentages with integers, so consider using floating-point.\nChange the values of hour, minute, and second to reflect the current time. Then write code to compute the elapsed time since you started working on this exercise.\n\n**Hint:* You might want to use additional variables to hold values during the computation. Variables that are used in a computation but never displayed are sometimes called “intermediate” or “temporary” variables.*",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Variables and Operators</span>"
    ]
  },
  {
    "objectID": "ch03.html",
    "href": "ch03.html",
    "title": "3  Input and Output",
    "section": "",
    "text": "3.1 The System Class\nWe have been using System.out.println for a while, but you might not have thought about what it means. System is a class that provides methods related to the “system”, or environment, where programs run. It also provides System.out, which is a special value that has additional methods (like println) for displaying output.\nIn fact, we can use System.out.println to display the value of System.out:\nThe result is shown here:\nThis output indicates that System.out is a PrintStream, which is defined in a package called java.io. A package is a collection of related classes; java.io contains classes for I/O which stands for “input and output”.\nThe numbers and letters after the @ sign are the address of System.out, represented as a hexadecimal (base 16) number. The address of a value is its location in the computer’s memory, which might be different on different computers. In this example, the address is 685d72cd, but if you run the same code, you will likely get something else.\nAs shown in Figure 3.1, System is defined in a file called System.java, and PrintStream is defined in PrintStream.java. These files are part of the Java library, which is an extensive collection of classes that you can use in your programs. The source code for these classes is usually included with the compiler (see Section 10.6).",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Input and Output</span>"
    ]
  },
  {
    "objectID": "ch03.html#the-system-class",
    "href": "ch03.html#the-system-class",
    "title": "3  Input and Output",
    "section": "",
    "text": "System.out.println(System.out);\n\njava.io.PrintStream@685d72cd\n\n\n\n\n\n\n\n\n\n\nSystem.out.println refers to the out variable of the System class, which is a PrintStream that provides a method called println.",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Input and Output</span>"
    ]
  },
  {
    "objectID": "ch03.html#scanner",
    "href": "ch03.html#scanner",
    "title": "3  Input and Output",
    "section": "3.2 The Scanner Class",
    "text": "3.2 The Scanner Class\nThe System class also provides the special value System.in, which is an InputStream that has methods for reading input from the keyboard. These methods are not convenient to use, but fortunately Java provides other classes that make it easy to handle common input tasks.\nFor example, Scanner is a class that provides methods for inputting words, numbers, and other data. Scanner is provided by java.util, which is a package that contains various “utility classes”. Before you can use Scanner, you have to import it like this:\nimport java.util.Scanner;\nThis import statement tells the compiler that when you refer to Scanner, you mean the one defined in java.util. Using an import statement is necessary because there might be another class named Scanner in another package.\nNext you have to initialize the Scanner. This line declares a Scanner variable named in and creates a Scanner that reads input from System.in:\nScanner in = new Scanner(System.in);\nThe Scanner class provides a method called nextLine that reads a line of input from the keyboard and returns a String. Here’s a complete example that reads two lines and repeats them back to the user:\nimport java.util.Scanner;\n\npublic class Echo {\n\n    public static void main(String[] args) {\n        String line;\n        Scanner in = new Scanner(System.in);\n\n        System.out.print(\"Type something: \");\n        line = in.nextLine();\n        System.out.println(\"You said: \" + line);\n\n        System.out.print(\"Type something else: \");\n        line = in.nextLine();\n        System.out.println(\"You also said: \" + line);\n    }\n}\nImport statements can’t be inside a class definition. By convention, they are usually at the beginning of the file. If you omit the import statement, you get a compiler error like “cannot find symbol”. That means the compiler doesn’t know where to find the definition for Scanner.\nYou might wonder why we can use the System class without importing it. System belongs to the java.lang package, which is imported automatically. According to the documentation, java.lang “provides classes that are fundamental to the design of the Java programming language.” The String class is also part of java.lang.",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Input and Output</span>"
    ]
  },
  {
    "objectID": "ch03.html#language-elements",
    "href": "ch03.html#language-elements",
    "title": "3  Input and Output",
    "section": "3.3 Language Elements",
    "text": "3.3 Language Elements\nAt this point, we have seen nearly all of the organizational units that make up Java programs. Figure 3.2 shows how these “language elements” are related.\n\n\n\n\n\n\n\nElements of the Java language, from largest to smallest.\n\n\nJava applications are typically organized into packages (like java.io and java.util) that include multiple classes (like PrintStream and Scanner). Each class defines its own methods (like println and nextLine), and each method is a sequence of statements.\nEach statement performs one or more computations, depending on how many expressions it has, and each expression represents a single value to compute. For example, the assignment statement hours = minutes / 60.0; contains a single expression: minutes / 60.0.\nTokens are the most basic elements of a program, including numbers, variable names, operators, keywords, parentheses, braces, and semicolons. In the previous example, the tokens are hours, =, minutes, /, 60.0, and ; (spaces are ignored by the compiler).\nKnowing this terminology is helpful, because error messages often say things like “not a statement” or “illegal start of expression” or “unexpected token”. Comparing Java to English, statements are complete sentences, expressions are phrases, and tokens are individual words and punctuation marks.\nNote there is a big difference between the Java language, which defines the elements in Figure 3.2, and the Java library, which provides the built-in classes that you can import. For example, the keywords public and class are part of the Java language, but the names PrintStream and Scanner are not.\nThe standard edition of Java comes with several thousand classes you can use, which can be both exciting and intimidating. You can browse this library on Oracle’s website (https://thinkjava.org/apidoc). Interestingly, most of the Java library is written in Java.",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Input and Output</span>"
    ]
  },
  {
    "objectID": "ch03.html#literals-and-constants",
    "href": "ch03.html#literals-and-constants",
    "title": "3  Input and Output",
    "section": "3.4 Literals and Constants",
    "text": "3.4 Literals and Constants\nAlthough most of the world has adopted the metric system for weights and measures, some countries are stuck with imperial units. For example, when talking with friends in Europe about the weather, people in the United States might have to convert from Celsius to Fahrenheit and back. Or they might want to convert height in inches to centimeters.\nWe can write a program to help. We’ll use a Scanner to input a measurement in inches, convert to centimeters, and then display the results. The following lines declare the variables and create the Scanner:\nint inch;\ndouble cm;\nScanner in = new Scanner(System.in);\nThe next step is to prompt the user for the input. We’ll use print instead of println so the user can enter the input on the same line as the prompt. And we’ll use the Scanner method nextInt, which reads input from the keyboard and converts it to an integer:\nSystem.out.print(\"How many inches? \");\ninch = in.nextInt();\nNext we multiply the number of inches by 2.54, since that’s how many centimeters there are per inch, and display the results:\ncm = inch * 2.54;\nSystem.out.print(inch + \" in = \");\nSystem.out.println(cm + \" cm\");\nThis code works correctly, but it has a minor problem. If another programmer reads this code, they might wonder where 2.54 comes from. For the benefit of others (and yourself in the future), it would be better to assign this value to a variable with a meaningful name.\nA value that appears in a program, like the number 2.54, is called a literal. In general, there’s nothing wrong with literals. But when numbers like 2.54 appear in an expression with no explanation, they make the code hard to read. And if the same value appears many times and could change in the future, it makes the code hard to maintain.\nValues like 2.54 are sometimes called magic numbers (with the implication that being magic is not a good thing). A good practice is to assign magic numbers to variables with meaningful names, like this:\ndouble cmPerInch = 2.54;\ncm = inch * cmPerInch;\nThis version is easier to read and less error-prone, but it still has a problem. Variables can vary (hence the term), but the number of centimeters in an inch does not. Once we assign a value to cmPerInch, it should never change. Java provides the keyword final, a language feature that enforces this rule:\nfinal double CM_PER_INCH = 2.54;\nDeclaring that a variable is final means that it cannot be reassigned once it has been initialized. If you try, the compiler gives an error.\nVariables declared as final are called constants. By convention, names for constants are all uppercase, with the underscore character (_) between words.",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Input and Output</span>"
    ]
  },
  {
    "objectID": "ch03.html#printf",
    "href": "ch03.html#printf",
    "title": "3  Input and Output",
    "section": "3.5 Formatting Output",
    "text": "3.5 Formatting Output\nWhen you output a double by using print or println, it displays up to 16 decimal places:\nSystem.out.print(4.0 / 3.0);\nThe result is as follows:\n1.3333333333333333\nThat might be more than you want. System.out provides another method, called printf, that gives you more control of the format. The “f” in printf stands for “formatted”. Here’s an example:\nSystem.out.printf(\"Four thirds = %.3f\", 4.0 / 3.0);\nThe first value in the parentheses is a format string that specifies how the output should be displayed. This format string contains ordinary text followed by a format specifier, which is a special sequence that starts with a percent sign. The format specifier \\%.3f indicates that the following value should be displayed as floating-point, rounded to three decimal places:\nFour thirds = 1.333\nThe format string can contain any number of format specifiers; here’s an example with two of them:\nint inch = 100;\ndouble cm = inch * CM_PER_INCH;\nSystem.out.printf(\"%d in = %f cm\\n\", inch, cm);\nThe result is as follows:\n100 in = 254.000000 cm\nLike print, printf does not append a newline. So format strings often end with a newline character.\nThe format specifier \\%d displays integer values (“d” stands for “decimal”, meaning base 10 integer). The values are matched up with the format specifiers in order, so inch is displayed using \\%d, and cm is displayed using \\%f.\nLearning about format strings is like learning a sublanguage within Java. There are many options, and the details can be overwhelming. Table 3.1 lists a few common uses, to give you an idea of how things work.\n\n\n\nExample format specifiers\n\n\n\\%d\nInteger in base 10 (“decimal”)\n12345\n\n\n\n\n\\%,d\nInteger with comma separators\n12,345\n\n\n\\%08d\nPadded with zeros, at least 8 digits wide\n00012345\n\n\n\\%f\nFloating-point number\n6.789000\n\n\n\\%.2f\nRounded to 2 decimal places\n6.79\n\n\n\\%s\nString of characters\n\"Hello\"\n\n\n\\%x\nInteger in base 16 (“hexadecimal”)\nbc614e\n\n\n\n\n\nFor more details, refer to the documentation of java.util.Formatter. The easiest way to find documentation for Java classes is to do a web search for “Java” and the name of the class.",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Input and Output</span>"
    ]
  },
  {
    "objectID": "ch03.html#reading-error-messages",
    "href": "ch03.html#reading-error-messages",
    "title": "3  Input and Output",
    "section": "3.6 Reading Error Messages",
    "text": "3.6 Reading Error Messages\nNotice that the values you pass to printf are separated by commas. If you are used to using the + operator to concatenate strings, you might write something like this by accident:\nSystem.out.printf(\"inches = %d\" + inch);  // error\nThis line of code is legal, so the compiler won’t catch the mistake. Instead, when you run the program, it causes an exception:\n\nException in thread \"main\" java.util.MissingFormatArgumentException:\nFormat specifier '%d'\n    at java.util.Formatter.format(Formatter.java:2519)\n    at java.io.PrintStream.format(PrintStream.java:970)\n    at java.io.PrintStream.printf(PrintStream.java:871)\n    at Example.main(Example.java:10)\n\nAs you saw in Section 2.10, the error message includes the name of the exception, MissingFormatArgumentException, followed by additional details, Format specifier '%d'. That means it doesn’t know what value to substitute for \\%d.\nThe problem is that concatenation happens first, before printf executes. If the value of inch is 100, the result of concatenation is \"inches = %d100\". So printf gets the format string, but it doesn’t get any values to format.\nThe error message also includes a stack trace that shows the method that was running when the error was detected, java.util.Formatter.format; the method that ran it, java.io.PrintStream.format; the method that ran that, java.io.PrintStream.printf; and finally the method you actually wrote, Example.main.\nEach line also names the source file of the method and the line it was on (e.g., Example.java:10). That’s a lot of information, and it includes method names and filenames you have no reason to know at this point. But don’t be overwhelmed.\nWhen you see an error message like this, read the first line carefully to see what happened. Then read the last line to see where it happened. In some IDEs, you can click the error message, and it will take you to the line of code that was running. But remember that where the error is discovered is not always where it was caused.",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Input and Output</span>"
    ]
  },
  {
    "objectID": "ch03.html#type-cast-operators",
    "href": "ch03.html#type-cast-operators",
    "title": "3  Input and Output",
    "section": "3.7 Type Cast Operators",
    "text": "3.7 Type Cast Operators\nNow suppose we have a measurement in centimeters, and we want to round it off to the nearest inch. It is tempting to write this:\ninch = cm / CM_PER_INCH;  // syntax error\nBut the result is an error—you get something like, “incompatible types: possible lossy conversion from double to int”. The problem is that the value on the right is floating-point, and the variable on the left is an integer.\nJava converts an int to a double automatically, since no information is lost in the process. On the other hand, going from double to int would lose the decimal places. Java doesn’t perform this operation automatically in order to ensure that you are aware of the loss of the fractional part of the number.\nThe simplest way to convert a floating-point value to an integer is to use a type cast, so called because it molds, or “casts”, a value from one type to another. The syntax for type casting is to put the name of the type in parentheses and use it as an operator:\ndouble pi = 3.14159;\nint x = (int) pi;\nThe (int) operator has the effect of converting what follows into an integer. In this example, x gets the value 3. Like integer division, casting to an integer always rounds toward zero, even if the fractional part is 0.999999 (or -0.999999). In other words, it simply throws away the fractional part.\nIn order to use a cast operator, the types must be compatible. For example, you can’t cast a String to an int because a string is not a number:\nString str = \"3\";\nint x = (int) str;  // error: incompatible types\nType casting takes precedence over arithmetic operations. In the following example, the value of pi gets converted to an integer before the multiplication:\ndouble pi = 3.14159;\ndouble x = (int) pi * 20.0;  // result is 60.0, not 62.0\nKeeping that in mind, here’s how we can convert centimeters to inches:\ninch = (int) (cm / CM_PER_INCH);\nSystem.out.printf(\"%f cm = %d in\\n\", cm, inch);\nThe parentheses after the cast operator require the division to happen before the type cast. And the result is rounded toward zero. You will see in the next chapter how to round floating-point numbers to the closest integer.",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Input and Output</span>"
    ]
  },
  {
    "objectID": "ch03.html#remainder-operator",
    "href": "ch03.html#remainder-operator",
    "title": "3  Input and Output",
    "section": "3.8 Remainder Operator",
    "text": "3.8 Remainder Operator\nLet’s take the example one step further: suppose you have a measurement in inches and you want to convert to feet and inches. The goal is divide by 12 (the number of inches in a foot) and keep the remainder.\nYou have already seen the division operation (/), which computes the quotient of two numbers. If the numbers are integers, the operation is integer division. Java also provides the modulo operation (\\%), which divides two numbers and computes the remainder.\nUsing division and modulo, we can convert to feet and inches like this:\nfeet = 76 / 12;    // quotient\ninches = 76 % 12;  // remainder\nThe first line yields 6. The second line, which is pronounced “76 mod 12”, yields 4. So 76 inches is 6 feet, 4 inches.\nMany people (and textbooks) incorrectly refer to \\% as the “modulus operator”. In mathematics, however, modulus is the number you’re dividing by. In the previous example, the modulus is 12.\nThe Java language specification refers to \\% as the “remainder operator”. The remainder operator looks like a percent sign, but you might find it helpful to think of it as a division sign (\\(\\div\\)) rotated to the left.\nModular arithmetic turns out to be surprisingly useful. For example, you can check whether one number is divisible by another: if x \\% y is 0, then x is divisible by y. You can use the remainder operator to “extract” digits from a number: x \\% 10 yields the rightmost digit of x, and x \\% 100 yields the last two digits. And many encryption algorithms use remainders extensively.",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Input and Output</span>"
    ]
  },
  {
    "objectID": "ch03.html#putting-it-all-together",
    "href": "ch03.html#putting-it-all-together",
    "title": "3  Input and Output",
    "section": "3.9 Putting It All Together",
    "text": "3.9 Putting It All Together\nAt this point, you have seen enough Java to write useful programs that solve everyday problems. You can (1) import Java library classes, (2) create a Scanner, (3) get input from the keyboard, (4) format output with printf, and (5) divide and mod integers. Now we will put everything together in a complete program:\nimport java.util.Scanner;\n\n/**\n * Converts centimeters to feet and inches.\n */\npublic class Convert {\n\n    public static void main(String[] args) {\n        double cm;\n        int feet, inches, remainder;\n        final double CM_PER_INCH = 2.54;\n        final int IN_PER_FOOT = 12;\n        Scanner in = new Scanner(System.in);\n\n        // prompt the user and get the value\n        System.out.print(\"Exactly how many cm? \");\n        cm = in.nextDouble();\n\n        // convert and output the result\n        inches = (int) (cm / CM_PER_INCH);\n        feet = inches / IN_PER_FOOT;\n        remainder = inches % IN_PER_FOOT;\n        System.out.printf(\"%.2f cm = %d ft, %d in\\n\",\n                          cm, feet, remainder);\n    }\n}\nAlthough not required, all variables and constants are declared at the top of main. This practice makes it easier to find their types later on, and it helps the reader know what data is involved in the algorithm.\nFor readability, each major step of the algorithm is separated by a blank line and begins with a comment. The class also includes a documentation comment (/**), which you can learn more about in Appendix 19.\nMany algorithms, including the Convert program, perform division and modulo together. In both steps, you divide by the same number (IN_PER_FOOT).\nWhen statements including System.out.printf get long (generally wider than 80 characters), a common style convention is to break them across multiple lines. The reader should never have to scroll horizontally.",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Input and Output</span>"
    ]
  },
  {
    "objectID": "ch03.html#the-scanner-bug",
    "href": "ch03.html#the-scanner-bug",
    "title": "3  Input and Output",
    "section": "3.10 The Scanner Bug",
    "text": "3.10 The Scanner Bug\nNow that you’ve had some experience with Scanner, we want to warn you about an unexpected behavior. The following code fragment asks users for their name and age:\nSystem.out.print(\"What is your name? \");\nname = in.nextLine();\nSystem.out.print(\"What is your age? \");\nage = in.nextInt();\nSystem.out.printf(\"Hello %s, age %d\\n\", name, age);\nThe output might look something like this:\nHello Grace Hopper, age 45\nWhen you read a String followed by an int, everything works just fine. But when you read an int followed by a String, something strange happens:\nSystem.out.print(\"What is your age? \");\nage = in.nextInt();\nSystem.out.print(\"What is your name? \");\nname = in.nextLine();\nSystem.out.printf(\"Hello %s, age %d\\n\", name, age);\nTry running this example code. It doesn’t let you input your name, and it immediately displays the output:\nWhat is your name? Hello , age 45\nTo understand what is happening, you need to realize that Scanner doesn’t see input as multiple lines as we do. Instead, it gets a stream of characters as shown in Figure 3.3.\n\n\n\n\n\n\n\nA stream of characters as seen by a Scanner.\n\n\nThe arrow indicates the next character to be read by Scanner. When you run nextInt, it reads characters until it gets to a non-digit. Figure 3.4 shows the state of the stream after nextInt runs.\n\n\n\n\n\n\n\nA stream of characters after nextInt runs.\n\n\nAt this point, nextInt returns the value 45. The program then displays the prompt \"What is your name? \" and runs nextLine, which reads characters until it gets to a newline. But since the next character is already a newline, nextLine returns the empty string \"\".\nTo solve this problem, you need an extra nextLine after nextInt:\nSystem.out.print(\"What is your age? \");\nage = in.nextInt();\nin.nextLine();  // read the newline\nSystem.out.print(\"What is your name? \");\nname = in.nextLine();\nSystem.out.printf(\"Hello %s, age %d\\n\", name, age);\nThis technique is common when reading int or double values that appear on their own line. First you read the number, and then you read the rest of the line, which is just a newline character.",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Input and Output</span>"
    ]
  },
  {
    "objectID": "ch03.html#vocabulary",
    "href": "ch03.html#vocabulary",
    "title": "3  Input and Output",
    "section": "3.11 Vocabulary",
    "text": "3.11 Vocabulary\n\npackage:\n\nA directory of classes that are related to each other.\n\naddress:\n\nThe location of a value in computer memory, often represented as a hexadecimal integer.\n\nlibrary:\n\nA collection of packages and classes that are available for use in other programs.\n\nimport statement:\n\nA statement that allows programs to use classes defined in other packages.\n\ntoken:\n\nThe smallest unit of source code, such as an individual word, literal value, or symbol.\n\nliteral:\n\nA value that appears in source code. For example, \"Hello\" is a string literal, and 74 is an integer literal.\n\nprompt:\n\nA brief message displayed in a print statement that asks the user for input.\n\nmagic number:\n\nA number that appears without explanation as part of an expression. It should generally be replaced with a constant.\n\nconstant:\n\nA variable, declared as final, whose value cannot be changed.\n\nformat string:\n\nThe string in System.out.printf that specifies the format of the output.\n\nformat specifier:\n\nA special code that begins with a percent sign and specifies the data type and format of the corresponding value.\n\nstack trace:\n\nAn error message that shows the methods that were running when an exception occurs.\n\ntype cast:\n\nAn operation that explicitly converts one data type into another. In Java, it appears as a type name in parentheses, like (int).\n\nmodulo:\n\nAn operation that yields the remainder when one integer is divided by another. In Java, it is denoted with a percent sign: 5 \\% 2 is 1.\n\nmodulus:\n\nThe value of b in the expression a \\% b. It often represents unit conversions, such as 24 hours in a day, 60 minutes in an hour, etc.",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Input and Output</span>"
    ]
  },
  {
    "objectID": "ch03.html#exercises",
    "href": "ch03.html#exercises",
    "title": "3  Input and Output",
    "section": "3.12 Exercises",
    "text": "3.12 Exercises\nThe code for this chapter is in the ch03 directory of ThinkJavaCode2. See page  for instructions on how to download the repository. Before you start the exercises, we recommend that you compile and run the examples.\nIf you have not already read Appendix 18.3, now might be a good time. It describes the command-line interface, which is a powerful and efficient way to interact with your computer.\n\nExercise 3.1. When you use printf, the Java compiler does not check your format string. See what happens if you try to display a value with type int using \\%f. And what happens if you display a double using \\%d? What if you use two format specifiers, but then provide only one value?\n\n\nExercise 3.2. Write a program that converts a temperature from Celsius to Fahrenheit. It should (1) prompt the user for input, (2) read a double value from the keyboard, (3) calculate the result, and (4) format the output to one decimal place. When it’s finished, it should work like this:\nEnter a temperature in Celsius: 24\n24.0 C = 75.2 F\nHere is the formula to do the conversion: \\[F = C \\times \\frac{9}{5} + 32\\] Hint:* Be careful not to use integer division!*\n\n\nExercise 3.3. Write a program that converts a total number of seconds to hours, minutes, and seconds. It should (1) prompt the user for input, (2) read an integer from the keyboard, (3) calculate the result, and (4) use printf to display the output. For example, \"5000 seconds = 1 hours, 23 minutes, and 20 seconds\".\n**Hint:* Use the remainder operator.*\n\n\nExercise 3.4.\nThe goal of this exercise is to program a Guess My Number* game. When it’s finished, it should work like this:*\nI'm thinking of a number between 1 and 100\n(including both). Can you guess what it is?\nType a number: 45\nYour guess is: 45\nThe number I was thinking of is: 14\nYou were off by: 31\nTo choose a random number, you can use the Random class in java.util. Here’s how it works:\nimport java.util.Random;\n\npublic class GuessStarter {\n\n    public static void main(String[] args) {\n        // pick a random number\n        Random random = new Random();\n        int number = random.nextInt(100) + 1;\n        System.out.println(number);\n    }\n}\nLike the Scanner class in this chapter, Random has to be imported before we can use it. And as with Scanner, we have to use the new operator to create a Random (number generator).\nThen we can use the method nextInt to generate a random number. In this example, the result of nextInt(100) will be between 0 and 99, including both. Adding 1 yields a number between 1 and 100, including both.\n\nThe definition of GuessStarter is in a file called GuessStarter.java, in the directory called ch03, in the repository for this book.\nCompile and run this program.\nModify the program to prompt the user; then use a Scanner to read a line of user input. Compile and test the program.\nRead the user input as an integer and display the result. Again, compile and test.\nCompute and display the difference between the user’s guess and the number that was generated.",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Input and Output</span>"
    ]
  },
  {
    "objectID": "ch04.html",
    "href": "ch04.html",
    "title": "4  Methods and Testing",
    "section": "",
    "text": "4.1 Defining New Methods\nSome methods perform a computation and return a result. For example, nextDouble reads input from the keyboard and returns it as a double. Other methods, like println, carry out a sequence of actions without returning a result. Java uses the keyword void to define such methods:\nIn this example, the newLine and main methods are both public, which means they can be invoked (or “called”) from other classes. And they are both void, which means that they don’t return a result (in contrast to nextDouble). The output of the program is shown here:\nNotice the extra space between the lines. If we wanted more space between them, we could invoke the same method repeatedly. Or we could write yet another method (named threeLine) that displays three blank lines:\nIn this example, the name of the class is NewLine. By convention, class names begin with a capital letter. NewLine contains three methods, newLine, threeLine, and main. Remember that Java is case-sensitive, so NewLine and newLine are not the same.\nBy convention, method names begin with a lowercase letter and use “camel case”, which is a cute name for jammingWordsTogetherLikeThis. You can use any name you want for methods, except main or any of the Java keywords.",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Methods and Testing</span>"
    ]
  },
  {
    "objectID": "ch04.html#adding_methods",
    "href": "ch04.html#adding_methods",
    "title": "4  Methods and Testing",
    "section": "",
    "text": "public static void newLine() {\n    System.out.println();\n}\n\npublic static void main(String[] args) {\n    System.out.println(\"First line.\");\n    newLine();\n    System.out.println(\"Second line.\");\n}\n\nFirst line.\n\nSecond line.\n\npublic class NewLine {\n\n    public static void newLine() {\n        System.out.println();\n    }\n\n    public static void threeLine() {\n        newLine();\n        newLine();\n        newLine();\n    }\n\n    public static void main(String[] args) {\n        System.out.println(\"First line.\");\n        threeLine();\n        System.out.println(\"Second line.\");\n    }\n}",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Methods and Testing</span>"
    ]
  },
  {
    "objectID": "ch04.html#flow-of-execution",
    "href": "ch04.html#flow-of-execution",
    "title": "4  Methods and Testing",
    "section": "4.2 Flow of Execution",
    "text": "4.2 Flow of Execution\nWhen you look at a class definition that contains several methods, it is tempting to read it from top to bottom. But that is not the flow of execution, or the order the program actually runs. The NewLine program runs methods in the opposite order than they are listed.\nPrograms always begin at the first statement of main, regardless of where it is in the source file. Statements are executed one at a time, in order, until you reach a method invocation, which you can think of as a detour. Instead of going to the next statement, you jump to the first line of the invoked method, execute all the statements there, and then come back and pick up exactly where you left off.\nThat sounds simple enough, but remember that one method can invoke another one. In the middle of main, the previous example goes off to execute the statements in threeLine. While in threeLine, it goes off to execute newLine. Then newLine invokes println, which causes yet another detour.\nFortunately, Java is good at keeping track of which methods are running. So when println completes, it picks up where it left off in newLine; when newLine completes, it goes back to threeLine; and when threeLine completes, it gets back to main.\nBeginners often wonder why it’s worth the trouble to write other methods, when they could just do everything in main. The NewLine example demonstrates a few reasons:\n\nCreating a new method allows you to name a block of statements, which makes the code easier to read and understand.\nIntroducing new methods can make the program shorter by eliminating repetitive code. For example, to display nine consecutive newlines, you could invoke threeLine three times.\nA common problem-solving technique is to break problems down into subproblems. Methods allow you to focus on each subproblem in isolation, and then compose them into a complete solution.\n\nPerhaps most importantly, organizing your code into multiple methods allows you to test individual parts of your program separately. It’s easier to get a complex program working if you know that each method works correctly.",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Methods and Testing</span>"
    ]
  },
  {
    "objectID": "ch04.html#parameters-and-arguments",
    "href": "ch04.html#parameters-and-arguments",
    "title": "4  Methods and Testing",
    "section": "4.3 Parameters and Arguments",
    "text": "4.3 Parameters and Arguments\nSome of the methods we have used require arguments, which are the values you provide in parentheses when you invoke the method.\nFor example, the println method takes a String argument. To display a message, you have to provide the message: System.out.println(\"Hello\"). Similarly, the printf method can take multiple arguments. The statement System.out.printf(\"\\%d in = \\%f cm\\\\n\", inch, cm) has three arguments: the format string, the inch value, and the cm value.\nWhen you invoke a method, you provide the arguments. When you define a method, you name the parameters, which are variables that indicate what arguments are required. The following class shows an example:\npublic class PrintTwice {\n\n    public static void printTwice(String s) {\n        System.out.println(s);\n        System.out.println(s);\n    }\n\n    public static void main(String[] args) {\n        printTwice(\"Don't make me say this twice!\");\n    }\n}\nThe printTwice method has a parameter named s with type String. When you invoke printTwice, you have to provide an argument with type String.\nBefore the method executes, the argument gets assigned to the parameter. In the printTwice example, the argument \"Don't make me say this twice!\" gets assigned to the parameter s.\nThis process is called parameter passing, because the value gets passed from outside the method to the inside. An argument can be any kind of expression, so if you have a String variable, you can use its value as an argument:\nString message = \"Never say never.\";\nprintTwice(message);\nThe value you provide as an argument must have the same (or compatible) type as the parameter. For example, if you try this:\nprintTwice(17);  // syntax error\nYou will get an error message like this:\nFile: Test.java  [line: 10]\nError: method printTwice in class Test cannot be applied\n       to given types;\n  required: java.lang.String\n  found: int\n  reason: actual argument int cannot be converted to\n          java.lang.String by method invocation conversion\nThis error message says that it found an int argument, but the required parameter should be a String. In the case of printTwice, Java won’t convert the integer 17 to the string \"17\" automatically.\nSometimes Java can convert an argument from one type to another automatically. For example, Math.sqrt requires a double, but if you invoke Math.sqrt(25), the integer value 25 is automatically converted to the floating-point value 25.0.\nParameters and other variables exist only inside their own methods. In the printTwice example, there is no such thing as s in the main method. If you try to use it there, you’ll get a compiler error.\nSimilarly, inside printTwice there is no such thing as message. That variable belongs to main. Because variables exist only inside the methods where they are defined, they are often called local variables.",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Methods and Testing</span>"
    ]
  },
  {
    "objectID": "ch04.html#multparam",
    "href": "ch04.html#multparam",
    "title": "4  Methods and Testing",
    "section": "4.4 Multiple Parameters",
    "text": "4.4 Multiple Parameters\nHere is an example of a method that takes two parameters:\npublic static void printTime(int hour, int minute) {\n    System.out.print(hour);\n    System.out.print(\":\");\n    System.out.println(minute);\n}\nTo invoke this method, we have to provide two integers as arguments:\nint hour = 11;\nint minute = 59;\nprintTime(hour, minute);\nBeginners sometimes make the mistake of declaring the arguments:\nint hour = 11;\nint minute = 59;\nprintTime(int hour, int minute);  // syntax error\nThat’s a syntax error, because the compiler sees int hour and int minute as variable declarations, not expressions that represent values. You wouldn’t declare the types of the arguments if they were simply integers:\nprintTime(int 11, int 59);  // syntax error\nPulling together the code fragments, here is the complete program:\npublic class PrintTime {\n\n    public static void printTime(int hour, int minute) {\n        System.out.print(hour);\n        System.out.print(\":\");\n        System.out.println(minute);\n    }\n\n    public static void main(String[] args) {\n        int hour = 11;\n        int minute = 59;\n        printTime(hour, minute);\n    }\n}\nprintTime has two parameters, named hour and minute. And main has two variables, also named hour and minute. Although they have the same names, these variables are not the same. The hour in printTime and the hour in main refer to different memory locations, and they can have different values.\nFor example, you could invoke printTime like this:\nint hour = 11;\nint minute = 59;\nprintTime(hour + 1, 0);\nBefore the method is invoked, Java evaluates the arguments; in this example, the results are 12 and 0. Then it assigns those values to the parameters. Inside printTime, the value of hour is 12, not 11, and the value of minute is 0, not 59. Furthermore, if printTime modifies one of its parameters, that change has no effect on the variables in main.",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Methods and Testing</span>"
    ]
  },
  {
    "objectID": "ch04.html#stack",
    "href": "ch04.html#stack",
    "title": "4  Methods and Testing",
    "section": "4.5 Stack Diagrams",
    "text": "4.5 Stack Diagrams\nOne way to keep track of variables is to draw a stack diagram, which is a memory diagram (see Section 2.3) that shows currently running methods. For each method there is a box, called a frame, that contains the method’s parameters and local variables. The name of the method appears outside the frame; the variables and parameters appear inside.\nAs with memory diagrams, stack diagrams show variables and methods at a particular point in time. Figure 4.1 is a stack diagram at the beginning of the printTime method. Notice that main is on top, because it executed first.\n\n\n\n\n\n\n\nStack diagram for printTime(hour + 1, 0).\n\n\nStack diagrams help you to visualize the scope of a variable, which is the area of a program where a variable can be used.\nStack diagrams are a good mental model for how variables and methods work at run-time. Learning to trace the execution of a program on paper (or on a whiteboard) is a useful skill for communicating with other programmers.\nEducational tools can automatically draw stack diagrams for you. For example, Java Tutor (https://thinkjava.org/javatutor) allows you to step through an entire program, both forward and backward, and see the stack frames and variables at each step. If you haven’t already, you should check out the Java examples on that website.",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Methods and Testing</span>"
    ]
  },
  {
    "objectID": "ch04.html#mathmeth",
    "href": "ch04.html#mathmeth",
    "title": "4  Methods and Testing",
    "section": "4.6 Math Methods",
    "text": "4.6 Math Methods\nYou don’t always have to write new methods to get work done. As a reminder, the Java library contains thousands of classes you can use. For example, the Math class provides common mathematical operations:\ndouble root = Math.sqrt(17.0);\ndouble angle = 1.5;\ndouble height = Math.sin(angle);\nThe first line sets root to the square root of 17. The third line finds the sine of 1.5 (the value of angle). Math is in the java.lang package, so you don’t have to import it.\nValues for the trigonometric functions—sin, cos, and tan—must be in radians. To convert from degrees to radians, you divide by 180 and multiply by \\(\\pi\\). Conveniently, the Math class provides a constant named PI that contains an approximation of \\(\\pi\\):\ndouble degrees = 90;\ndouble angle = degrees / 180.0 * Math.PI;\nNotice that PI is in capital letters. Java does not recognize Pi, pi, or pie. Also, PI is the name of a constant, not a method, so it doesn’t have parentheses. The same is true for the constant Math.E, which approximates Euler’s number.\nConverting to and from radians is a common operation, so the Math class provides methods that do that for you:\ndouble radians = Math.toRadians(180.0);\ndouble degrees = Math.toDegrees(Math.PI);\nAnother useful method is round, which rounds a floating-point value to the nearest integer and returns a long. The following result is 63 (rounded up from 62.8319):\nlong x = Math.round(Math.PI * 20.0);\nA long is like an int, but bigger. More specifically, an int uses 32 bits of memory; the largest value it can hold is \\(2^{31}-1\\), which is about 2 billion. A long uses 64 bits, so the largest value is \\(2^{63}-1\\), which is about 9 quintillion.\nTake a minute to read the documentation for these and other methods in the Math class. The easiest way to find documentation for Java classes is to do a web search for “Java” and the name of the class.",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Methods and Testing</span>"
    ]
  },
  {
    "objectID": "ch04.html#composition",
    "href": "ch04.html#composition",
    "title": "4  Methods and Testing",
    "section": "4.7 Composition",
    "text": "4.7 Composition\nYou have probably learned how to evaluate simple expressions like \\(\\sin(\\pi/2)\\) and \\(\\log(1/x)\\). First, you evaluate the expression in parentheses, which is the argument of the function. Then you can evaluate the function itself, either by hand or by punching it into a calculator.\nThis process can be applied repeatedly to evaluate more-complex expressions like \\(\\log(1/\\sin(\\pi/2))\\). First we evaluate the argument of the innermost function (\\(\\pi/2 = 1.57\\)), then evaluate the function itself (\\(\\sin(1.57) = 1.0\\)), and so on.\nJust as with mathematical functions, Java methods can be composed to solve complex problems. That means you can use one method as part of another. In fact, you can use any expression as an argument to a method, as long as the resulting value has the correct type:\ndouble x = Math.cos(angle + Math.PI / 2.0);\nThis statement divides Math.PI by 2.0, adds the result to angle, and computes the cosine of the sum. You can also take the result of one method and pass it as an argument to another:\ndouble x = Math.exp(Math.log(10.0));\nIn Java, the log method always uses base \\(e\\). So this statement finds the log base \\(e\\) of 10, and then raises \\(e\\) to that power. The result gets assigned to x.\nSome math methods take more than one argument. For example, Math.pow takes two arguments and raises the first to the power of the second. This line computes \\(2^{10}\\) and assigns the value 1024.0 to the variable x:\ndouble x = Math.pow(2.0, 10.0);\nWhen using Math methods, beginners often forget the word Math. For example, if you just write x = pow(2.0, 10.0), you will get a compiler error:\nFile: Test.java  [line: 5]\nError: cannot find symbol\n  symbol:   method pow(double,double)\n  location: class Test\nThe message “cannot find symbol” is confusing, but the last two lines provide a useful hint. The compiler is looking for a method named pow in the file Test.java (the file for this example). If you don’t specify a class name when referring to a method, the compiler looks in the current class by default.",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Methods and Testing</span>"
    ]
  },
  {
    "objectID": "ch04.html#return-values",
    "href": "ch04.html#return-values",
    "title": "4  Methods and Testing",
    "section": "4.8 Return Values",
    "text": "4.8 Return Values\nWhen you invoke a void method, the invocation is usually on a line all by itself. For example:\nprintTime(hour + 1, 0);\nOn the other hand, when you invoke a value-returning method, you have to do something with the return value. We usually assign it to a variable or use it as part of an expression, like this:\ndouble error = Math.abs(expect - actual);\ndouble height = radius * Math.sin(angle);\nCompared to void methods, value-returning methods differ in two ways:\n\nThey declare the type of the return value (the return type).\nThey use at least one return statement to provide a return value.\n\nHere’s an example from a program named Circle.java. The calculateArea method takes a double as a parameter and returns the area of a circle with that radius (i.e., \\(\\pi r^2\\)):\npublic static double calculateArea(double radius) {\n    double result = Math.PI * radius * radius;\n    return result;\n}\nAs usual, this method is public and static. But in the place where we are used to seeing void, we see double, which means that the return value from this method is a double.\nThe last line is a new form of the return statement that means, “Return immediately from this method, and use the following expression as the return value.” The expression you provide can be arbitrarily complex, so we could have written this method more concisely:\npublic static double calculateArea(double radius) {\n    return Math.PI * radius * radius;\n}\nOn the other hand, temporary variables like result often make debugging easier, especially when you are stepping through code by using an interactive debugger (see Appendix 18.6).\nFigure 4.2 illustrates how data values flows through the program. When the main method invokes calculateArea, the value 5.0 is assigned to the parameter radius. calculateArea then returns the value 78.54, which is assigned to the variable area.\n\n\n\n\n\n\n\nPassing a parameter and saving the return value.\n\n\nThe type of the expression in the return statement must match the return type of the method itself. When you declare that the return type is double, you are making a promise that this method will eventually produce a double value. If you try to return with no expression, or return an expression with the wrong type, the compiler will give an error.",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Methods and Testing</span>"
    ]
  },
  {
    "objectID": "ch04.html#distance",
    "href": "ch04.html#distance",
    "title": "4  Methods and Testing",
    "section": "4.9 Incremental Development",
    "text": "4.9 Incremental Development\nPeople often make the mistake of writing a lot of code before they try to compile and run it. Then they spend way too much time debugging. A better approach is incremental development. Its key aspects are as follows:\n\nStart with a working program and make small, incremental changes. At any point, if there is an error, you will know where to look.\nUse variables to hold intermediate values so you can check them, either with print statements or by using a debugger.\nOnce the program is working, you can consolidate multiple statements into compound expressions (but only if it does not make the program more difficult to read).\n\nAs an example, suppose you want to find the distance between two points, given by the coordinates \\((x_1, y_1)\\) and \\((x_2, y_2)\\). By the usual definition:\n\\[distance = \\sqrt{(x_2 - x_1)^2 +(y_2 - y_1)^2}\\]\nThe first step is to consider what a distance method should look like in Java. In other words, what are the inputs (parameters) and what is the output (return value)? For this method, the parameters are the two points, and it is natural to represent them using four double values. The return value is the distance, which should also have type double.\nAlready we can write an outline for the method, which is sometimes called a stub. The stub includes the method declaration and a return statement:\npublic static double distance\n        (double x1, double y1, double x2, double y2) {\n    return 0.0;  // stub\n}\nThe return statement is a placeholder that is necessary only for the program to compile. At this stage, the program doesn’t do anything useful, but it is good to compile it so we can find any syntax errors before we add more code.\nIt’s usually a good idea to think about testing before you develop new methods; doing so can help you figure out how to implement them. To test the method, we can invoke it from main by using the sample values:\ndouble dist = distance(1.0, 2.0, 4.0, 6.0);\nWith these values, the horizontal distance is 3.0 and the vertical distance is 4.0. So the result should be 5.0, the hypotenuse of a 3-4-5 triangle. When you are testing a method, it is necessary to know the right answer.\nOnce we have compiled the stub, we can start adding code one line at a time. After each incremental change, we recompile and run the program. If there is an error, we have a good idea of where to look: the lines we just added.\nThe next step is to find the differences, \\(x_2 - x_1\\) and \\(y_2 - y_1\\). We store those values in temporary variables named dx and dy, so that we can examine them with print statements before proceeding. They should be 3.0 and 4.0:\npublic static double distance\n        (double x1, double y1, double x2, double y2) {\n    double dx = x2 - x1;\n    double dy = y2 - y1;\n    System.out.println(\"dx is \" + dx);\n    System.out.println(\"dy is \" + dy);\n    return 0.0;  // stub\n}\nWe will remove the print statements when the method is finished. Code like that is called scaffolding, because it is helpful for building the program but is not part of the final product.\nThe next step is to square dx and dy. We could use the Math.pow method, but it is simpler (and more efficient) to multiply each term by itself. Then we add the squares and print the result so far:\npublic static double distance\n        (double x1, double y1, double x2, double y2) {\n    double dx = x2 - x1;\n    double dy = y2 - y1;\n    double dsquared = dx * dx + dy * dy;\n    System.out.println(\"dsquared is \" + dsquared);\n    return 0.0;  // stub\n}\nAgain, you should compile and run the program at this stage and check the intermediate value, which should be 25.0. Finally, we can use Math.sqrt to compute and return the result:\npublic static double distance\n        (double x1, double y1, double x2, double y2) {\n    double dx = x2 - x1;\n    double dy = y2 - y1;\n    double dsquared = dx * dx + dy * dy;\n    double result = Math.sqrt(dsquared);\n    return result;\n}\nAs you gain more experience programming, you might write and debug more than one line at a time. But if you find yourself spending a lot of time debugging, consider taking smaller steps.",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Methods and Testing</span>"
    ]
  },
  {
    "objectID": "ch04.html#vocabulary",
    "href": "ch04.html#vocabulary",
    "title": "4  Methods and Testing",
    "section": "4.10 Vocabulary",
    "text": "4.10 Vocabulary\n\nvoid:\n\nA special return type indicating the method does not return a value.\n\ninvoke:\n\nTo cause a method to execute. Also known as “calling” a method.\n\nflow of execution:\n\nThe order in which Java executes methods and statements. It may not necessarily be from top to bottom in the source file.\n\nargument:\n\nA value that you provide when you call a method. This value must have the type that the method expects.\n\nparameter:\n\nA piece of information that a method requires before it can run. Parameters are variables: they contain values and have types.\n\nparameter passing:\n\nThe process of assigning an argument value to a parameter variable.\n\nlocal variable:\n\nA variable declared inside a method. Local variables cannot be accessed from outside their method.\n\nstack diagram:\n\nA graphical representation of the variables belonging to each method. The method calls are “stacked” from top to bottom, in the flow of execution.\n\nframe:\n\nIn a stack diagram, a representation of the variables and parameters for a method, along with their current values.\n\nscope:\n\nThe area of a program where a variable can be used.\n\ncomposition:\n\nThe ability to combine simple expressions and statements into compound expressions and statements.\n\nreturn type:\n\nThe type of value a method returns.\n\nreturn value:\n\nThe value provided as the result of a method invocation.\n\ntemporary variable:\n\nA short-lived variable, often used for debugging.\n\nincremental development:\n\nA process for creating programs by writing a few lines at a time, compiling, and testing.\n\nstub:\n\nA placeholder for an incomplete method so that the class will compile.\n\nscaffolding:\n\nCode that is used during program development but is not part of the final version.",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Methods and Testing</span>"
    ]
  },
  {
    "objectID": "ch04.html#exercises",
    "href": "ch04.html#exercises",
    "title": "4  Methods and Testing",
    "section": "4.11 Exercises",
    "text": "4.11 Exercises\nThe code for this chapter is in the ch04 directory of ThinkJavaCode2. See page  for instructions on how to download the repository. Before you start the exercises, we recommend that you compile and run the examples.\nIf you have not already read Appendix 18.4, now might be a good time. It describes an efficient way to test programs that take input from the user and display specific output.\n\nExercise 4.1. The purpose of this exercise is to take code from a previous exercise and redesign it as a method that takes parameters. Start with a working solution to Exercise 2.2.\n\nWrite a method called printAmerican that takes the day, date, month, and year as parameters and displays them in American format.\nTest your method by invoking it from main and passing appropriate arguments. The output should look something like this (except the date might be different):\nMonday, July 22, 2019\nOnce you have debugged printAmerican, write another method called printEuropean that displays the date in European format.\n\n\n\nExercise 4.2. This exercise reviews the flow of execution through a program with multiple methods. Read the following code and answer the questions:\npublic static void main(String[] args) {\n    zippo(\"rattle\", 13);\n}\npublic static void baffle(String blimp) {\n    System.out.println(blimp);\n    zippo(\"ping\", -5);\n}\npublic static void zippo(String quince, int flag) {\n    if (flag &lt; 0) {\n        System.out.println(quince + \" zoop\");\n    } else {\n        System.out.println(\"ik\");\n        baffle(quince);\n        System.out.println(\"boo-wa-ha-ha\");\n    }\n}\n\nWrite the number 1 next to the first line of code in this program that will execute.\nWrite the number 2 next to the second line of code, and so on until the end of the program. If a line is executed more than once, it might end up with more than one number next to it.\nWhat is the value of the parameter blimp when baffle gets invoked?\nWhat is the output of this program?\n\n\n\nExercise 4.3. Answer the following questions without running the program on a computer.\n\nDraw a stack diagram that shows the state of the program the first time ping is invoked.\nWhat is output by the following program? Be precise about the placement of spaces and newlines.\n\npublic static void zoop() {\n    baffle();\n    System.out.print(\"You wugga \");\n    baffle();\n}\npublic static void main(String[] args) {\n    System.out.print(\"No, I \");\n    zoop();\n    System.out.print(\"I \");\n    baffle();\n}\npublic static void baffle() {\n    System.out.print(\"wug\");\n    ping();\n}\npublic static void ping() {\n    System.out.println(\".\");\n}\n\n\nExercise 4.4. If you have a question about whether something is legal, and what happens if it is not, a good way to find out is to ask the compiler. Answer the following questions by trying them out.\n\nWhat happens if you invoke a value method and don’t do anything with the result; that is, if you don’t assign it to a variable or use it as part of a larger expression?\nWhat happens if you use a void method as part of an expression? For example, try System.out.println(\"boo!\") + 7;.\n\n\n\nExercise 4.5. Draw a stack diagram that shows the state of the program the second* time zoop is invoked. What is the complete output?*\npublic static void zoop(String fred, int bob) {\n    System.out.println(fred);\n    if (bob == 5) {\n        ping(\"not \");\n    } else {\n        System.out.println(\"!\");\n    }\n}\npublic static void main(String[] args) {\n    int bizz = 5;\n    int buzz = 2;\n    zoop(\"just for\", bizz);\n    clink(2 * buzz);\n}\npublic static void clink(int fork) {\n    System.out.print(\"It's \");\n    zoop(\"breakfast \", fork);\n}\npublic static void ping(String strangStrung) {\n    System.out.println(\"any \" + strangStrung + \"more \");\n}\n\n\nExercise 4.6. Many computations can be expressed more concisely using the “multadd” operation, which takes three operands and computes a * b + c. Some processors even provide a hardware implementation of this operation for floating-point numbers.\n\nCreate a new program called Multadd.java.\nWrite a method called multadd that takes three doubles as parameters and returns a * b + c.\nWrite a main method that tests multadd by invoking it with a few simple parameters, like 1.0, 2.0, 3.0.\nAlso in main, use multadd to compute the following values: \\[\\begin{aligned}\n& \\sin \\frac{\\pi}{4} + \\frac{\\cos \\frac{\\pi}{4}}{2} & \\\\\n& \\log 10 + \\log 20 &\n\\end{aligned}\\]\nWrite a method called expSum that takes a double as a parameter and uses multadd to calculate: \\[\\begin{aligned}\nx e^{-x} + \\sqrt{1 - e^{-x}}\n\\end{aligned}\\] Hint:* The method for raising \\(e\\) to a power is Math.exp.*\n\nIn the last part of this exercise, you need to write a method that invokes another method you wrote. Whenever you do that, it is a good idea to test the first method carefully before working on the second. Otherwise, you might find yourself debugging two methods at the same time, which can be difficult.\nOne of the purposes of this exercise is to practice pattern-matching: the ability to recognize a specific problem as an instance of a general category of problems.",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Methods and Testing</span>"
    ]
  },
  {
    "objectID": "ch05.html",
    "href": "ch05.html",
    "title": "5  Conditionals and Logic",
    "section": "",
    "text": "5.1 Relational Operators\nJava has six relational operators that test the relationship between two values (e.g., whether they are equal, or whether one is greater than the other). The following expressions show how they are used:\nThe result of a relational operator is one of two special values: true or false. These values belong to the data type boolean, named after the mathematician George Boole. He developed an algebraic way of representing logic.\nYou are probably familiar with these operators, but notice how Java is different from mathematical symbols like \\(=\\), \\(\\neq\\), and \\(\\geq\\). A common error is to use a single = instead of a double == when comparing values. Remember that = is the assignment operator, and == is a relational operator. Also, the operators =&lt; and =&gt; do not exist.\nThe two sides of a relational operator have to be compatible. For example, the expression 5 &lt; \"6\" is invalid because 5 is an int and \"6\" is a String. When comparing values of different numeric types, Java applies the same conversion rules you saw previously with the assignment operator. For example, when evaluating the expression 5 &lt; 6.0, Java automatically converts the 5 to 5.0.",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Conditionals and Logic</span>"
    ]
  },
  {
    "objectID": "ch05.html#relational-operators",
    "href": "ch05.html#relational-operators",
    "title": "5  Conditionals and Logic",
    "section": "",
    "text": "x == y          // x is equal to y\nx != y          // x is not equal to y\nx &gt; y           // x is greater than y\nx &lt; y           // x is less than y\nx &gt;= y          // x is greater than or equal to y\nx &lt;= y          // x is less than or equal to y",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Conditionals and Logic</span>"
    ]
  },
  {
    "objectID": "ch05.html#the-if-else-statement",
    "href": "ch05.html#the-if-else-statement",
    "title": "5  Conditionals and Logic",
    "section": "5.2 The if-else Statement",
    "text": "5.2 The if-else Statement\nTo write useful programs, we almost always need to check conditions and react accordingly. Conditional statements give us this ability. The simplest conditional statement in Java is the if statement:\nif (x &gt; 0) {\n    System.out.println(\"x is positive\");\n}\nThe expression in parentheses is called the condition. If it is true, the statements in braces get executed. If the condition is false, execution skips over that block of code. The condition in parentheses can be any boolean expression.\nA second form of conditional statement has two possibilities, indicated by if and else. The possibilities are called branches, and the condition determines which branch gets executed:\nif (x % 2 == 0) {\n    System.out.println(\"x is even\");\n} else {\n    System.out.println(\"x is odd\");\n}\nIf the remainder when x is divided by 2 is 0, we know that x is even, and the program displays a message to that effect. If the condition is false, the second print statement is executed instead. Since the condition must be true or false, exactly one of the branches will run.\nThe braces are optional for branches that have only one statement. So we could have written the previous example this way:\nif (x % 2 == 0)\n    System.out.println(\"x is even\");\nelse\n    System.out.println(\"x is odd\");\nHowever, it’s better to use braces—even when they are optional—to avoid making the mistake of adding statements to a one-line if or else block. This code is misleading because it’s not indented correctly:\nif (x &gt; 0)\n    System.out.println(\"x is positive\");\n    System.out.println(\"x is not zero\");\nSince there are no braces, only the first println is part of the if statement. Here is what the compiler actually sees:\nif (x &gt; 0) {\n    System.out.println(\"x is positive\");\n}\n    System.out.println(\"x is not zero\");\nAs a result, the second println runs no matter what. Even experienced programmers make this mistake; search the web for Apple’s “goto fail” bug.\nIn all previous examples, notice that there is no semicolon at the end of the if or else lines. Instead, a new block should be defined using braces. Another common mistake is to put a semicolon after the condition, like this:\nint x = 1;\nif (x % 2 == 0); {  // incorrect semicolon\n    System.out.println(\"x is even\");\n}\nThis code will compile, but the program will output \"x is even\" regardless of the value of x. Here is the same incorrect code with better formatting:\nint x = 1;\nif (x % 2 == 0)\n    ;  // empty statement\n{\n    System.out.println(\"x is even\");\n}\nBecause of the semicolon, the if statement compiles as if there are no braces, and the subsequent block runs independently. As a general rule, each line of Java code should end with a semicolon or brace—but not both.\nThe compiler won’t complain if you omit optional braces or write empty statements. Doing so is allowed by the Java language, but it often results in bugs that are difficult to find. Development tools like Checkstyle (see Appendix 18.5) can warn you about these and other kinds of programming mistakes.",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Conditionals and Logic</span>"
    ]
  },
  {
    "objectID": "ch05.html#chaining-and-nesting",
    "href": "ch05.html#chaining-and-nesting",
    "title": "5  Conditionals and Logic",
    "section": "5.3 Chaining and Nesting",
    "text": "5.3 Chaining and Nesting\nSometimes you want to check related conditions and choose one of several actions. One way to do this is by chaining a series of if and else blocks:\nif (x &gt; 0) {\n    System.out.println(\"x is positive\");\n} else if (x &lt; 0) {\n    System.out.println(\"x is negative\");\n} else {\n    System.out.println(\"x is zero\");\n}\nThese chains can be as long as you want, although they can be difficult to read if they get out of hand. One way to make them easier to read is to use standard indentation, as demonstrated in these examples. If you keep all the statements and braces lined up, you are less likely to make syntax errors.\nNotice that the last branch is simply else, not else if (x == 0). At this point in the chain, we know that x is not positive and x is not negative. There is no need to test whether x is 0, because there is no other possibility.\nIn addition to chaining, you can also make complex decisions by nesting one conditional statement inside another. We could have written the previous example as follows:\nif (x &gt; 0) {\n    System.out.println(\"x is positive\");\n} else {\n    if (x &lt; 0) {\n        System.out.println(\"x is negative\");\n    } else {\n        System.out.println(\"x is zero\");\n    }\n}\nThe outer conditional has two branches. The first branch contains a print statement, and the second branch contains another conditional statement, which has two branches of its own. These two branches are also print statements, but they could have been conditional statements as well.\nThese kinds of nested structures are common, but they can become difficult to read very quickly. Good indentation is essential to make the structure (or intended structure) apparent to the reader.",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Conditionals and Logic</span>"
    ]
  },
  {
    "objectID": "ch05.html#the-switch-statement",
    "href": "ch05.html#the-switch-statement",
    "title": "5  Conditionals and Logic",
    "section": "5.4 The switch Statement",
    "text": "5.4 The switch Statement\nIf you need to make a series of decisions, chaining else if blocks can get long and redundant. For example, consider a program that converts integers like 1, 2, and 3 into words like \"one\", \"two\", and \"three\":\nif (number == 1) {\n    word = \"one\";\n} else if (number == 2) {\n    word = \"two\";\n} else if (number == 3) {\n    word = \"three\";\n} else {\n    word = \"unknown\";\n}\nThis chain could go on and on, especially for banking programs that write numbers in long form (e.g., “one hundred twenty-three and 45/100 dollars”). An alternative way to evaluate many possible values of an expression is to use a switch statement:\nswitch (number) {\n    case 1:\n        word = \"one\";\n        break;\n    case 2:\n        word = \"two\";\n        break;\n    case 3:\n        word = \"three\";\n        break;\n    default:\n        word = \"unknown\";\n        break;\n}\nThe body of a switch statement is organized into one or more case blocks. Each case ends with a break statement, which exits the switch body. The default block is optional and executed only if none of the cases apply.\nAlthough switch statements appear longer than chained else if blocks, they are particularly useful when multiple cases can be grouped:\nswitch (food) {\n    case \"apple\":\n    case \"banana\":\n    case \"cherry\":\n        System.out.println(\"Fruit!\");\n        break;\n    case \"asparagus\":\n    case \"broccoli\":\n    case \"carrot\":\n        System.out.println(\"Vegetable!\");\n        break;\n}",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Conditionals and Logic</span>"
    ]
  },
  {
    "objectID": "ch05.html#logical-operators",
    "href": "ch05.html#logical-operators",
    "title": "5  Conditionals and Logic",
    "section": "5.5 Logical Operators",
    "text": "5.5 Logical Operators\nIn addition to the relational operators, Java also has three logical operators: &&, ||, and !, which respectively stand for and, or, and not. The results of these operators are similar to their meanings in English. For example:\n\nx &gt; 0 && x &lt; 10 is true when x is greater than 0 and less than 10.\nx &lt; 0 || x &gt; 10 is true if either condition is true; that is, if x is less than 0 or greater than 10.\n!(x &gt; 0) is true if x is not greater than 0. The parentheses are necessary in this example because, in the order of operations, ! comes before &gt;.\n\nIn order for an expression with && to be true, both sides of the && operator must be true. And in order for an expression with || to be false, both sides of the || operator must be false.\nThe && operator can be used to simplify nested if statements. For example, the following code can be rewritten with a single condition:\nif (x == 0) {\n    if (y == 0) {\n        System.out.println(\"Both x and y are zero\");\n    }\n}\n// combined\nif (x == 0 && y == 0) {\n    System.out.println(\"Both x and y are zero\");\n}\nLikewise, the || operator can simplify chained if statements. Since the branches are the same, there is no need to duplicate that code:\nif (x == 0) {\n    System.out.println(\"Either x or y is zero\");\n} else if (y == 0) {\n    System.out.println(\"Either x or y is zero\");\n}\n// combined\nif (x == 0 || y == 0) {\n    System.out.println(\"Either x or y is zero\");\n}\nThen again, if the statements in the branches were different, we could not combine them into one block. But it’s useful to explore different ways of representing the same logic, especially when it’s complex.\n\nLogical operators evaluate the second expression only when necessary. For example, true || anything is always true, so Java does not need to evaluate the expression anything. Likewise, false && anything is always false.\nIgnoring the second operand, when possible, is called short-circuit evaluation, by analogy with an electrical circuit. Short-circuit evaluation can save time, especially if anything takes a long time to evaluate. It can also avoid unnecessary errors, if anything might fail.",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Conditionals and Logic</span>"
    ]
  },
  {
    "objectID": "ch05.html#de-morgans-laws",
    "href": "ch05.html#de-morgans-laws",
    "title": "5  Conditionals and Logic",
    "section": "5.6 De Morgan’s Laws",
    "text": "5.6 De Morgan’s Laws\nSometimes you need to negate an expression containing a mix of relational and logical operators. For example, to test if x and y are both nonzero, you could write the following:\nif (!(x == 0 || y == 0)) {\n    System.out.println(\"Neither x nor y is zero\");\n}\nThis condition is difficult to read because of the ! and parentheses. A better way to negate logic expressions is to apply De Morgan’s laws:\n\n!(A && B)  is the same as  !A || !B\n!(A || B)  is the same as  !A && !B\n\nIn words, negating a logical expression is the same as negating each term and changing the operator. The ! operator takes precedence over && and ||, so you don’t have to put parentheses around the individual terms !A and !B.\nDe Morgan’s laws also apply to the relational operators. In this case, negating each term means using the “opposite” relational operator:\n\n!(x &lt; 5 && y == 3)  is the same as  x &gt;= 5 || y != 3\n!(x &gt;= 1 || y != 7)  is the same as  x &lt; 1 && y == 7\n\nIt may help to read these examples out loud in English. For instance, “If I don’t want the case where \\(x\\) is less than 5 and \\(y\\) is 3, then I need \\(x\\) to be greater than or equal to 5, or I need \\(y\\) to be anything but 3.”\nReturning to the previous example, here is the revised condition. In English, it reads, “If \\(x\\) is not zero and \\(y\\) is not zero.” The logic is the same, and the source code is easier to read:\nif (x != 0 && y != 0) {\n    System.out.println(\"Neither x nor y is zero\");\n}",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Conditionals and Logic</span>"
    ]
  },
  {
    "objectID": "ch05.html#boolean-variables",
    "href": "ch05.html#boolean-variables",
    "title": "5  Conditionals and Logic",
    "section": "5.7 Boolean Variables",
    "text": "5.7 Boolean Variables\nTo store a true or false value, you need a boolean variable. You can declare and assign them like other variables. In this example, the first line is a variable declaration, the second is an assignment, and the third is both:\nboolean flag;\nflag = true;\nboolean testResult = false;\nSince relational and logical operators evaluate to a boolean value, you can store the result of a comparison in a variable:\nboolean evenFlag = (x % 2 == 0);    // true if x is even\nboolean positiveFlag = (x &gt; 0);     // true if x is positive\nThe parentheses are unnecessary, but they make the code easier to understand. A variable defined in this way is called a flag, because it signals, or “flags”, the presence or absence of a condition.\nYou can use flag variables as part of a conditional statement:\nif (evenFlag) {\n    System.out.println(\"n was even when I checked it\");\n}\nFlags may not seem that useful at this point, but they will help simplify complex conditions later. Each part of a condition can be stored in a separate flag, and these flags can be combined with logical operators.\nNotice that we didn’t have to write  if (evenFlag == true). Since evenFlag is a boolean, it’s already a condition. To check if a flag is false, we simply negate the flag:\nif (!evenFlag) {\n    System.out.println(\"n was odd when I checked it\");\n}\nIn general, you should never compare anything to true or false. Doing so makes the code more verbose and awkward to read out loud.",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Conditionals and Logic</span>"
    ]
  },
  {
    "objectID": "ch05.html#boolmeth",
    "href": "ch05.html#boolmeth",
    "title": "5  Conditionals and Logic",
    "section": "5.8 Boolean Methods",
    "text": "5.8 Boolean Methods\nMethods can return boolean values, just like any other type, which is often convenient for hiding tests inside methods. For example:\npublic static boolean isSingleDigit(int x) {\n    if (x &gt; -10 && x &lt; 10) {\n        return true;\n    } else {\n        return false;\n    }\n}\nThe name of this method is isSingleDigit. It is common to give boolean methods names that sound like yes/no questions. Since the return type is boolean, the return statement has to provide a boolean expression.\nThe code itself is straightforward, although it is longer than it needs to be. Remember that the expression x &gt; -10 && x &lt; 10 has type boolean, so there is nothing wrong with returning it directly (without the if statement):\npublic static boolean isSingleDigit(int x) {\n    return x &gt; -10 && x &lt; 10;\n}\nIn main, you can invoke the method in the usual ways:\nSystem.out.println(isSingleDigit(2));\nboolean bigFlag = !isSingleDigit(17);\nThe first line displays true because 2 is a single-digit number. The second line sets bigFlag to true, because 17 is not a single-digit number.\nConditional statements often invoke boolean methods and use the result as the condition:\nif (isSingleDigit(z)) {\n    System.out.println(\"z is small\");\n} else {\n    System.out.println(\"z is big\");\n}\nExamples like this one almost read like English: “If is single digit z, print z is small else print z is big.”",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Conditionals and Logic</span>"
    ]
  },
  {
    "objectID": "ch05.html#validate",
    "href": "ch05.html#validate",
    "title": "5  Conditionals and Logic",
    "section": "5.9 Validating Input",
    "text": "5.9 Validating Input\nOne of the most important tasks in any computer program is to validate input from the user. People often make mistakes while typing, especially on smartphones, and incorrect inputs may cause your program to fail.\nEven worse, someone (i.e., a hacker) may intentionally try to break into your system by entering unexpected inputs. You should never assume that users will input the right kind of data.\nConsider this simple program that prompts the user for a number and computes its logarithm:\nScanner in = new Scanner(System.in);\nSystem.out.print(\"Enter a number: \");\ndouble x = in.nextDouble();\ndouble y = Math.log(x);\nSystem.out.println(\"The log is \" + y);\nIn mathematics, the natural logarithm (base \\(e\\)) is undefined when \\(x \\le 0\\). In Java, if you ask for Math.log(-1), it returns NaN, which stands for “not a number”. We can check for this condition and print an appropriate message:\nif (x &gt; 0) {\n    double y = Math.log(x);\n    System.out.println(\"The log is \" + y);\n} else {\n    System.out.println(\"The log is undefined\");\n}\nThe output is better now, but there is another problem. What if the user doesn’t enter a number at all? What would happen if they typed the word “hello”, either by accident or on purpose?\n\nException in thread \"main\" java.util.InputMismatchException\n    at java.util.Scanner.throwFor(Scanner.java:864)\n    at java.util.Scanner.next(Scanner.java:1485)\n    at java.util.Scanner.nextDouble(Scanner.java:2413)\n    at Logarithm.main(Logarithm.java:8)\n\nIf the user inputs a String when we expect a double, Java reports an “input mismatch” exception. We can prevent this run-time error from happening by testing the input first.\nThe Scanner class provides hasNextDouble, which checks whether the next input can be interpreted as a double. If not, we can display an error message:\nif (!in.hasNextDouble()) {\n    String word = in.next();\n    System.err.println(word + \"is not a number\");\n}\nIn contrast to in.nextLine, which returns an entire line of input, the in.next method returns only the next token of input. We can use in.next to show the user exactly which word they typed was not a number.\nThis example also uses System.err, which is an OutputStream for error messages and warnings. Some development environments display output to System.err with a different color or in a separate window.",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Conditionals and Logic</span>"
    ]
  },
  {
    "objectID": "ch05.html#example-program",
    "href": "ch05.html#example-program",
    "title": "5  Conditionals and Logic",
    "section": "5.10 Example Program",
    "text": "5.10 Example Program\nIn this chapter, you have seen relational and logical operators, if statements, boolean methods, and validating input. The following program shows how the individual code examples in the previous section fit together:\nimport java.util.Scanner;\n\n/**\n * Demonstrates input validation using if statements.\n */\npublic class Logarithm {\n\n    public static void main(String[] args) {\n\n        // prompt for input\n        Scanner in = new Scanner(System.in);\n        System.out.print(\"Enter a number: \");\n\n        // check the format\n        if (!in.hasNextDouble()) {\n            String word = in.next();\n            System.err.println(word + \" is not a number\");\n            return;\n        }\n\n        // check the range\n        double x = in.nextDouble();\n        if (x &gt; 0) {\n            double y = Math.log(x);\n            System.out.println(\"The log is \" + y);\n        } else {\n            System.out.println(\"The log is undefined\");\n        }\n    }\n}\nNotice that the return statement allows you to exit a method before you reach the end of it. Returning from main terminates the program.\nWhat started as five lines of code at the beginning of Section 5.9 is now a 30-line program. Making programs robust (and secure) often requires a lot of additional checking, as shown in this example.\nIt’s important to write comments every few lines to make your code easier to understand. Comments not only help other people read your code, but also help you document what you’re trying to do. If there’s a mistake in the code, finding it will be a lot easier when there are good comments.",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Conditionals and Logic</span>"
    ]
  },
  {
    "objectID": "ch05.html#vocabulary",
    "href": "ch05.html#vocabulary",
    "title": "5  Conditionals and Logic",
    "section": "5.11 Vocabulary",
    "text": "5.11 Vocabulary\n\nboolean:\n\nA data type with only two possible values, true and false.\n\nrelational operator:\n\nAn operator that compares two values and produces a boolean indicating the relationship between them.\n\nconditional statement:\n\nA statement that uses a condition to determine which statements to execute.\n\nblock:\n\nA sequence of statements, surrounded by braces, that generally runs as the result of a condition.\n\nbranch:\n\nOne of the alternative blocks after a conditional statement. For example, an if-else statement has two branches.\n\nchaining:\n\nA way of joining several conditional statements in sequence.\n\nnesting:\n\nPutting a conditional statement inside one or both branches of another conditional statement.\n\nlogical operator:\n\nAn operator that combines boolean values and produces a boolean value.\n\nshort circuit:\n\nA way of evaluating logical operators that evaluates the second operand only if necessary.\n\nDe Morgan’s laws:\n\nMathematical rules that show how to negate a logical expression.\n\nflag:\n\nA variable (usually boolean) that represents a condition or status.\n\nvalidate:\n\nTo confirm that an input value is of the correct type and within the expected range.\n\nhacker:\n\nA programmer who breaks into computer systems. The term hacker may also apply to someone who enjoys writing code.\n\nNaN:\n\nA special floating-point value that stands for “not a number”.",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Conditionals and Logic</span>"
    ]
  },
  {
    "objectID": "ch05.html#exercises",
    "href": "ch05.html#exercises",
    "title": "5  Conditionals and Logic",
    "section": "5.12 Exercises",
    "text": "5.12 Exercises\nThe code for this chapter is in the ch05 directory of ThinkJavaCode2. See page  for instructions on how to download the repository. Before you start the exercises, we recommend that you compile and run the examples.\nIf you have not already read Appendix 18.5, now might be a good time. It describes Checkstyle, a tool that analyzes many aspects of your source code.\n\nExercise 5.1. Rewrite the following code by using a single if statement:\nif (x &gt; 0) {\n    if (x &lt; 10) {\n        System.out.println(\"positive single digit number.\");\n    }\n}\n\n\nExercise 5.2. Now that we have conditional statements, we can get back to the Guess My Number* game from Exercise 3.4.*\nYou should already have a program that chooses a random number, prompts the user to guess it, and displays the difference between the guess and the chosen number.\nBy adding a small amount of code at a time and testing as you go, modify the program so it tells the user whether the guess is too high or too low, and then prompts the user for another guess.\nThe program should continue until the user gets it right or guesses incorrectly three times. If the user guesses the correct number, display a message and terminate the program.\n\n\nExercise 5.3. Fermat’s Last Theorem says that there are no integers \\(a\\), \\(b\\), \\(c\\), and \\(n\\) such that \\(a^n + b^n = c^n\\), except when \\(n \\leq 2\\).\nWrite a program named Fermat.java* that inputs four integers (a, b, c, and n) and checks to see if Fermat’s theorem holds. If \\(n\\) is greater than 2 and \\(a^n + b^n = c^n\\), the program should display “Holy smokes, Fermat was wrong!” Otherwise, the program should display “No, that doesn’t work.”*\n**Hint:* You might want to use Math.pow.*\n\n\nExercise 5.4. Using the following variables, evaluate the logic expressions in the table that follows. Write your answers as true, false, or error.\nboolean yes = true;\nboolean no = false;\nint loVal = -999;\nint hiVal = 999;\ndouble grade = 87.5;\ndouble amount = 50.0;\nString hello = \"world\";\n\n\n|l|l| Expression & Result\nyes == no || grade &gt; amount &\namount == 40.0 || 50.0 &\nhiVal != loVal || loVal &lt; 0 &\nTrue || hello.length() &gt; 0 &\nhello.isEmpty() && yes &\ngrade &lt;= 100 && !false &\n!yes || no &\ngrade &gt; 75 &gt; amount &\namount &lt;= hiVal && amount &gt;= loVal &\nno && !no || yes && !yes &\n\n\n\n\n\nExercise 5.5. What is the output of the following program? Determine the answer without using a computer.\npublic static void main(String[] args) {\n    boolean flag1 = isHoopy(202);\n    boolean flag2 = isFrabjuous(202);\n    System.out.println(flag1);\n    System.out.println(flag2);\n    if (flag1 && flag2) {\n        System.out.println(\"ping!\");\n    }\n    if (flag1 || flag2) {\n        System.out.println(\"pong!\");\n    }\n}\npublic static boolean isHoopy(int x) {\n    boolean hoopyFlag;\n    if (x % 2 == 0) {\n        hoopyFlag = true;\n    } else {\n        hoopyFlag = false;\n    }\n    return hoopyFlag;\n}\npublic static boolean isFrabjuous(int x) {\n    boolean frabjuousFlag;\n    if (x &gt; 0) {\n        frabjuousFlag = true;\n    } else {\n        frabjuousFlag = false;\n    }\n    return frabjuousFlag;\n}\nThe purpose of this exercise is to make sure you understand logical operators and the flow of execution through methods.\n\n\nExercise 5.6. Write a program named Quadratic.java* that finds the roots of \\(ax^2 + bx + c = 0\\) using the quadratic formula: \\[x = \\frac{-b \\pm \\sqrt{b^2 - 4ac}}{2a}\\] Prompt the user to input integers for \\(a\\), \\(b\\), and \\(c\\). Compute the two solutions for \\(x\\), and display the results.*\nYour program should be able to handle inputs for which there is only one or no solution. Specifically, it should not divide by zero or take the square root of a negative number.\nBe sure to validate all inputs. The user should never see an input mismatch exception. Display specific error messages that include the invalid input.\n\n\nExercise 5.7. If you are given three sticks, you may or may not be able to arrange them in a triangle. For example, if one of the sticks is 12 inches long and the other two are 1 inch long, you will not be able to get the short sticks to meet in the middle. For any three lengths, there is a simple test to see if it is possible to form a triangle:\n\nIf any of the three lengths is greater than the sum of the other two, you cannot form a triangle.\n\nWrite a program named Triangle.java* that inputs three integers, and then outputs whether you can (or cannot) form a triangle from the given lengths. Reuse your code from the previous exercise to validate the inputs. Display an error if any of the lengths are negative or zero.*",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Conditionals and Logic</span>"
    ]
  },
  {
    "objectID": "ch06.html",
    "href": "ch06.html",
    "title": "6  Loops and Strings",
    "section": "",
    "text": "6.1 The while Statement\nUsing a while statement, we can repeat the same code multiple times:\nReading the code in English sounds like this: “Start with n set to 3. While n is greater than 0, print the value of n, and reduce the value of n by 1. When you get to 0, print Blastoff!”\nThe output is shown here:\nThe flow of execution for a while statement is as follows:\nThis type of flow is called a loop, because the last step “loops back around” to the first. Figure 6.1 shows this idea using a flowchart.\nThe body of the loop should change the value of one or more variables so that, eventually, the condition becomes false and the loop terminates. Otherwise, the loop will repeat forever, which is called an infinite loop:\nThis example will print the number 3 forever, or at least until you terminate the program. An endless source of amusement for computer scientists is the observation that the directions on shampoo, “Lather, rinse, repeat,” are an infinite loop.\nIn the first example, we can prove that the loop terminates when n is positive. But in general, it is not so easy to tell whether a loop terminates. For example, this loop continues until n is 1 (which makes the condition false):\nEach time through the loop, the program displays the value of n and then checks whether it is even or odd. If it is even, the value of n is divided by 2. If it is odd, the value is replaced by \\(3n+1\\). For example, if the starting value is 3, the resulting sequence is 3, 10, 5, 16, 8, 4, 2, 1.\nSince n sometimes increases and sometimes decreases, there is no obvious proof that n will ever reach 1 and that the program will ever terminate. For some values of n, such as the powers of two, we can prove that it terminates. The previous example ends with such a sequence, starting when n is 16 (or \\(2^4\\)).\nThe hard question is whether this program terminates for all values of n. So far, no one has been able to prove it or disprove it! For more information, see https://en.wikipedia.org/wiki/Collatz_conjecture.",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Loops and Strings</span>"
    ]
  },
  {
    "objectID": "ch06.html#the-while-statement",
    "href": "ch06.html#the-while-statement",
    "title": "6  Loops and Strings",
    "section": "",
    "text": "int n = 3;\nwhile (n &gt; 0) {\n    System.out.println(n);\n    n = n - 1;\n}\nSystem.out.println(\"Blastoff!\");\n\n\n3\n2\n1\nBlastoff!\n\n\nEvaluate the condition in parentheses, yielding true or false.\nIf the condition is false, skip the following statements in braces.\nIf the condition is true, execute the statements and go back to step 1.\n\n\n\n\n\n\n\n\n\nFlow of execution for a while loop.\n\n\n\nint n = 3;\nwhile (n &gt; 0) {\n    System.out.println(n);\n    // n never changes\n}\n\n\nwhile (n != 1) {\n    System.out.println(n);\n    if (n % 2 == 0) {         // n is even\n        n = n / 2;\n    } else {                  // n is odd\n        n = 3 * n + 1;\n    }\n}",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Loops and Strings</span>"
    ]
  },
  {
    "objectID": "ch06.html#increment-and-decrement",
    "href": "ch06.html#increment-and-decrement",
    "title": "6  Loops and Strings",
    "section": "6.2 Increment and Decrement",
    "text": "6.2 Increment and Decrement\nHere is another while loop example; this one displays the numbers 1 to 5:\nint i = 1;\nwhile (i &lt;= 5) {\n    System.out.println(i);\n    i++;  // add 1 to i\n}\nAssignments like i = i + 1 don’t often appear in loops, because Java provides a more concise way to add and subtract by one. Specifically, ++ is the increment operator; it has the same effect as i = i + 1. And -- is the decrement operator; it has the same effect as i = i - 1.\nIf you want to increment or decrement a variable by an amount other than 1, you can use += and -=. For example, i += 2 increments i by 2:\nint i = 2;\nwhile (i &lt;= 8) {\n    System.out.print(i + \", \");\n    i += 2;  // add 2 to i\n}\nSystem.out.println(\"Who do we appreciate?\");\nAnd the output is as follows:\n2, 4, 6, 8, Who do we appreciate?",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Loops and Strings</span>"
    ]
  },
  {
    "objectID": "ch06.html#the-for-statement",
    "href": "ch06.html#the-for-statement",
    "title": "6  Loops and Strings",
    "section": "6.3 The for Statement",
    "text": "6.3 The for Statement\nThe loops we have written so far have three parts in common. They start by initializing a variable, they have a condition that depends on that variable, and they do something inside the loop to update that variable.\nRunning the same code multiple times is called iteration. It’s so common that there is another statement, the for loop, that expresses it more concisely. For example, we can rewrite the 2-4-6-8 loop this way:\nfor (int i = 2; i &lt;= 8; i += 2) {\n    System.out.print(i + \", \");\n}\nSystem.out.println(\"Who do we appreciate?\");\nfor loops have three components in parentheses, separated by semicolons: the initializer, the condition, and the update:\n\nThe initializer runs once at the very beginning of the loop. It is equivalent to the line before the while statement.\nThe condition is checked each time through the loop. If it is false, the loop ends. Otherwise, the body of the loop is executed (again).\nAt the end of each iteration, the update runs, and we go back to step 2.\n\nThe for loop is often easier to read because it puts all the loop-related statements at the top of the loop. Doing so allows you to focus on the statements inside the loop body. Figure 6.2 illustrates for loops with a flowchart.\n\n\n\n\n\n\n\nFlow of execution for a for loop.\n\n\nThere is another difference between for loops and while loops: if you declare a variable in the initializer, it exists only inside the for loop. For example:\nfor (int n = 3; n &gt; 0; n--) {\n    System.out.println(n);\n}\nSystem.out.println(\"n is now \" + n);  // compiler error\nThe last line tries to display n (for no reason other than demonstration), but it won’t work. If you need to use a loop variable outside the loop, you have to declare it outside the loop, like this:\nint n;\nfor (n = 3; n &gt; 0; n--) {\n    System.out.println(n);\n}\nSystem.out.println(\"n is now \" + n);\nNotice that the for statement does not say int n = 3. Rather, it simply initializes the existing variable n.",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Loops and Strings</span>"
    ]
  },
  {
    "objectID": "ch06.html#nested",
    "href": "ch06.html#nested",
    "title": "6  Loops and Strings",
    "section": "6.4 Nested Loops",
    "text": "6.4 Nested Loops\nLike conditional statements, loops can be nested one inside the other. Nested loops allow you to iterate over two variables. For example, we can generate a “multiplication table” like this:\nfor (int x = 1; x &lt;= 10; x++) {\n    for (int y = 1; y &lt;= 10; y++) {\n        System.out.printf(\"%4d\", x * y);\n    }\n    System.out.println();\n}\nVariables like x and y are called loop variables, because they control the execution of a loop. In this example, the first loop (for x) is known as the “outer loop”, and the second loop (for y) is known as the “inner loop”.\nEach loop repeats its corresponding statements 10 times. The outer loop iterates from 1 to 10 only once, but the inner loop iterates from 1 to 10 each of those 10 times. As a result, the printf method is invoked 100 times.\nThe format specifier \\%4d displays the value of x * y padded with spaces so it’s four characters wide. Doing so causes the output to align vertically, regardless of how many digits the numbers have:\n1   2   3   4   5   6   7   8   9  10\n   2   4   6   8  10  12  14  16  18  20\n   3   6   9  12  15  18  21  24  27  30\n   4   8  12  16  20  24  28  32  36  40\n   5  10  15  20  25  30  35  40  45  50\n   6  12  18  24  30  36  42  48  54  60\n   7  14  21  28  35  42  49  56  63  70\n   8  16  24  32  40  48  56  64  72  80\n   9  18  27  36  45  54  63  72  81  90\n  10  20  30  40  50  60  70  80  90 100\nIt’s important to realize that the output is displayed row by row. The inner loop displays a single row of output, followed by a newline. The outer loop iterates over the rows themselves. Another way to read nested loops, like the ones in this example, is: “For each row x, and for each column y, …”",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Loops and Strings</span>"
    ]
  },
  {
    "objectID": "ch06.html#characters",
    "href": "ch06.html#characters",
    "title": "6  Loops and Strings",
    "section": "6.5 Characters",
    "text": "6.5 Characters\nSome of the most interesting problems in computer science involve searching and manipulating text. In the next few sections, we’ll discuss how to apply loops to strings. Although the examples are short, the techniques work the same whether you have one word or one million words.\nStrings provide a method named charAt. It returns a char, a data type that stores an individual character (as opposed to strings of them):\nString fruit = \"banana\";\nchar letter = fruit.charAt(0);\nThe argument 0 means that we want the character at index 0. String indexes range from 0 to \\(n-1\\), where \\(n\\) is the length of the string. So the character assigned to letter is 'b':\n\n\n\n\nb\na\nn\na\nn\na\n\n\n\n\n0\n1\n2\n3\n4\n5\n\n\n\n\nCharacters work like the other data types you have seen. You can compare them using relational operators:\nif (letter == 'A') {\n    System.out.println(\"It's an A!\");\n}\nCharacter literals, like 'A', appear in single quotes. Unlike string literals, which appear in double quotes, character literals can contain only a single character. Escape sequences, like '\\\\t', are legal because they represent a single character.\nThe increment and decrement operators also work with characters. So this loop displays the letters of the alphabet:\nSystem.out.print(\"Roman alphabet: \");\nfor (char c = 'A'; c &lt;= 'Z'; c++) {\n    System.out.print(c);\n}\nSystem.out.println();\nThe output is shown here:\nABCDEFGHIJKLMNOPQRSTUVWXYZ\nJava uses Unicode to represent characters, so strings can store text in other alphabets like Cyrillic and Greek, and non-alphabetic languages like Chinese. You can read more about it at the Unicode website (https://unicode.org/).\nIn Unicode, each character is represented by a “code point”, which you can think of as an integer. The code points for uppercase Greek letters run from 913 to 937, so we can display the Greek alphabet like this:\nSystem.out.print(\"Greek alphabet: \");\nfor (int i = 913; i &lt;= 937; i++) {\n    System.out.print((char) i);\n}\nSystem.out.println();\nThis example uses a type cast to convert each integer (in the range) to the corresponding character. Try running the code and see what happens.",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Loops and Strings</span>"
    ]
  },
  {
    "objectID": "ch06.html#which-loop-to-use",
    "href": "ch06.html#which-loop-to-use",
    "title": "6  Loops and Strings",
    "section": "6.6 Which Loop to Use",
    "text": "6.6 Which Loop to Use\nfor and while loops have the same capabilities; any for loop can be rewritten as a while loop, and vice versa. For example, we could have printed letters of the alphabet by using a while loop:\nSystem.out.print(\"Roman alphabet: \");\nchar c = 'A';\nwhile (c &lt;= 'Z') {\n    System.out.print(c);\n    c++;\n}\nSystem.out.println();\nYou might wonder when to use one or the other. It depends on whether you know how many times the loop will repeat.\nA for loop is “definite”, which means we know, at the beginning of the loop, how many times it will repeat. In the alphabet example, we know it will run 26 times. In that case, it’s better to use a for loop, which puts all of the loop control code on one line.\nA while loop is “indefinite”, which means we don’t know how many times it will repeat. For example, when validating user input as in Section 5.9, it’s impossible to know how many times the user will enter a wrong value. In this case, a while loop is more appropriate:\nSystem.out.print(\"Enter a number: \");\nwhile (!in.hasNextDouble()) {\n    String word = in.next();\n    System.err.println(word + \" is not a number\");\n    System.out.print(\"Enter a number: \");\n}\ndouble number = in.nextDouble();\nIt’s easier to read the Scanner method calls when they’re not all on one line of code.",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Loops and Strings</span>"
    ]
  },
  {
    "objectID": "ch06.html#string-iteration",
    "href": "ch06.html#string-iteration",
    "title": "6  Loops and Strings",
    "section": "6.7 String Iteration",
    "text": "6.7 String Iteration\nStrings provide a method called length that returns the number of characters in the string. The following loop iterates the characters in fruit and displays them, one on each line:\nfor (int i = 0; i &lt; fruit.length(); i++) {\n    char letter = fruit.charAt(i);\n    System.out.println(letter);\n}\nBecause length is a method, you have to invoke it with parentheses (there are no arguments). When i is equal to the length of the string, the condition becomes false and the loop terminates.\nTo find the last letter of a string, you might be tempted to do something like the following:\nint length = fruit.length();\nchar last = fruit.charAt(length);      // wrong!\nThis code compiles and runs, but invoking the charAt method throws a StringIndexOutOfBoundsException. The problem is that there is no sixth letter in \"banana\". Since we started counting at 0, the six letters are indexed from 0 to 5. To get the last character, you have to subtract 1 from length:\nint length = fruit.length();\nchar last = fruit.charAt(length - 1);  // correct\nMany string algorithms involve reading one string and building another. For example, to reverse a string, we can concatenate one character at a time:\npublic static String reverse(String s) {\n    String r = \"\";\n    for (int i = s.length() - 1; i &gt;= 0; i--) {\n        r += s.charAt(i);\n    }\n    return r;\n}\nThe initial value of r is \"\", which is an empty string. The loop iterates the indexes of s in reverse order. Each time through the loop, the += operator appends the next character to r. When the loop exits, r contains the characters from s in reverse order. So the result of reverse(\"banana\") is \"ananab\".",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Loops and Strings</span>"
    ]
  },
  {
    "objectID": "ch06.html#the-indexof-method",
    "href": "ch06.html#the-indexof-method",
    "title": "6  Loops and Strings",
    "section": "6.8 The indexOf Method",
    "text": "6.8 The indexOf Method\nTo search for a specific character in a string, you could write a for loop and use charAt as in the previous section. However, the String class already provides a method for doing just that:\nString fruit = \"banana\";\nint index = fruit.indexOf('a');     // returns 1\nThis example finds the index of 'a' in the string. But the letter appears three times, so it’s not obvious what indexOf might do. According to the documentation, it returns the index of the first appearance.\nTo find subsequent appearances, you can use another version of indexOf, which takes a second argument that indicates where in the string to start looking:\nint index = fruit.indexOf('a', 2);  // returns 3\nTo visualize how indexOf and other String methods work, it helps to draw a picture like Figure 6.3. The previous code starts at index 2 (the first 'n') and finds the next 'a', which is at index 3.\n\n\n\n\n\n\n\nMemory diagram for a String of six characters.\n\n\nIf the character happens to appear at the starting index, the starting index is the answer. So fruit.indexOf('a', 5) returns 5. If the character does not appear in the string, indexOf returns -1. Since indexes cannot be negative, this value indicates the character was not found.\nYou can also use indexOf to search for an entire string, not just a single character. For example, the expression fruit.indexOf(\"nan\") returns 2.",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Loops and Strings</span>"
    ]
  },
  {
    "objectID": "ch06.html#substrings",
    "href": "ch06.html#substrings",
    "title": "6  Loops and Strings",
    "section": "6.9 Substrings",
    "text": "6.9 Substrings\nIn addition to searching strings, we often need to extract parts of strings. The substring method returns a new string that copies letters from an existing string, given a pair of indexes:\n\nfruit.substring(0, 3) returns \"ban\"\nfruit.substring(2, 5) returns \"nan\"\nfruit.substring(6, 6) returns \"\"\n\nNotice that the character indicated by the second index is not included. Defining substring this way simplifies some common operations. For example, to select a substring with length len, starting at index i, you could write fruit.substring(i, i + len).\nLike most string methods, substring is overloaded. That is, there are other versions of substring that have different parameters. If it’s invoked with one argument, it returns the letters from that index to the end:\n\nfruit.substring(0) returns \"banana\"\nfruit.substring(2) returns \"nana\"\nfruit.substring(6) returns \"\"\n\nThe first example returns a copy of the entire string. The second example returns all but the first two characters. As the last example shows, substring returns the empty string if the argument is the length of the string.\nWe could also use fruit.substring(2, fruit.length()) to get the result \"nana\". But calling substring with one argument is more convenient when you want the end of the string.",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Loops and Strings</span>"
    ]
  },
  {
    "objectID": "ch06.html#strcmp",
    "href": "ch06.html#strcmp",
    "title": "6  Loops and Strings",
    "section": "6.10 String Comparison",
    "text": "6.10 String Comparison\nWhen comparing strings, it might be tempting to use the == and != operators. But that will almost never work. The following code compiles and runs, but it always displays Goodbye! regardless what the user types.\nSystem.out.print(\"Play again? \");\nString answer = in.nextLine();\nif (answer == \"yes\") {                 // wrong!\n    System.out.println(\"Let's go!\");\n} else {\n    System.out.println(\"Goodbye!\");\n}\nThe problem is that the == operator checks whether the two operands refer to the same object. Even if the answer is \"yes\", it will refer to a different object in memory than the literal string \"yes\" in the code. You’ll learn more about objects and references in the next chapter.\nThe correct way to compare strings is with the equals method, like this:\nif (answer.equals(\"yes\")) {\n    System.out.println(\"Let's go!\");\n}\nThis example invokes equals on answer and passes \"yes\" as an argument. The equals method returns true if the strings contain the same characters; otherwise, it returns false.\nIf two strings differ, we can use compareTo to see which comes first in alphabetical order:\nString name1 = \"Alan Turing\";\nString name2 = \"Ada Lovelace\";\nint diff = name1.compareTo(name2);\nif (diff &lt; 0) {\n    System.out.println(\"name1 comes before name2.\");\n} else if (diff &gt; 0) {\n    System.out.println(\"name2 comes before name1.\");\n} else {\n    System.out.println(\"The names are the same.\");\n}\nThe return value from compareTo is the difference between the first characters in the strings that are not the same. In the preceding code, compareTo returns positive 8, because the second letter of \"Ada\" comes before the second letter of \"Alan\" by eight letters.\nIf the first string (the one on which the method is invoked) comes earlier in the alphabet, the difference is negative. If it comes later in the alphabet, the difference is positive. If the strings are equal, their difference is zero.\nBoth equals and compareTo are case-sensitive. In Unicode, uppercase letters come before lowercase letters. So \"Ada\" comes before \"ada\".",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Loops and Strings</span>"
    ]
  },
  {
    "objectID": "ch06.html#string-formatting",
    "href": "ch06.html#string-formatting",
    "title": "6  Loops and Strings",
    "section": "6.11 String Formatting",
    "text": "6.11 String Formatting\nIn Section 3.5, we learned how to use System.out.printf to display formatted output. Sometimes programs need to create strings that are formatted a certain way, but not display them immediately (or ever). For example, the following method returns a time string in 12-hour format:\npublic static String timeString(int hour, int minute) {\n    String ampm;\n    if (hour &lt; 12) {\n        ampm = \"AM\";\n        if (hour == 0) {\n            hour = 12;  // midnight\n        }\n    } else {\n        ampm = \"PM\";\n        hour = hour - 12;\n    }\n    return String.format(\"%02d:%02d %s\", hour, minute, ampm);\n}\nString.format takes the same arguments as System.out.printf: a format specifier followed by a sequence of values. The main difference is that System.out.printf displays the result on the screen. String.format creates a new string but does not display anything.\nIn this example, the format specifier \\%02d means “two-digit integer padded with zeros”, so timeString(19, 5) returns the string \"07:05 PM\". As an exercise, try writing two nested for loops (in main) that invoke timeString and display all possible times over a 24-hour period.\nBe sure to skim through the documentation for String. Knowing what other methods are there will help you avoid reinventing the wheel. The easiest way to find documentation for Java classes is to do a web search for “Java” and the name of the class.",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Loops and Strings</span>"
    ]
  },
  {
    "objectID": "ch06.html#vocabulary",
    "href": "ch06.html#vocabulary",
    "title": "6  Loops and Strings",
    "section": "6.12 Vocabulary",
    "text": "6.12 Vocabulary\n\nloop:\n\nA statement that executes a sequence of statements repeatedly.\n\nloop body:\n\nThe statements inside the loop.\n\ninfinite loop:\n\nA loop whose condition is always true.\n\nincrement:\n\nIncrease the value of a variable.\n\ndecrement:\n\nDecrease the value of a variable.\n\niteration:\n\nExecuting a sequence of statements repeatedly.\n\nloop variable:\n\nA variable that is initialized, tested, and updated in order to control a loop.\n\nindex:\n\nAn integer variable or value used to indicate a character in a string.\n\nUnicode:\n\nAn international standard for representing characters in most of the world’s languages.\n\nempty string:\n\nThe string \"\", which contains no characters and has a length of zero.\n\noverloaded:\n\nTwo or more methods with the same name but different parameters.",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Loops and Strings</span>"
    ]
  },
  {
    "objectID": "ch06.html#exercises",
    "href": "ch06.html#exercises",
    "title": "6  Loops and Strings",
    "section": "6.13 Exercises",
    "text": "6.13 Exercises\nThe code for this chapter is in the ch06 directory of ThinkJavaCode2. See page  for instructions on how to download the repository. Before you start the exercises, we recommend that you compile and run the examples.\nIf you have not already read Appendix 18.6, now might be a good time. It describes the DrJava debugger, which is a useful tool for visualizing the flow of execution through loops.\n\nExercise 6.1. Consider the following methods (main and loop):\n\nDraw a table that shows the value of the variables i and n during the execution of loop. The table should contain one column for each variable and one line for each iteration.\nWhat is the output of this program?\nCan you prove that this loop terminates for any positive value of n?\n\npublic static void main(String[] args) {\n    loop(10);\n}\n\npublic static void loop(int n) {\n    int i = n;\n    while (i &gt; 1) {\n        System.out.println(i);\n        if (i % 2 == 0) {\n            i = i / 2;\n        } else {\n            i = i + 1;\n        }\n    }\n}\n\n\nExercise 6.2. Let’s say you are given a number, \\(a\\), and you want to find its square root. One way to do that is to start with a rough guess about the answer, \\(x_0\\), and then improve the guess by using this formula: \\[x_1 =(x_0 + a/x_0) / 2\\] For example, if we want to find the square root of 9, and we start with \\(x_0 = 6\\), then \\(x_1 = (6 + 9/6) / 2 = 3.75\\), which is closer. We can repeat the procedure, using \\(x_1\\) to calculate \\(x_2\\), and so on. In this case, \\(x_2 = 3.075\\) and \\(x_3 = 3.00091\\). So the repetition converges quickly on the correct answer.\nWrite a method called squareRoot that takes a double and returns an approximation of the square root of the parameter, using this technique. You should not use Math.sqrt.\nAs your initial guess, you should use \\(a/2\\). Your method should iterate until it gets two consecutive estimates that differ by less than 0.0001. You can use Math.abs to calculate the absolute value of the difference.\n\n\nExercise 6.3. One way to evaluate \\(\\exp(-x^2)\\) is to use the infinite series expansion: \\[\\exp(-x^2) = 1 - x^2 + x^4/2 - x^6/6 + \\ldots\\] The \\(i\\)th term in this series is \\((-1)^i x^{2i} / i!\\). Write a method named gauss that takes x and n as arguments and returns the sum of the first n terms of the series. You should not use factorial or pow.\n\n\nExercise 6.4. A word is said to be “abecedarian” if the letters in the word appear in alphabetical order. For example, the following are all six-letter English abecedarian words:\n\nabdest, acknow, acorsy, adempt, adipsy, agnosy, befist, behint, beknow, bijoux, biopsy, cestuy, chintz, deflux, dehors, dehort, deinos, diluvy, dimpsy\n\nWrite a method called isAbecedarian that takes a String and returns a boolean indicating whether the word is abecedarian.\n\n\nExercise 6.5.\nA word is said to be a “doubloon” if every letter that appears in the word appears exactly twice. Here are some example doubloons found in the dictionary:\n\nAbba, Anna, appall, appearer, appeases, arraigning, beriberi, bilabial, boob, Caucasus, coco, Dada, deed, Emmett, Hannah, horseshoer, intestines, Isis, mama, Mimi, murmur, noon, Otto, papa, peep, reappear, redder, sees, Shanghaiings, Toto\n\nWrite a method called isDoubloon that takes a string and checks whether it is a doubloon. To ignore case, invoke the toLowerCase method before checking.\n\n\nExercise 6.6. In Scrabble[^1] each player has a set of tiles with letters on them. The object of the game is to use those letters to spell words. The scoring system is complex, but longer words are usually worth more than shorter words.\nImagine you are given your set of tiles as a string, like \"quijibo\", and you are given another string to test, like \"jib\".\nWrite a method called canSpell that takes two strings and checks whether the set of tiles can spell the word. You might have more than one tile with the same letter, but you can use each tile only once.",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Loops and Strings</span>"
    ]
  },
  {
    "objectID": "ch07.html",
    "href": "ch07.html",
    "title": "7  Arrays and References",
    "section": "",
    "text": "7.1 Creating Arrays\nAn array is a sequence of values; the values in the array are called elements. You can make an array of ints, doubles, Strings, or any other type, but all the values in an array must have the same type.\nTo create an array, you have to declare a variable with an array type and then create the array itself. Array types look like other Java types, except they are followed by square brackets ([]). For example, the following lines declare that counts is an “integer array” and values is a “double array”:\nTo create the array itself, you have to use the new operator, which you first saw in Section 3.2. The new operator allocates memory for the array and automatically initializes all of its elements to zero:\nThe first assignment makes counts refer to an array of four integers. The second makes values refer to an array of doubles, but the number of elements depends on the value of size (at the time the array is created).\nOf course, you can also declare the variable and create the array with a single line of code:\nYou can use any integer expression for the size of an array, as long as the value is nonnegative. If you try to create an array with -4 elements, for example, you will get a NegativeArraySizeException. An array with zero elements is allowed, and there are special uses for such arrays.\nYou can initialize an array with a comma-separated sequence of elements enclosed in braces, like this:\nThis statement creates an array variable, a, and makes it refer to an array with four elements.",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Arrays and References</span>"
    ]
  },
  {
    "objectID": "ch07.html#creating-arrays",
    "href": "ch07.html#creating-arrays",
    "title": "7  Arrays and References",
    "section": "",
    "text": "int[] counts;\ndouble[] values;\n\ncounts = new int[4];\nvalues = new double[size];\n\n\nint[] counts = new int[4];\ndouble[] values = new double[size];\n\n\nint[] a = {1, 2, 3, 4};",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Arrays and References</span>"
    ]
  },
  {
    "objectID": "ch07.html#elements",
    "href": "ch07.html#elements",
    "title": "7  Arrays and References",
    "section": "7.2 Accessing Elements",
    "text": "7.2 Accessing Elements\nWhen you create an array with the new operator, the elements are initialized to zero. Figure 7.1 shows a memory diagram of the counts array so far.\n\n\n\n\n\n\n\nMemory diagram of an int array.\n\n\nThe arrow indicates that the value of counts is a reference to the array. You should think of the array and the variable that refers to it as two different things. As you’ll soon see, we can assign a different variable to refer to the same array, and we can change the value of counts to refer to a different array.\nThe boldface numbers inside the boxes are the elements of the array. The lighter numbers outside the boxes are the indexes used to identify each location in the array. As with strings, the index of the first element is 0, not 1. For this reason, we sometimes refer to the first element as the “zeroth” element.\nThe [] operator selects elements from an array:\nSystem.out.println(\"The zeroth element is \" + counts[0]);\nYou can use the [] operator anywhere in an expression:\ncounts[0] = 7;\ncounts[1] = counts[0] * 2;\ncounts[2]++;\ncounts[3] -= 60;\nFigure 7.2 shows the result of these statements.\n\n\n\n\n\n\n\nMemory diagram after several assignment statements.\n\n\nYou can use any expression as an index, as long as it has type int. One of the most common ways to index an array is with a loop variable. For example:\nint i = 0;\nwhile (i &lt; 4) {\n    System.out.println(counts[i]);\n    i++;\n}\nThis while loop counts up from 0 to 4. When i is 4, the condition fails and the loop terminates. So the body of the loop is executed only when i is 0, 1, 2, or 3. In this context, the variable name i is short for “index”.\nEach time through the loop, we use i as an index into the array, displaying the \\(i\\)th element. This type of array processing is usually written as a for loop:\nfor (int i = 0; i &lt; 4; i++) {\n    System.out.println(counts[i]);\n}\nFor the counts array, the only legal indexes are 0, 1, 2, and 3. If the index is negative or greater than 3, the result is an ArrayIndexOutOfBoundsException.",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Arrays and References</span>"
    ]
  },
  {
    "objectID": "ch07.html#printarray",
    "href": "ch07.html#printarray",
    "title": "7  Arrays and References",
    "section": "7.3 Displaying Arrays",
    "text": "7.3 Displaying Arrays\nYou can use println to display an array, but it probably doesn’t do what you would like. For example, say you print an array like this:\nint[] a = {1, 2, 3, 4};\nSystem.out.println(a);\nThe output is something like this:\n[I@bf3f7e0\nThe bracket indicates that the value is an array, I stands for “integer”, and the rest represents the address of the array in memory.\nIf we want to display the elements of the array, we can do it ourselves:\npublic static void printArray(int[] a) {\n    System.out.print(\"{\" + a[0]);\n    for (int i = 1; i &lt; a.length; i++) {\n        System.out.print(\", \" + a[i]);\n    }\n    System.out.println(\"}\");\n}\nGiven the previous array, the output of printArray is as follows:\n{1, 2, 3, 4}\nThe Java library includes a class, java.util.Arrays, that provides methods for working with arrays. One of them, toString, returns a string representation of an array. After importing Arrays, we can invoke toString like this:\nSystem.out.println(Arrays.toString(a));\nAnd the output is shown here:\n[1, 2, 3, 4]\nNotice that Arrays.toString uses square brackets instead of curly braces. But it beats writing your own printArray method.",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Arrays and References</span>"
    ]
  },
  {
    "objectID": "ch07.html#copying-arrays",
    "href": "ch07.html#copying-arrays",
    "title": "7  Arrays and References",
    "section": "7.4 Copying Arrays",
    "text": "7.4 Copying Arrays\nAs explained in Section 7.2, array variables contain references to arrays. When you make an assignment to an array variable, it simply copies the reference. But it doesn’t copy the array itself. For example:\ndouble[] a = new double[3];\ndouble[] b = a;\nThese statements create an array of three doubles and make two different variables refer to it, as shown in Figure 7.3.\n\n\n\n\n\n\n\nMemory diagram of two variables referring to the same array.\n\n\nAny changes made through either variable will be seen by the other. For example, if we set a[0] = 17.0, and then display b[0], the result is 17.0. Because a and b are different names for the same thing, they are sometimes called aliases.\nIf you actually want to copy the array, not just the reference, you have to create a new array and copy the elements from one to the other, like this:\ndouble[] b = new double[3];\nfor (int i = 0; i &lt; 3; i++) {\n    b[i] = a[i];\n}\njava.util.Arrays provides a method named copyOf that performs this task for you. So you can replace the previous code with one line:\ndouble[] b = Arrays.copyOf(a, 3);\nThe second parameter is the number of elements you want to copy, so copyOf can also be used to copy part of an array. Figure 7.4 shows the state of the array variables after invoking Arrays.copyOf.\n\n\n\n\n\n\n\nMemory diagram of two variables referring to different arrays.\n\n\nThe examples so far work only if the array has three elements. It is better to generalize the code to work with arrays of any size. We can do that by replacing the magic number, 3, with a.length:\ndouble[] b = new double[a.length];\nfor (int i = 0; i &lt; a.length; i++) {\n    b[i] = a[i];\n}\nAll arrays have a built-in constant, length, that stores the number of elements. In contrast to String.length(), which is a method, a.length is a constant. The expression a.length may look like a method invocation, but there are no parentheses and no arguments.\nThe last time the loop gets executed, i is a.length - 1, which is the index of the last element. When i is equal to a.length, the condition fails and the body is not executed—which is a good thing, because trying to access a[a.length] would throw an exception.\nOf course, we can replace the loop altogether by using Arrays.copyOf and a.length for the second argument. The following line produces the same result shown in Figure 7.4:\ndouble[] b = Arrays.copyOf(a, a.length);\nThe Arrays class provides many other useful methods like Arrays.compare, Arrays.equals, Arrays.fill, and Arrays.sort. Take a moment to read the documentation by searching the web for java.util.Arrays.",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Arrays and References</span>"
    ]
  },
  {
    "objectID": "ch07.html#traversal",
    "href": "ch07.html#traversal",
    "title": "7  Arrays and References",
    "section": "7.5 Traversing Arrays",
    "text": "7.5 Traversing Arrays\nMany computations can be implemented by looping through the elements of an array and performing an operation on each element. Looping through the elements of an array is called a traversal:\nint[] a = {1, 2, 3, 4, 5};\nfor (int i = 0; i &lt; a.length; i++) {\n    a[i] *= a[i];\n}\nThis example traverses an array and squares each element. At the end of the loop, the array has the values {1, 4, 9, 16, 25}.\nAnother common pattern is a search, which involves traversing an array and “searching” for a particular element. For example, the following method takes an array and a value, and it returns the index where the value appears:\npublic static int search(double[] array, double target) {\n    for (int i = 0; i &lt; array.length; i++) {\n        if (array[i] == target) {\n            return i;\n        }\n    }\n    return -1;  // not found\n}\nIf we find the target value in the array, we return its index immediately. If the loop exits without finding the target, it returns -1, a special value chosen to indicate a failed search. (This code is essentially what the String.indexOf method does.)\nThe following code searches an array for the value 1.23, which is the third element. Because array indexes start at 0, the output is 2:\ndouble[] array = {3.14, -55.0, 1.23, -0.8};\nint index = search(array, 1.23);\nSystem.out.println(index);\nAnother common traversal is a reduce operation, which “reduces” an array of values down to a single value. Examples include the sum or product of the elements, the minimum, and the maximum. The following method takes an array and returns the sum of its elements:\npublic static double sum(double[] array) {\n    double total = 0.0;\n    for (int i = 0; i &lt; array.length; i++) {\n        total += array[i];\n    }\n    return total;\n}\nBefore the loop, we initialize total to 0. Each time through the loop, we update total by adding one element from the array. At the end of the loop, total contains the sum of the elements. A variable used this way is sometimes called an accumulator, because it “accumulates” the running total.",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Arrays and References</span>"
    ]
  },
  {
    "objectID": "ch07.html#random",
    "href": "ch07.html#random",
    "title": "7  Arrays and References",
    "section": "7.6 Random Numbers",
    "text": "7.6 Random Numbers\nMost computer programs do the same thing every time they run; programs like that are called deterministic. Usually, determinism is a good thing, since we expect the same calculation to yield the same result. But for some applications, we want the computer to be unpredictable. Games are an obvious example, but there are many others, like scientific simulations.\nMaking a program nondeterministic turns out to be hard, because it’s impossible for a computer to generate truly random numbers. But there are algorithms that generate unpredictable sequences called pseudorandom numbers. For most applications, they are as good as random.\nIf you did Exercise 3.4, you have already seen java.util.Random, which generates pseudorandom numbers. The method nextInt takes an integer argument, n, and returns a random integer between 0 and n - 1 (inclusive).\nIf you generate a long series of random numbers, every value should appear, at least approximately, the same number of times. One way to test this behavior of nextInt is to generate a large number of values, store them in an array, and count the number of times each value occurs.\nThe following method creates an int array and fills it with random numbers between 0 and 99. The argument specifies the desired size of the array, and the return value is a reference to the new array:\npublic static int[] randomArray(int size) {\n    Random random = new Random();\n    int[] a = new int[size];\n    for (int i = 0; i &lt; a.length; i++) {\n        a[i] = random.nextInt(100);\n    }\n    return a;\n}\nThe following main method generates an array and displays it by using the printArray method from Section 7.3. We could have used Arrays.toString, but we like seeing curly braces instead of square brackets:\npublic static void main(String[] args) {\n    int[] array = randomArray(8);\n    printArray(array);\n}\nEach time you run the program, you should get different values. The output will look something like this:\n{15, 62, 46, 74, 67, 52, 51, 10}",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Arrays and References</span>"
    ]
  },
  {
    "objectID": "ch07.html#singlepass",
    "href": "ch07.html#singlepass",
    "title": "7  Arrays and References",
    "section": "7.7 Building a Histogram",
    "text": "7.7 Building a Histogram\nIf these values were exam scores—and they would be pretty bad exam scores in that case—the teacher might present them to the class in the form of a histogram. In statistics, a histogram is a set of counters that keeps track of the number of times each value appears.\nFor exam scores, we might have 10 counters to keep track of how many students scored in the 90s, the 80s, etc. To do that, we can traverse the array and count the number of elements that fall in a given range.\nThe following method takes an array and two integers. It returns the number of elements that fall in the range from low to high - 1:\npublic static int inRange(int[] a, int low, int high) {\n    int count = 0;\n    for (int i = 0; i &lt; a.length; i++) {\n        if (a[i] &gt;= low && a[i] &lt; high) {\n            count++;\n        }\n    }\n    return count;\n}\nThis pattern should look familiar: it is another reduce operation. Notice that low is included in the range (&gt;=), but high is excluded (&lt;). This design keeps us from counting any scores twice.\nNow we can count the number of scores in each grade range. We add the following code to our main method:\nint[] scores = randomArray(30);\nint a = inRange(scores, 90, 100);\nint b = inRange(scores, 80, 90);\nint c = inRange(scores, 70, 80);\nint d = inRange(scores, 60, 70);\nint f = inRange(scores, 0, 60);\nThis code is repetitive, but it is acceptable as long as the number of ranges is small. Suppose we wanted to keep track of the number of times each individual score appears. Then we would have to write 100 lines of code:\nint count0 = inRange(scores, 0, 1);\nint count1 = inRange(scores, 1, 2);\nint count2 = inRange(scores, 2, 3);\n...\nint count99 = inRange(scores, 99, 100);\nWhat we need is a way to store 100 counters, preferably so we can use an index to access them. Wait a minute—that’s exactly what an array does.\nThe following fragment creates an array of 100 counters, one for each possible score. It loops through the scores and uses inRange to count how many times each score appears. Then it stores the results in the counts array:\nint[] counts = new int[100];\nfor (int i = 0; i &lt; counts.length; i++) {\n    counts[i] = inRange(scores, i, i + 1);\n}\nNotice that we are using the loop variable i three times: as an index into the counts array, and in the last two arguments of inRange.\nThe code works, but it is not as efficient as it could be. Every time the loop invokes inRange, it traverses the entire array. It would be better to make a single pass through the scores array.\nFor each score, we already know which range it falls in—the score itself. We can use that value to increment the corresponding counter. This code traverses the array of scores only once to generate the histogram:\nint[] counts = new int[100];\nfor (int i = 0; i &lt; scores.length; i++) {\n    int index = scores[i];\n    counts[index]++;\n}\nEach time through the loop, it selects one element from scores and uses it as an index to increment the corresponding element of counts. Because this code traverses the array of scores only once, it is much more efficient.",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Arrays and References</span>"
    ]
  },
  {
    "objectID": "ch07.html#enhanced",
    "href": "ch07.html#enhanced",
    "title": "7  Arrays and References",
    "section": "7.8 The Enhanced for Loop",
    "text": "7.8 The Enhanced for Loop\nSince traversing arrays is so common, Java provides an alternative syntax that makes the code more compact. Consider a for loop that displays the elements of an array on separate lines:\nfor (int i = 0; i &lt; values.length; i++) {\n    int value = values[i];\n    System.out.println(value);\n}\nWe could rewrite the loop like this:\nfor (int value : values) {\n    System.out.println(value);\n}\nThis statement is called an enhanced for loop, also known as the “for each” loop. You can read the code as, “for each value in values”. It’s conventional to use plural nouns for array variables and singular nouns for element variables.\nNotice how the single line for (int value : values) replaces the first two lines of the standard for loop. It hides the details of iterating each index of the array, and instead, focuses on the values themselves.\nUsing the enhanced for loop, and removing the temporary variable, we can write the histogram code from the previous section more concisely:\nint[] counts = new int[100];\nfor (int score : scores) {\n    counts[score]++;\n}\nEnhanced for loops often make the code more readable, especially for accumulating values. But they are not helpful when you need to refer to the index, as in search operations:\nfor (double d : array) {\n    if (d == target) {\n        // array contains d, but we don't know where\n    }\n}",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Arrays and References</span>"
    ]
  },
  {
    "objectID": "ch07.html#counting-characters",
    "href": "ch07.html#counting-characters",
    "title": "7  Arrays and References",
    "section": "7.9 Counting Characters",
    "text": "7.9 Counting Characters\nWe now return to the example from the beginning of the chapter and present a solution to Exercise 6.5 using arrays. Here is the problem again:\n\nA word is said to be a “doubloon” if every letter that appears in the word appears exactly twice. Write a method called isDoubloon that takes a string and checks whether it is a doubloon. To ignore case, invoke the toLowerCase method before checking.\n\nBased on the approach from Section 7.7, we will create an array of 26 integers to count how many times each letter appears. We convert the string to lowercase, so that we can treat 'A' and 'a' (for example) as the same letter.\nint[] counts = new int[26];\nString lower = s.toLowerCase();\nWe can use a for loop to iterate each character in the string. To update the counts array, we need to compute the index that corresponds to each character. Fortunately, Java allows you to perform arithmetic on characters:\nfor (int i = 0; i &lt; lower.length(); i++) {\n    char letter = lower.charAt(i);\n    int index = letter - 'a';\n    counts[index]++;\n}\nIf letter is 'a', the value of index is 0; if letter is 'b', the value of index is 1, and so on.\nThen we use index to increment the corresponding element of counts. At the end of the loop, counts contains a histogram of the letters in the string lower.\nWe can simplify this code with an enhanced for loop, but it doesn’t work with strings; we have to convert lower to an array of characters, like this:\nfor (char letter : lower.toCharArray()) {\n    int index = letter - 'a';\n    counts[index]++;\n}\nOnce we have the counts, we can use a second for loop to check whether each letter appears zero or two times:\nfor (int count : counts) {\n    if (count != 0 && count != 2) {\n        return false;  // not a doubloon\n    }\n}\nreturn true;  // is a doubloon\nIf we find a count that is neither 0 or 2, we know the word is not a doubloon and we can return immediately. If we make it all the way through the for loop, we know that all counts are 0 or 2, which means the word is a doubloon.\nPulling together the code fragments, and adding some comments and test cases, here’s the entire program:\npublic class Doubloon {\n\n    public static boolean isDoubloon(String s) {\n        // count the number of times each letter appears\n        int[] counts = new int[26];\n        String lower = s.toLowerCase();\n        for (char letter : lower.toCharArray()) {\n            int index = letter - 'a';\n            counts[index]++;\n        }\n        // determine whether the given word is a doubloon\n        for (int count : counts) {\n            if (count != 0 && count != 2) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(isDoubloon(\"Mama\"));  // true\n        System.out.println(isDoubloon(\"Lama\"));  // false\n    }\n}\nThis example uses methods, if statements, for loops, arithmetic and logical operators, integers, characters, strings, booleans, and arrays. We hope you’ll take a second to appreciate how much you’ve learned!",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Arrays and References</span>"
    ]
  },
  {
    "objectID": "ch07.html#vocabulary",
    "href": "ch07.html#vocabulary",
    "title": "7  Arrays and References",
    "section": "7.10 Vocabulary",
    "text": "7.10 Vocabulary\n\narray:\n\nA collection of values in which all the values have the same type, and each value is identified by an index.\n\nelement:\n\nOne of the values in an array. The [] operator selects elements.\n\nindex:\n\nAn integer variable or value used to indicate an element of an array.\n\nallocate:\n\nTo reserve memory for an array or other object. In Java, the new operator allocates memory.\n\nreference:\n\nA value that indicates a storage location. In a memory diagram, a reference appears as an arrow.\n\nalias:\n\nA variable that refers to the same object as another variable.\n\ntraversal:\n\nLooping through the elements of an array (or other collection).\n\nsearch:\n\nA traversal pattern used to find a particular element of an array.\n\nreduce:\n\nA traversal pattern that combines the elements of an array into a single value.\n\naccumulator:\n\nA variable used to accumulate results during a traversal.\n\ndeterministic:\n\nA program that does the same thing every time it is run.\n\nnondeterministic:\n\nA program that always behaves differently, even when run multiple times with the same input.\n\npseudorandom:\n\nA sequence of numbers that appear to be random but are actually the product of a deterministic computation.\n\nhistogram:\n\nAn array of integers in which each integer counts the number of values that fall into a certain range.\n\nenhanced for loop:\n\nAn alternative syntax for traversing the elements of an array (or other collection).",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Arrays and References</span>"
    ]
  },
  {
    "objectID": "ch07.html#exercises",
    "href": "ch07.html#exercises",
    "title": "7  Arrays and References",
    "section": "7.11 Exercises",
    "text": "7.11 Exercises\nThe code for this chapter is in the ch07 directory of ThinkJavaCode2. See page  for instructions on how to download the repository. Before you start the exercises, we recommend that you compile and run the examples.\nIf you haven’t already, take a look at Appendix 21, where we’ve collected some of our favorite debugging advice. It refers to language features we haven’t yet covered, but it’s good for you to know what’s available when you need it.\n\nExercise 7.1. The purpose of this exercise is to practice reading code and recognizing the traversal patterns in this chapter. The following methods are hard to read, because instead of using meaningful names for the variables and methods, they use names of fruit.\nFor each method, write one sentence that describes what the method does, without getting into the details of how it works. And for each variable, identify the role it plays.\npublic static int banana(int[] a) {\n    int kiwi = 1;\n    int i = 0;\n    while (i &lt; a.length) {\n        kiwi = kiwi * a[i];\n        i++;\n    }\n    return kiwi;\n}\npublic static int grapefruit(int[] a, int grape) {\n    for (int i = 0; i &lt; a.length; i++) {\n        if (a[i] == grape) {\n            return i;\n        }\n    }\n    return -1;\n}\npublic static int pineapple(int[] a, int apple) {\n    int pear = 0;\n    for (int pine: a) {\n        if (pine == apple) {\n            pear++;\n        }\n    }\n    return pear;\n}\n\n\nExercise 7.2. What is the output of the following program? Describe in a few words what mus does. Draw a stack diagram just before mus returns.\npublic static int[] make(int n) {\n    int[] a = new int[n];\n    for (int i = 0; i &lt; n; i++) {\n        a[i] = i + 1;\n    }\n    return a;\n}\npublic static void dub(int[] jub) {\n    for (int i = 0; i &lt; jub.length; i++) {\n        jub[i] *= 2;\n    }\n}\npublic static int mus(int[] zoo) {\n    int fus = 0;\n    for (int i = 0; i &lt; zoo.length; i++) {\n        fus += zoo[i];\n    }\n    return fus;\n}\npublic static void main(String[] args) {\n    int[] bob = make(5);\n    dub(bob);\n    System.out.println(mus(bob));\n}\n\n\nExercise 7.3. Write a method called indexOfMax that takes an array of integers and returns the index of the largest element. Can you write this method by using an enhanced for loop? Why or why not?\n\n\nExercise 7.4. The Sieve of Eratosthenes is “a simple, ancient algorithm for finding all prime numbers up to any given limit” (https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes).\nWrite a method called sieve that takes an integer parameter, n, and returns a boolean array that indicates, for each number from 0 to n - 1, whether the number is prime.\n\n\nExercise 7.5. Write a method named areFactors that takes an integer n and an array of integers, and returns true if the numbers in the array are all factors of n (which is to say that n is divisible by all of them).\n\n\nExercise 7.6. Write a method named arePrimeFactors that takes an integer n and an array of integers, and that returns true if the numbers in the array are all prime and* their product is n.*\n\n\nExercise 7.7. Write a method called letterHist that takes a string as a parameter and returns a histogram of the letters in the string. The zeroth element of the histogram should contain the number of a’s in the string (upper- and lowercase); the 25th element should contain the number of z’s. Your solution should traverse the string only once.\n\n\nExercise 7.8. Two words are anagrams if they contain the same letters and the same number of each letter. For example, “stop” is an anagram of “pots”, “allen downey” is an anagram of “well annoyed”, and “christopher mayfield” is an anagram of “hi prof the camel is dry”. Write a method that takes two strings and checks whether they are anagrams of each other.",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Arrays and References</span>"
    ]
  },
  {
    "objectID": "ch08.html",
    "href": "ch08.html",
    "title": "8  Recursive Methods",
    "section": "",
    "text": "8.1 Recursive Void Methods\nConsider the following example:\nThe name of the method is countdown; it takes a single integer as a parameter. If the parameter is 0, it displays the word Blastoff!. Otherwise, it displays the number and then invokes itself, passing n - 1 as the argument.\nWhat happens if we invoke countdown(3) from main?\nAnd then you’re back in main. So the total output looks like this:\nAs a second example, we’ll rewrite the methods newLine and threeLine from Section 4.1. Here they are again:\nAlthough these methods work, they would not help if we wanted to display two newlines, or maybe 100. A more general alternative would be the following:\nThis method takes an integer, n, as a parameter and displays n newlines. The structure is similar to countdown. As long as \\(n\\) is greater than 0, it displays a newline and then invokes itself to display \\((n-1)\\) additional newlines. The total number of newlines is \\(1 + (n - 1)\\), which is just what we wanted: \\(n\\).",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Recursive Methods</span>"
    ]
  },
  {
    "objectID": "ch08.html#recursion",
    "href": "ch08.html#recursion",
    "title": "8  Recursive Methods",
    "section": "",
    "text": "public static void countdown(int n) {\n    if (n == 0) {\n        System.out.println(\"Blastoff!\");\n    } else {\n        System.out.println(n);\n        countdown(n - 1);\n    }\n}\n\n\n\nThe execution of countdown begins with n == 3, and since n is not 0, it displays the value 3, and then invokes itself...\n\nThe execution of countdown begins with n == 2, and since n is not 0, it displays the value 2, and then invokes itself...\n\nThe execution of countdown begins with n == 1, and since n is not 0, it displays the value 1, and then invokes itself...\n\nThe execution of countdown begins with n == 0, and since n is 0, it displays the word Blastoff! and then returns.\n\nThe countdown that got n == 1 returns.\n\nThe countdown that got n == 2 returns.\n\nThe countdown that got n == 3 returns.\n\n\n3\n2\n1\nBlastoff!\n\npublic static void newLine() {\n    System.out.println();\n}\n\npublic static void threeLine() {\n    newLine();\n    newLine();\n    newLine();\n}\n\npublic static void nLines(int n) {\n    if (n &gt; 0) {\n        System.out.println();\n        nLines(n - 1);\n    }\n}",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Recursive Methods</span>"
    ]
  },
  {
    "objectID": "ch08.html#recursive-stack-diagrams",
    "href": "ch08.html#recursive-stack-diagrams",
    "title": "8  Recursive Methods",
    "section": "8.2 Recursive Stack Diagrams",
    "text": "8.2 Recursive Stack Diagrams\nIn Section 4.5, we used a stack diagram to represent the state of a program during a method invocation. The same kind of diagram can make it easier to interpret a recursive method.\nRemember that every time a method gets called, Java creates a new frame that contains the method’s parameters and variables. Figure 8.1 is a stack diagram for countdown, called with n == 3.\n\n\n\n\n\n\n\nStack diagram for the countdown program.\n\n\nBy convention, the frame for main is at the top, and the stack of other frames grows down. That way, we can draw stack diagrams on paper without needing to guess how far they will grow. The frame for main is empty because main does not have any variables. (It has the parameter args, but since we’re not using it, we left it out of the diagram.)\nThere are four frames for countdown, each with a different value for the parameter n. The last frame, with n == 0, is called the base case. It does not make a recursive call, so there are no more frames below it.\nIf there is no base case in a recursive method, or if the base case is never reached, the stack would grow forever—at least in theory. In practice, the size of the stack is limited. If you exceed the limit, you get a StackOverflowError.\nFor example, here is a recursive method without a base case:\npublic static void forever(String s) {\n    System.out.println(s);\n    forever(s);\n}\nThis method displays the given string until the stack overflows, at which point it throws an error. Try this example on your computer—you might be surprised by how long the error message is!",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Recursive Methods</span>"
    ]
  },
  {
    "objectID": "ch08.html#factorial",
    "href": "ch08.html#factorial",
    "title": "8  Recursive Methods",
    "section": "8.3 Value-Returning Methods",
    "text": "8.3 Value-Returning Methods\nTo give you an idea of what you can do with the tools you have learned, let’s look at methods that evaluate recursively defined mathematical functions.\nA recursive definition is similar to a “circular” definition, in the sense that the definition refers to the thing being defined. Of course, a truly circular definition is not very useful:\n\nrecursive:\nAn adjective used to describe a method that is recursive.\n\nIf you saw that definition in the dictionary, you might be annoyed. Then again, if you search for “recursion” on Google, it displays “Did you mean: recursion” as an inside joke. People fall for that link all the time.\nMany mathematical functions are defined recursively, because that is often the simplest way. For example, the factorial of an integer \\(n\\), which is written \\(n!\\), is defined like this: \\[\\begin{aligned}\n&&  0! = 1 \\\\\n&&  n! = n \\cdot(n-1)!\n\\end{aligned}\\] Don’t confuse the mathematical symbol \\(!\\), which means factorial, with the Java operator !, which means not. This definition says that factorial(0) is 1, and factorial(n) is n * factorial(n - 1).\nSo factorial(3) is 3 * factorial(2); factorial(2) is 2 * factorial(1); factorial(1) is 1 * factorial(0); and factorial(0) is 1. Putting it all together, we get 3 * 2 * 1 * 1, which is 6.\nIf you can formulate a recursive definition of something, you can easily write a Java method to evaluate it. The first step is to decide what the parameters and return type are. Since factorial is defined for integers, the method takes an int as a parameter and returns an int:\npublic static int factorial(int n) {\n    return 0;  // stub\n}\nNext, we think about the base case. If the argument happens to be 0, we return 1:\npublic static int factorial(int n) {\n    if (n == 0) {\n        return 1;\n    }\n    return 0;  // stub\n}\nOtherwise, and this is the interesting part, we have to make a recursive call to find the factorial of \\(n-1\\), and then multiply it by \\(n\\):\npublic static int factorial(int n) {\n    if (n == 0) {\n        return 1;\n    }\n    int recurse = factorial(n - 1);\n    int result = n * recurse;\n    return result;\n}\nTo illustrate what is happening, we’ll use the temporary variables recurse and result. In each method call, recurse stores the factorial of \\(n - 1\\), and result stores the factorial of \\(n\\).\nThe flow of execution for this program is similar to countdown from Section 8.1. If we invoke factorial with the value 3:\n\nSince 3 is not 0, we skip the first branch and calculate the factorial of \\(n-1\\)...\n\nSince 2 is not 0, we skip the first branch and calculate the factorial of \\(n-1\\)...\n\nSince 1 is not 0, we skip the first branch and calculate the factorial of \\(n-1\\)...\n\nSince 0 is 0, we take the first branch and return the value 1 immediately.\n\nThe return value (1) gets multiplied by n, which is 1, and the result is returned.\n\nThe return value (1) gets multiplied by n, which is 2, and the result is returned.\n\nThe return value (2) gets multiplied by n, which is 3, and the result, 6, is returned to whatever invoked factorial(3).\n\nFigure 8.2 shows what the stack diagram looks like for this sequence of method invocations. The return values are shown being passed up the stack. Notice that recurse and result do not exist in the last frame, because when n == 0, the code that declares them does not execute.\n\n\n\n\n\n\n\nStack diagram for the factorial method.",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Recursive Methods</span>"
    ]
  },
  {
    "objectID": "ch08.html#leap_of_faith",
    "href": "ch08.html#leap_of_faith",
    "title": "8  Recursive Methods",
    "section": "8.4 The Leap of Faith",
    "text": "8.4 The Leap of Faith\nFollowing the flow of execution is one way to read programs, but it can quickly become overwhelming. Another way to understand recursion is the leap of faith: when you come to a method invocation, instead of following the flow of execution, you assume that the method works correctly and returns the appropriate value.\nIn fact, you are already practicing this leap of faith when you use methods in the Java library. When you invoke Math.cos or System.out.println, you don’t think about the implementations of those methods. You just assume that they work properly.\nThe same is true of other methods. For example, consider the method from Section 5.8 that determines whether an integer has only one digit:\npublic static boolean isSingleDigit(int x) {\n    return x &gt; -10 && x &lt; 10;\n}\nOnce you convince yourself that this method is correct—by examining and testing the code—you can just use the method without ever looking at the implementation again.\nRecursive methods are no different. When you get to a recursive call, don’t think about the flow of execution. Instead, assume that the recursive call produces the desired result.\nFor example, “Assuming that I can find the factorial of \\(n-1\\), can I compute the factorial of \\(n\\)?” Yes you can, by multiplying by \\(n\\). Here’s an implementation of factorial with the temporary variables removed:\npublic static int factorial(int n) {\n    if (n == 0) {\n        return 1;\n    }\n    return n * factorial(n - 1);\n}\nNotice how similar this version is to the original mathematical definition: \\[\\begin{aligned}\n&&  0! = 1 \\\\\n&&  n! = n \\cdot(n-1)!\n\\end{aligned}\\] Of course, it is strange to assume that the method works correctly when you have not finished writing it. But that’s why it’s called a leap of faith!\n\nAnother common recursively defined mathematical function is the Fibonacci sequence, which has the following definition: \\[\\begin{aligned}\n&& fibonacci(1) = 1 \\\\\n&& fibonacci(2) = 1 \\\\\n&& fibonacci(n) = fibonacci(n-1) + fibonacci(n-2)\n\\end{aligned}\\] Notice that each Fibonacci number is the sum of the two preceding Fibonacci numbers. Translated into Java, this function is as follows:\npublic static int fibonacci(int n) {\n    if (n == 1 || n == 2) {\n        return 1;\n    }\n    return fibonacci(n - 1) + fibonacci(n - 2);\n}\nIf you try to follow the flow of execution here, even for small values of n, your head will explode. But if we take a leap of faith and assume that the two recursive invocations work correctly, then it is clear, looking at the definition, that our implementation is correct.",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Recursive Methods</span>"
    ]
  },
  {
    "objectID": "ch08.html#countup",
    "href": "ch08.html#countup",
    "title": "8  Recursive Methods",
    "section": "8.5 Counting Up Recursively",
    "text": "8.5 Counting Up Recursively\nThe countdown example in Section 8.1 has three parts: (1) it checks the base case, (2) it displays something, and (3) it makes a recursive call. What do you think happens if you reverse steps 2 and 3, making the recursive call before displaying?\npublic static void countup(int n) {\n    if (n == 0) {\n        System.out.println(\"Blastoff!\");\n    } else {\n        countup(n - 1);\n        System.out.println(n);\n    }\n}\nThe stack diagram is the same as before, and the method is still called \\(n\\) times. But now the System.out.println happens just before each recursive call returns. As a result, it counts up instead of down:\nBlastoff!\n1\n2\n3\nKeep this in mind for the next example, which displays numbers in binary.",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Recursive Methods</span>"
    ]
  },
  {
    "objectID": "ch08.html#binary",
    "href": "ch08.html#binary",
    "title": "8  Recursive Methods",
    "section": "8.6 Binary Number System",
    "text": "8.6 Binary Number System\nYou are probably aware that computers can store only 1s and 0s. That’s because processors and memory are made up of billions of tiny on-off switches.\nThe value 1 means a switch is on; the value 0 means a switch is off. All types of data, whether integer, floating-point, text, audio, video, or something else, are represented by 1s and 0s.\nFortunately, we can represent any integer as a binary number. Table 8.1 shows the first eight numbers in binary and decimal.\n\n\n\nThe first eight binary numbers.\n\n\nBinary\nDecimal\n\n\n\n\n0\n0\n\n\n1\n1\n\n\n10\n2\n\n\n11\n3\n\n\n100\n4\n\n\n101\n5\n\n\n110\n6\n\n\n111\n7\n\n\n\n\n\nIn decimal there are 10 digits, and the written representation of numbers is based on powers of 10. For example, the number 456 has 4 in the 100’s place, 5 in the 10’s place, and 6 in the 1’s place. So the value is 400 + 50 + 6:\n\n\n\n\n4\n5\n6\n\n\n\n\n\\(10^2\\)\n\\(10^1\\)\n\\(10^0\\)\n\n\n\n\nIn binary there are two digits, and the written representation of numbers is based on powers of two. For example, the number 10111 has 1 in the 16’s place, 0 in the 8’s place, 1 in the 4’s place, 1 in the 2’s place, and 1 in the 1’s place. So the value is 16 + 0 + 4 + 2 + 1, which is 23 in decimal.\n\n\n\n\n1\n0\n1\n1\n1\n\n\n\n\n\\(2^4\\)\n\\(2^3\\)\n\\(2^2\\)\n\\(2^1\\)\n\\(2^0\\)\n\n\n\n\nTo get the digits of a decimal number, we can use repeated division. For example, if we divide 456 by 10, we get 45 with remainder 6. The remainder is the rightmost digit of 456.\nIf we divide the result again, we get 4 with remainder 5. The remainder is the second rightmost digit of 456. And if we divide again, we get 0 with remainder 4. The remainder is the third rightmost digit of 456, and the result, 0, tells us that we’re done.\nWe can do the same thing in binary if we divide by 2. When you divide by 2, the remainder is the right-most digit, either 0 or 1. If you divide the result again, you get the second rightmost digit. If you keep going, and write down the remainders, you’ll have your number in binary:\n23 / 2 is 11 remainder 1\n11 / 2 is  5 remainder 1\n 5 / 2 is  2 remainder 1\n 2 / 2 is  1 remainder 0\n 1 / 2 is  0 remainder 1\nReading these remainders from bottom to top, 23 in binary is 10111.",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Recursive Methods</span>"
    ]
  },
  {
    "objectID": "ch08.html#recursive-binary-method",
    "href": "ch08.html#recursive-binary-method",
    "title": "8  Recursive Methods",
    "section": "8.7 Recursive Binary Method",
    "text": "8.7 Recursive Binary Method\nNow, to display a number in binary, we can combine the algorithm from the previous section and the “count up” pattern from Section 8.5.\nHere is a recursive method that displays any positive integer in binary:\npublic static void displayBinary(int value) {\n    if (value &gt; 0) {\n        displayBinary(value / 2);\n        System.out.print(value % 2);\n    }\n}\nIf value is 0, displayBinary does nothing (that’s the base case). If the argument is positive, the method divides it by 2 and calls displayBinary recursively. When the recursive call returns, the method displays one digit of the result and returns (again). Figure 8.3 illustrates this process.\n\n\n\n\n\n\n\nStack diagram for the displayBinary method.\n\n\nThe leftmost digit is near the bottom of the stack, so it gets displayed first. The rightmost digit, near the top of the stack, gets displayed last. After invoking displayBinary, we use println to complete the output:\ndisplayBinary(23);      // output is 10111\nSystem.out.println();",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Recursive Methods</span>"
    ]
  },
  {
    "objectID": "ch08.html#codingbat-problems",
    "href": "ch08.html#codingbat-problems",
    "title": "8  Recursive Methods",
    "section": "8.8 CodingBat Problems",
    "text": "8.8 CodingBat Problems\nIn the past several chapters, you’ve seen methods, conditions, loops, strings, arrays, and recursion. A great resource for practicing all of these concepts is https://codingbat.com/.\nCodingBat is a free website of programming problems developed by Nick Parlante, a computer science lecturer at Stanford University. As you work on these problems, CodingBat saves your progress (if you create an account).\nTo conclude this chapter, we consider two problems in the Recursion-1 section of CodingBat. One of them deals with strings, and the other deals with arrays. Both of them have the same recursive idea: check the base case, look at the current index, and recursively handle the rest.\nThe first problem is available at https://codingbat.com/prob/p118230:\n\nRecursion-1  noX\nGiven a string, compute recursively a new string where all the 'x' chars have been removed.\nnoX(\"xaxb\") \\(\\rightarrow\\) \"ab\"\nnoX(\"abc\") \\(\\rightarrow\\) \"abc\"\nnoX(\"xx\") \\(\\rightarrow\\) \"\"\n\nWhen solving recursive problems, it helps to think about the base case first. The base case is the easiest version of the problem; for noX, it’s the empty string. If the argument is an empty string, there are no x’s to be removed:\nif (str.length() == 0) {\n    return \"\";\n}\nNext comes the more difficult part. To solve a problem recursively, you need to think of a simpler instance of the same problem. For noX, it’s removing all the x’s from a shorter string.\nSo let’s split the string into two parts, the first letter and the rest:\nchar first = str.charAt(0);\nString rest = str.substring(1);\nNow we can make a recursive call to remove the x’s from rest:\nString recurse = noX(rest);\nIf first happens to be an x, we’re done; we just have to return recurse. Otherwise, we have to concatenate first and recurse. Here’s the if statement we need:\nif (first == 'x') {\n    return recurse;\n} else {\n    return first + recurse;\n}\nYou can run this solution on CodingBat by pasting these snippets into the provided method definition.\nThe second problem is available at https://codingbat.com/prob/p135988:\n\nRecursion-1  array11\nGiven an array of ints, compute recursively the number of times that the value 11 appears in the array.\narray11([1, 2, 11], 0) \\(\\rightarrow\\) 1\narray11([11, 11], 0) \\(\\rightarrow\\) 2\narray11([1, 2, 3, 4], 0) \\(\\rightarrow\\) 0\n\nThis problem uses the convention of passing the index as an argument. So the base case is when we’ve reached the end of the array. At that point, we know there are no more 11s:\nif (index &gt;= nums.length) {\n    return 0;\n}\nNext we look at the current number (based on the given index), and check if it’s an 11. After that, we can recursively check the rest of the array. Similar to the noX problem, we look at only one integer per method call:\nint recurse = array11(nums, index + 1);\nif (nums[index] == 11) {\n    return recurse + 1;\n} else {\n    return recurse;\n}\nAgain, you can run this solutions on CodingBat by pasting the snippets into the method definition.\nTo see how these solutions actually work, you might find it helpful to step through them with a debugger (see Appendix 18.6) or Java Tutor (https://thinkjava.org/javatutor). Then try solving other CodingBat problems on your own.\nLearning to think recursively is an important part of learning to think like a computer scientist. Many algorithms can be written concisely with recursive methods that perform computations on the way down, on the way up, or both.",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Recursive Methods</span>"
    ]
  },
  {
    "objectID": "ch08.html#vocabulary",
    "href": "ch08.html#vocabulary",
    "title": "8  Recursive Methods",
    "section": "8.9 Vocabulary",
    "text": "8.9 Vocabulary\n\niterative:\n\nA method or algorithm that repeats steps by using one or more loops.\n\nrecursive:\n\nA method or algorithm that invokes itself one or more times with different arguments.\n\nbase case:\n\nA condition that causes a recursive method not to make another recursive call.\n\nfactorial:\n\nThe product of all the integers up to and including a given integer.\n\nleap of faith:\n\nA way to read recursive programs by assuming that the recursive call works, rather than following the flow of execution.\n\nbinary:\n\nA system that uses only zeros and ones to represent numbers. Also known as “base 2”.",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Recursive Methods</span>"
    ]
  },
  {
    "objectID": "ch08.html#exercises",
    "href": "ch08.html#exercises",
    "title": "8  Recursive Methods",
    "section": "8.10 Exercises",
    "text": "8.10 Exercises\nThe code for this chapter is in the ch08 directory of ThinkJavaCode2. See page  for instructions on how to download the repository. Before you start the exercises, we recommend that you compile and run the examples.\nIf you have not already read Appendix 18.7, now might be a good time. It describes JUnit, a standard framework for writing test code.\n\nExercise 8.1. The purpose of this exercise is to take a problem and break it into smaller problems, and to solve the smaller problems by writing simple methods. Consider the first verse of the song “99 Bottles of Beer”:\n\n99 bottles of beer on the wall,\n99 bottles of beer,\nya’ take one down, ya’ pass it around,\n98 bottles of beer on the wall.\n\nSubsequent verses are identical except that the number of bottles gets smaller by one in each verse, until the last verse:\n\nNo bottles of beer on the wall,\nno bottles of beer,\nya’ can’t take one down, ya’ can’t pass it around,\n’cause there are no more bottles of beer on the wall!\n\nAnd then the song (finally) ends.\nWrite a program that displays the entire lyrics of “99 Bottles of Beer”. Your program should include a recursive method that does the hard part, but you might want to write additional methods to separate other parts of the program. As you develop your code, test it with a small number of verses, like 3.\n\n\nExercise 8.2. Write a recursive method named oddSum that takes a positive odd integer n and returns the sum of odd integers from 1 to n. Start with a base case, and use temporary variables to debug your solution. You might find it helpful to print the value of n each time oddSum is invoked.\n\n\nExercise 8.3. In this exercise, you will use a stack diagram to understand the execution of the following recursive method:\npublic static void main(String[] args) {\n    System.out.println(prod(1, 4));\n}\n\npublic static int prod(int m, int n) {\n    if (m == n) {\n        return n;\n    } else {\n        int recurse = prod(m, n - 1);\n        int result = n * recurse;\n        return result;\n    }\n}\n\nDraw a stack diagram showing the state of the program just before the last invocation of prod completes.\nWhat is the output of this program? (Try to answer this question on paper first; then run the code to check your answer.)\nExplain in a few words what prod does (without getting into the details of how it works).\nRewrite prod without the temporary variables recurse and result. Hint:* You need only one line for the else branch.*\n\n\n\nExercise 8.4. The goal of this exercise is to translate a recursive definition into a Java method. The Ackermann function is defined for non-negative integers as follows: \\[\\begin{aligned}\nA(m, n) = \\begin{cases}\n              n+1 & \\mbox{if } m = 0 \\\\\n        A(m-1, 1) & \\mbox{if } m &gt; 0 \\mbox{ and } n = 0 \\\\\nA(m-1, A(m, n-1)) & \\mbox{if } m &gt; 0 \\mbox{ and } n &gt; 0\n\\end{cases}\n\\end{aligned}\\]\nWrite a recursive method called ack that takes two ints as parameters and that computes and returns the value of the Ackermann function.\nTest your implementation of Ackermann by invoking it from main and displaying the return value. Note the return value gets very big very quickly. You should try it only for small values of \\(m\\) and \\(n\\) (not bigger than 3).\n\n\nExercise 8.5.\nWrite a recursive method called power that takes a double x and an integer n and returns \\(x^n\\).\n**Hint:* A recursive definition of this operation is \\(x^n = x \\cdot x^{n-1}\\). Also, remember that anything raised to the zeroth power is 1.*\nOptional challenge: you can make this method more efficient, when n is even, using \\(x^n = \\left( x^{n/2} \\right)^2\\).\n\n\nExercise 8.6. Many of the patterns you have seen for traversing arrays can also be written recursively. It is not common, but it is a useful exercise.\n\nWrite a method called maxInRange that takes an array of integers and two indexes, lowIndex and highIndex, and finds the maximum value in the array, but considering only the elements between lowIndex and highIndex, including both.\nThis method should be recursive. If the length of the range is 1 (i.e., if lowIndex == highIndex), we know immediately that the sole element in the range must be the maximum. So that’s the base case.\nIf there is more than one element in the range, we can break the array into two pieces, find the maximum in each piece, and then find the maximum of the maxima.\nMethods like maxInRange can be awkward to use. To find the largest element in an array, we have to provide the range for the entire array:\ndouble max = maxInRange(a, 0, a.length - 1);\nWrite a method called max that takes an array and uses maxInRange to find and return the largest element.\n\n\n\nExercise 8.7. Create a program called Recurse.java* and type in the following methods:*\n/**\n * Returns the first character of the given String.\n */\npublic static char first(String s) {\n    return s.charAt(0);\n}\n/**\n * Returns all but the first letter of the given String.\n */\npublic static String rest(String s) {\n    return s.substring(1);\n}\n/**\n * Returns all but the first and last letter of the String.\n */\npublic static String middle(String s) {\n    return s.substring(1, s.length() - 1);\n}\n/**\n * Returns the length of the given String.\n */\npublic static int length(String s) {\n    return s.length();\n}\n\nWrite some code in main that tests each of these methods. Make sure they work, and you understand what they do.\nUsing these methods, and without using any other String methods, write a method called printString that takes a string as a parameter and displays the letters of the string, one on each line. It should be a void method.\nAgain using only these methods, write a method called printBackward that does the same thing as printString but displays the string backward (again, one character per line).\nNow write a method called reverseString that takes a string as a parameter and returns a new string as a return value. The new string should contain the same letters as the parameter, but in reverse order:\nString backwards = reverseString(\"coffee\");\nSystem.out.println(backwards);\nThe output of this example code should be as follows:\neeffoc\nA palindrome is a word that reads the same both forward and backward, like “otto” and “palindromeemordnilap”. Here’s one way to test whether a string is a palindrome:\n\nA single letter is a palindrome, a two-letter word is a palindrome if the letters are the same, and any other word is a palindrome if the first letter is the same as the last and the middle is a palindrome.\n\nWrite a recursive method named isPalindrome that takes a String and returns a boolean indicating whether the word is a palindrome.",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Recursive Methods</span>"
    ]
  },
  {
    "objectID": "ch09.html",
    "href": "ch09.html",
    "title": "9  Immutable Objects",
    "section": "",
    "text": "9.1 Primitives vs Objects\nNot everything in Java is an object: int, double, char, and boolean are primitive types. When you declare a variable with a primitive type, Java reserves a small amount of memory to store its value. Figure 9.1 shows how the following values are stored in memory:\nAs you learned in Section 7.2, an array variable stores a reference to an array. For example, the following line declares a variable named array and creates an array of three characters:\nFigure 9.2 shows them both, with a box to represent the location of the variable and an arrow pointing to the location of the array.\nObjects work in a similar way. For example, this line declares a String variable named word and creates a String object, as shown in Figure 9.3:\nObjects and arrays are usually created with the new keyword, which allocates memory for them. For convenience, you don’t have to use new to create strings:\nRecall from Section 6.10 that you need to use the equals method to compare strings. The equals method traverses the String objects and tests whether they contain the same characters.\nTo test whether two integers or other primitive types are equal, you can simply use the == operator. But two String objects with the same characters would not be considered equal in the == sense. The == operator, when applied to string variables, tests only whether they refer to the same object.",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Immutable Objects</span>"
    ]
  },
  {
    "objectID": "ch09.html#primitives-vs-objects",
    "href": "ch09.html#primitives-vs-objects",
    "title": "9  Immutable Objects",
    "section": "",
    "text": "int number = -2;\nchar symbol = '!';\n\n\n\n\n\n\n\nMemory diagram of two primitive variables.\n\n\n\nchar[] array = {'c', 'a', 't'};\n\n\n\n\n\n\n\n\nMemory diagram of an array of characters.\n\n\n\nString word = \"dog\";\n\n\n\n\n\n\n\nMemory diagram of a String object.\n\n\n\nString word1 = new String(\"dog\");  // creates a string object\nString word2 = \"dog\";   // implicitly creates a string object",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Immutable Objects</span>"
    ]
  },
  {
    "objectID": "ch09.html#the-null-keyword",
    "href": "ch09.html#the-null-keyword",
    "title": "9  Immutable Objects",
    "section": "9.2 The null Keyword",
    "text": "9.2 The null Keyword\nOften when you declare an object variable, you assign it to reference an object. But sometimes you want to declare a variable that doesn’t refer to an object, at least initially.\nIn Java, the keyword null is a special value that means “no object”. You can initialize object and array variables this way:\nString name = null;\nint[] combo = null;\nThe value null is represented in memory diagrams by a small box with no arrow, as in Figure 9.4.\n\n\n\n\n\n\n\nMemory diagram showing variables that are null.\n\n\nIf you try to use a variable that is null by invoking a method or accessing an element, Java throws a NullPointerException:\nSystem.out.println(name.length());  // NullPointerException\nSystem.out.println(combo[0]);       // NullPointerException\nOn the other hand, it is perfectly fine to pass a null reference as an argument to a method, or to receive one as a return value. In these situations, null is often used to represent a special condition or indicate an error.",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Immutable Objects</span>"
    ]
  },
  {
    "objectID": "ch09.html#strings-are-immutable",
    "href": "ch09.html#strings-are-immutable",
    "title": "9  Immutable Objects",
    "section": "9.3 Strings Are Immutable",
    "text": "9.3 Strings Are Immutable\nIf the Java library didn’t have a String class, we would have to use character arrays to store and manipulate text. Operations like concatenation (+), indexOf, and substring would be difficult and inconvenient. Fortunately, Java does have a String class that provides these and other methods.\nFor example, the methods toLowerCase and toUpperCase convert uppercase letters to lowercase, and vice versa. These methods are often a source of confusion, because it sounds like they modify strings. But neither these methods nor any others can change a string, because strings are immutable.\nWhen you invoke toUpperCase on a string, you get a new String object as a result. For example:\nString name = \"Alan Turing\";\nString upperName = name.toUpperCase();\nAfter these statements run, upperName refers to the string \"ALAN TURING\". But name still refers to \"Alan Turing\". A common mistake is to assume that toUpperCase somehow affects the original string:\nString name = \"Alan Turing\";\nname.toUpperCase();           // ignores the return value\nSystem.out.println(name);\nThe previous code displays \"Alan Turing\", because the value of name, which refers to the original String object, never changes. If you want to change name to be uppercase, then you need to assign the return value:\nString name = \"Alan Turing\";\nname = name.toUpperCase();    // references the new string\nSystem.out.println(name);\nA similar method is replace, which finds and replaces instances of one string within another. This example replaces \"Computer Science\" with \"CS\":\nString text = \"Computer Science is fun!\";\ntext = text.replace(\"Computer Science\", \"CS\");\nAs with toUpperCase, assigning the return value (to text) is important. If you don’t assign the return value, invoking text.replace has no effect.\nStrings are immutable by design, because it simplifies passing them as parameters and return values. And since the contents of a string can never change, two variables can reference the same string without one accidentally corrupting the other.",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Immutable Objects</span>"
    ]
  },
  {
    "objectID": "ch09.html#wrapper-classes",
    "href": "ch09.html#wrapper-classes",
    "title": "9  Immutable Objects",
    "section": "9.4 Wrapper Classes",
    "text": "9.4 Wrapper Classes\nPrimitive types like int, double, and char cannot be null, and they do not provide methods. For example, you can’t invoke equals on an int:\nint i = 5;\nSystem.out.println(i.equals(5));  // compiler error\nBut for each primitive type, there is a corresponding wrapper class in the Java library. The wrapper class for int is named Integer, with a capital I:\nInteger i = Integer.valueOf(5);\nSystem.out.println(i.equals(5));  // displays true\nOther wrapper classes include Boolean, Character, Double, and Long. They are in the java.lang package, so you can use them without importing them.\nLike strings, objects from wrapper classes are immutable, and you have to use the equals method to compare them:\nInteger x = Integer.valueOf(123);\nInteger y = Integer.valueOf(123);\nif (x == y) {                     // false\n    System.out.println(\"x and y are the same object\");\n}\nif (x.equals(y)) {                // true\n    System.out.println(\"x and y have the same value\");\n}\nBecause x and y refer to different objects, this code displays only “x and y have the same value”.\nEach wrapper class defines the constants MIN_VALUE and MAX_VALUE. For example, Integer.MIN_VALUE is -2147483648, and Integer.MAX_VALUE is 2147483647. Because these constants are available in wrapper classes, you don’t have to remember them, and you don’t have to write them yourself.\nWrapper classes also provide methods for converting strings to and from primitive types. For example, Integer.parseInt converts a string to an int. In this context, parse means “read and translate”.\nString str = \"12345\";\nint num = Integer.parseInt(str);\nOther wrapper classes provide similar methods, like Double.parseDouble and Boolean.parseBoolean. They also provide toString, which returns a string representation of a value:\nint num = 12345;\nString str = Integer.toString(num);\nThe result is the String object \"12345\".\nIt’s always possible to convert a primitive value to a string, but not the other way around. For example, say we try to parse an invalid string like this:\nString str = \"five\";\nint num = Integer.parseInt(str);  // NumberFormatException\nparseInt throws a NumberFormatException, because the characters in the string \"five\" are not digits.",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Immutable Objects</span>"
    ]
  },
  {
    "objectID": "ch09.html#command-line-arguments",
    "href": "ch09.html#command-line-arguments",
    "title": "9  Immutable Objects",
    "section": "9.5 Command-Line Arguments",
    "text": "9.5 Command-Line Arguments\nNow that you know about strings, arrays, and wrapper classes, we can finally explain the args parameter of the main method, which we have been ignoring since Chapter 1. If you are unfamiliar with the command-line interface, please read Appendix 18.3.\nLet’s write a program to find the maximum value in a sequence of numbers. Rather than read the numbers from System.in by using a Scanner, we’ll pass them as command-line arguments. Here is a starting point:\nimport java.util.Arrays;\npublic class Max {\n    public static void main(String[] args) {\n        System.out.println(Arrays.toString(args));\n    }\n}\nYou can run this program from the command line by typing this:\njava Max\nThe output indicates that args is an empty array; that is, it has no elements:\n[]\nIf you provide additional values on the command line, they are passed as arguments to main. For example, say you run the program like this:\njava Max 10 -3 55 0 14\nThe output is shown here:\n[10, -3, 55, 0, 14]\nIt’s not clear from the output, but the elements of args are strings. So args is the array \\{\"10\", \"-3\", \"55\", \"0\", \"14\"\\}. To find the maximum number, we have to convert the arguments to integers.\nThe following code uses an enhanced for loop (see Section 7.8) to parse the arguments and find the largest value:\nint max = Integer.MIN_VALUE;\nfor (String arg : args) {\n    int value = Integer.parseInt(arg);\n    if (value &gt; max) {\n        max = value;\n    }\n}\nSystem.out.println(\"The max is \" + max);\nWe begin by initializing max to the smallest (most negative) number an int can represent. That way, the first value we parse will replace max. As we find larger values, they will replace max as well.\nIf args is empty, the result will be MIN_VALUE. We can prevent this situation from happening by checking args at the beginning of the program:\nif (args.length == 0) {\n    System.err.println(\"Usage: java Max &lt;numbers&gt;\");\n    return;\n}\nIt’s customary for programs that require command-line arguments to display a “usage” message if the arguments are not valid. For example, if you run javac or java from the command line without any arguments, you will get a very long message.",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Immutable Objects</span>"
    ]
  },
  {
    "objectID": "ch09.html#argument-validation",
    "href": "ch09.html#argument-validation",
    "title": "9  Immutable Objects",
    "section": "9.6 Argument Validation",
    "text": "9.6 Argument Validation\nAs we discussed in Section 5.9, you should never assume that program input will be in the correct format. Sometimes users make mistakes, such as pressing the wrong key or misreading instructions.\nOr even worse, someone might make intentional “mistakes” to see what your program will do. One way hackers break into computer systems is by entering malicious input that causes a program to fail.\nProgrammers can make mistakes too. It’s difficult to write bug-free software, especially when working in teams on large projects.\nFor all of these reasons, it’s good practice to validate arguments passed to methods, including the main method. In the previous section, we did this by ensuring that args.length was not 0.\nAs a further example, consider a method that checks whether the first word of a sentence is capitalized. We can write this method using the Character wrapper class:\npublic static boolean isCapitalized(String str) {\n    return Character.isUpperCase(str.charAt(0));\n}\nThe expression str.charAt(0) makes two assumptions: the string object referenced by str exists, and it has at least one character. What if these assumptions don’t hold at run-time?\n\nIf str is null, invoking charAt will cause a NullPointerException, because you can’t invoke a method on null.\nIf str refers to an empty string, which is a String object with no characters, charAt will cause a StringIndexOutOfBoundsException, because there is no character at index 0.\n\nWe can prevent these exceptions by validating str at the start of the method. If it’s invalid, we return before executing the rest of the method:\npublic static boolean isCapitalized(String str) {\n    if (str == null || str.isEmpty()) {\n        return false;\n    }\n    return Character.isUpperCase(str.charAt(0));\n}\nNotice that null and empty are different concepts, as shown in Figure 9.5. The variable str1 is null, meaning that it doesn’t reference an object. The variable str2 refers to the empty string, an object that exists.\n\n\n\n\n\n\n\nMemory diagram of null and empty string.\n\n\nBeginners sometimes make the mistake of checking for empty first. Doing so causes a NullPointerException, because you can’t invoke methods on variables that are null:\nif (str.isEmpty() || str == null) {    // wrong!\nChecking for null first prevents the NullPointerException. If str is null, the || operator will short circuit (see Section [shortcircuit]) and evaluate to true immediately. As a result, str.isEmpty() will not be called.",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Immutable Objects</span>"
    ]
  },
  {
    "objectID": "ch09.html#biginteger-arithmetic",
    "href": "ch09.html#biginteger-arithmetic",
    "title": "9  Immutable Objects",
    "section": "9.7 BigInteger Arithmetic",
    "text": "9.7 BigInteger Arithmetic\nIt might not be clear at this point why you would ever need an integer object when you can just use an int or long. One advantage is the variety of methods that Integer and Long provide. But there is another reason: when you need very large integers that exceed Long.MAX_VALUE.\nBigInteger is a Java class that can represent arbitrarily large integers. There is no upper bound except the limitations of memory size and processing speed. Take a minute to read the documentation, which you can find by doing a web search for “Java BigInteger”.\nTo use BigIntegers, you have to import java.math.BigInteger at the beginning of your program. There are several ways to create a BigInteger, but the simplest uses valueOf. The following code converts a long to a BigInteger:\nlong x = 17;\nBigInteger big = BigInteger.valueOf(x);\nYou can also create BigIntegers from strings. For example, here is a 20-digit integer that is too big to store using a long:\nString s = \"12345678901234567890\";\nBigInteger bigger = new BigInteger(s);\nNotice the difference in the previous two examples: you use valueOf to convert integers, and new BigInteger to convert strings.\nSince BigIntegers are not primitive types, the usual math operators don’t work. Instead, we have to use methods like add. To add two BigIntegers, we invoke add on one and pass the other as an argument:\nBigInteger a = BigInteger.valueOf(17);\nBigInteger b = BigInteger.valueOf(1700000000);\nBigInteger c = a.add(b);\nLike strings, BigInteger objects are immutable. Methods like add, multiply, and pow all return new BigIntegers, rather than modify an existing one.\nInternally, a BigInteger is implemented using an array of ints, similar to the way a string is implemented using an array of chars. Each int in the array stores a portion of the BigInteger. The methods of BigInteger traverse this array to perform addition, multiplication, etc.\nFor very long floating-point values, take a look at java.math.BigDecimal. Interestingly, BigDecimal objects represent floating-point numbers internally by using a BigInteger!",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Immutable Objects</span>"
    ]
  },
  {
    "objectID": "ch09.html#encapsulation",
    "href": "ch09.html#encapsulation",
    "title": "9  Immutable Objects",
    "section": "9.8 Incremental Design",
    "text": "9.8 Incremental Design\nOne challenge of programming, especially for beginners, is figuring out how to divide a program into methods. In this section, we present a design process that allows you to divide a program into methods as you go along. The process is called “encapsulation and generalization”. The essential steps are as follows:\n\nWrite a few lines of code in main or another method, and test them.\nWhen they are working, wrap them in a new method and test again.\nIf it’s appropriate, replace literal values with variables and parameters.\n\nTo demonstrate this process, we’ll develop methods that display multiplication tables. We begin by writing and testing a few lines of code. Here is a loop that displays the multiples of two, all on one line:\nfor (int i = 1; i &lt;= 6; i++) {\n    System.out.printf(\"%4d\", 2 * i);\n}\nSystem.out.println();\nEach time through the loop, we display the value of 2 * i, padded with spaces so it’s four characters wide. Since we use System.out.printf, the output appears on a single line.\nAfter the loop, we call println to print a newline character. Remember that in some environments, none of the output is displayed until the line is complete. The output of the code so far is shown here:\n2   4   6   8  10  12\nThe next step is to encapsulate the code; that is, we “wrap” the code in a method:\npublic static void printRow() {\n    for (int i = 1; i &lt;= 6; i++) {\n        System.out.printf(\"%4d\", 2 * i);\n    }\n    System.out.println();\n}\nFinally, we generalize the method to print multiples of other numbers by replacing the constant value 2 with a parameter n. This step is called “generalization”, because it makes the method more general (less specific):\npublic static void printRow(int n) {\n    for (int i = 1; i &lt;= 6; i++) {\n        System.out.printf(\"%4d\", n * i);  // generalized n\n    }\n    System.out.println();\n}\nInvoking this method with the argument 2 yields the same output as before. With the argument 3, the output is as follows:\n3   6   9  12  15  18\nBy now, you can probably guess how we are going to display a multiplication table: we’ll invoke printRow repeatedly with different arguments. In fact, we’ll use another loop to iterate through the rows:\nfor (int i = 1; i &lt;= 6; i++) {\n    printRow(i);\n}\nAnd the output looks like this:\n1   2   3   4   5   6\n   2   4   6   8  10  12\n   3   6   9  12  15  18\n   4   8  12  16  20  24\n   5  10  15  20  25  30\n   6  12  18  24  30  36",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Immutable Objects</span>"
    ]
  },
  {
    "objectID": "ch09.html#more-generalization",
    "href": "ch09.html#more-generalization",
    "title": "9  Immutable Objects",
    "section": "9.9 More Generalization",
    "text": "9.9 More Generalization\nThe previous result is similar to the “nested loops” approach in Section 6.4. However, the inner loop is now encapsulated in the printRow method. We can encapsulate the outer loop in a method too:\npublic static void printTable() {\n    for (int i = 1; i &lt;= 6; i++) {\n        printRow(i);\n    }\n}\nThe initial version of printTable always displays six rows. We can generalize it by replacing the literal 6 with a parameter:\npublic static void printTable(int rows) {\n    for (int i = 1; i &lt;= rows; i++) {     // generalized rows\n        printRow(i);\n    }\n}\nHere is the output of printTable(7):\n1   2   3   4   5   6\n   2   4   6   8  10  12\n   3   6   9  12  15  18\n   4   8  12  16  20  24\n   5  10  15  20  25  30\n   6  12  18  24  30  36\n   7  14  21  28  35  42\nThat’s better, but it always displays the same number of columns. We can generalize more by adding a parameter to printRow:\npublic static void printRow(int n, int cols) {\n    for (int i = 1; i &lt;= cols; i++) {     // generalized cols\n        System.out.printf(\"%4d\", n * i);\n    }\n    System.out.println();\n}\nNow printRow takes two parameters: n is the value whose multiples should be displayed, and cols is the number of columns. Since we added a parameter to printRow, we also have to change the line in printTable where it is invoked:\npublic static void printTable(int rows) {\n    for (int i = 1; i &lt;= rows; i++) {\n        printRow(i, rows);\n    }\n}\nWhen this line executes, it evaluates rows and passes the value, which is 7 in this example, as an argument. In printRow, this value is assigned to cols. As a result, the number of columns equals the number of rows, so we get a square 7 x 7 table, instead of the previous 7 x 6 table.\nWhen you generalize a method appropriately, you often find that it has capabilities you did not plan. For example, you might notice that the multiplication table is symmetric. Since \\(ab = ba\\), all the entries in the table appear twice. You could save ink by printing half of the table, and you would have to change only one line of printTable:\nprintRow(i, i);  // using i for both n and cols\nThis means the length of each row is the same as its row number. The result is a triangular multiplication table:\n1\n   2   4\n   3   6   9\n   4   8  12  16\n   5  10  15  20  25\n   6  12  18  24  30  36\n   7  14  21  28  35  42  49\nGeneralization makes code more versatile, more likely to be reused, and sometimes easier to write.",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Immutable Objects</span>"
    ]
  },
  {
    "objectID": "ch09.html#vocabulary",
    "href": "ch09.html#vocabulary",
    "title": "9  Immutable Objects",
    "section": "9.10 Vocabulary",
    "text": "9.10 Vocabulary\n\nobject-oriented:\n\nA way of organizing code and data into objects, rather than independent methods.\n\nobject:\n\nA collection of related data that comes with a set of methods that operate on the data.\n\nprimitive:\n\nA data type that stores a single value and provides no methods.\n\nimmutable:\n\nAn object that, once created, cannot be modified. Strings are immutable by design.\n\nwrapper class:\n\nClasses in java.lang that provide constants and methods for working with primitive types.\n\nparse:\n\nIn Chapter 2, we defined parse as what the compiler does to analyze a program. Now you know that it means to read a string and interpret or translate it.\n\nempty array:\n\nAn array with no elements and a length of zero.\n\ndesign process:\n\nA process for determining what methods a class or program should have.\n\nencapsulate:\n\nTo wrap data inside an object, or to wrap statements inside a method.\n\ngeneralize:\n\nTo replace something unnecessarily specific (like a constant value) with something appropriately general (like a variable or parameter).",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Immutable Objects</span>"
    ]
  },
  {
    "objectID": "ch09.html#exercises",
    "href": "ch09.html#exercises",
    "title": "9  Immutable Objects",
    "section": "9.11 Exercises",
    "text": "9.11 Exercises\nThe code for this chapter is in the ch09 directory of ThinkJavaCode2. See page  for instructions on how to download the repository. Before you start the exercises, we recommend that you compile and run the examples.\n\nExercise 9.1. The point of this exercise is to explore Java types and fill in some of the details that aren’t covered in the chapter.\n\nCreate a new program named Test.java* and write a main method that contains expressions that combine various types using the + operator. For example, what happens when you “add” a String and a char? Does it perform character addition or string concatenation? What is the type of the result?*\nMake a bigger copy of the following table and fill it in. At the intersection of each pair of types, you should indicate whether it is legal to use the + operator with these types, the operation that is performed (addition or concatenation), and the type of the result.\n\n\n\n\n\nboolean\n char \n  int  \ndouble\nString\n\n\n\n\nboolean\n\n\n\n\n\n\n\nchar\n\n\n\n\n\n\n\nint\n\n\n\n\n\n\n\ndouble\n\n\n\n\n\n\n\nString\n\n\n\n\n\n\n\n\n\nThink about some of the choices the designers of Java made, based on this table. How many of the entries seem unavoidable, as if there was no other choice? How many seem like arbitrary choices from several equally reasonable possibilities? Which entries seem most problematic?\nHere’s a puzzler: normally, the statement x++ is exactly equivalent to x = x + 1. But if x is a char, it’s not exactly the same! In that case, x++ is legal, but x = x + 1 causes an error. Try it out. See what the error message is, and then see if you can figure out what is going on.\nWhat happens when you add \"\" (the empty string) to the other types; for example, \"\" + 5?\n\n\n\nExercise 9.2. You might be sick of the factorial method by now, but we’re going to do one more version.\n\nCreate a new program called Big.java* and write an iterative version of factorial (using a for loop).*\nDisplay a table of the integers from 0 to 30 along with their factorials. At some point around 15, you will probably see that the answers are not correct anymore. Why not?\nConvert factorial so that it performs its calculation using BigIntegers and returns a BigInteger as a result. You can leave the parameter alone; it will still be an integer.\nTry displaying the table again with your modified factorial method. Is it correct up to 30? How high can you make it go?\n\n\n\nExercise 9.3. Many encryption algorithms depend on the ability to raise large integers to a power. Here is a method that implements an efficient algorithm for integer exponentiation:\npublic static int pow(int x, int n) {\n    if (n == 0) return 1;\n\n    // find x to the n/2 recursively\n    int t = pow(x, n / 2);\n\n    // if n is even, the result is t squared\n    // if n is odd, the result is t squared times x\n    if (n % 2 == 0) {\n        return t * t;\n    } else {\n        return t * t * x;\n    }\n}\nThe problem with this method is that it works only if the result is small enough to be represented by an int. Rewrite it so that the result is a BigInteger. The parameters should still be integers, though.\nYou should use the BigInteger methods add and multiply. But don’t use BigInteger.pow; that would spoil the fun.\n\n\nExercise 9.4. One way to calculate \\(e^x\\) is to use the following infinite series expansion. The \\(i\\)th term in the series is \\(x^i / i!\\). \\[e^x = 1 + x + x^2 / 2! + x^3 / 3! + x^4 / 4! + \\ldots\\]\n\nWrite a method called myexp that takes x and n as parameters and estimates \\(e^x\\) by adding the first n terms of this series. You can use the factorial method from Section 8.3 or your iterative version from the previous exercise.\nYou can make this method more efficient by observing that the numerator of each term is the same as its predecessor multiplied by x, and the denominator is the same as its predecessor multiplied by i.\nUse this observation to eliminate the use of Math.pow and factorial, and check that you get the same result.\nWrite a method called check that takes a parameter, x, and displays x, myexp(x), and Math.exp(x). The output should look like this:\n1.0     2.708333333333333     2.718281828459045\nUse the escape sequence '\\\\t' to display a tab character between each of the values.\nVary the number of terms in the series (the second argument that check sends to myexp) and see the effect on the accuracy of the result. Adjust this value until the estimated value agrees with the correct answer when x is 1.\nWrite a loop in main that invokes check with the values 0.1, 1.0, 10.0, and 100.0. How does the accuracy of the result vary as x varies? Compare the number of digits of agreement rather than the difference between the actual and estimated values.\nAdd a loop in main that checks myexp with the values -0.1, -1.0, -10.0, and -100.0. Comment on the accuracy.\n\n\n\nExercise 9.5. The goal of this exercise is to practice encapsulation and generalization using some of the examples in previous chapters.\n\nStarting with the code in Section 7.5, write a method called powArray that takes a double array, a, and returns a new array that contains the elements of a squared. Generalize it to take a second argument and raise the elements of a to the given power.\nStarting with the code in Section 7.8, write a method called histogram that takes an int array of scores from 0 to (but not including) 100, and returns a histogram of 100 counters. Generalize it to take the number of counters as an argument.\n\n\n\nExercise 9.6. The following code fragment traverses a string and checks whether it has the same number of opening and closing parentheses:\nString s = \"((3 + 7) * 2)\";\nint count = 0;\n\nfor (int i = 0; i &lt; s.length(); i++) {\n    char c = s.charAt(i);\n    if (c == '(') {\n        count++;\n    } else if (c == ')') {\n        count--;\n    }\n}\n\nSystem.out.println(count);\n\nEncapsulate this fragment in a method that takes a string argument and returns the final value of count.\nTest your method with multiple strings, including some that are balanced and some that are not.\nGeneralize the code so that it works on any string. What could you do to generalize it more?",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Immutable Objects</span>"
    ]
  },
  {
    "objectID": "ch10.html",
    "href": "ch10.html",
    "title": "10  Mutable Objects",
    "section": "",
    "text": "10.1 Point Objects\nIn math, 2D points are often written in parentheses with a comma separating the coordinates. For example, \\((0,0)\\) indicates the origin, and \\((x,y)\\) indicates the point \\(x\\) units to the right and \\(y\\) units up from the origin.\nThe java.awt package provides a class named Point that represents a location in a Cartesian plane. In order to use the Point class, you have to import it:\nThen, to create a new point, you use the new operator:\nThe first line declares that blank has type Point. The second line creates the new Point with the coordinates \\(x=3\\) and \\(y=4\\). The result of the new operator is a reference to the object. Figure 10.1 shows the result.\nAs usual, the name of the variable blank appears outside the box, and its value appears inside the box. In this case, the value is a reference, which is represented with an arrow. The arrow points to the Point object, which contains two variables, x and y.\nVariables that belong to an object are called attributes. In some documentation, you also see them called “fields”. To access an attribute of an object, Java uses dot notation. For example:\nThe expression blank.x means “go to the object blank refers to, and get the value of the attribute x.” In this case, we assign that value to a local variable named x.\nThere is no conflict between the local variable x and the attribute x. The purpose of dot notation is to identify which variable you are referring to unambiguously.\nYou can use dot notation as part of an expression. For example:\nThe first line displays 3, 4. The second line calculates the value 25.",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Mutable Objects</span>"
    ]
  },
  {
    "objectID": "ch10.html#point",
    "href": "ch10.html#point",
    "title": "10  Mutable Objects",
    "section": "",
    "text": "import java.awt.Point;\n\nPoint blank;\nblank = new Point(3, 4);\n\n\n\n\n\n\n\n\nMemory diagram showing a variable that refers to a Point object.\n\n\n\n\nint x = blank.x;\n\n\n\nSystem.out.println(blank.x + \", \" + blank.y);\nint sum = blank.x * blank.x + blank.y * blank.y;",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Mutable Objects</span>"
    ]
  },
  {
    "objectID": "ch10.html#objects-as-parameters",
    "href": "ch10.html#objects-as-parameters",
    "title": "10  Mutable Objects",
    "section": "10.2 Objects as Parameters",
    "text": "10.2 Objects as Parameters\nYou can pass objects as parameters in the usual way. For example:\npublic static void printPoint(Point p) {\n    System.out.println(\"(\" + p.x + \", \" + p.y + \")\");\n}\nThis method takes a point as an argument and displays its attributes in parentheses. If you invoke printPoint(blank), it displays (3, 4).\nAs another example, we can rewrite the distance method from Section 4.9 so that it takes two Points as parameters instead of four doubles:\npublic static double distance(Point p1, Point p2) {\n    int dx = p2.x - p1.x;\n    int dy = p2.y - p1.y;\n    return Math.sqrt(dx * dx + dy * dy);\n}\nPassing objects as parameters makes the source code more readable and less error-prone because related values are bundled together.\nYou actually don’t need to write a distance method, because Point objects already have one. To compute the distance between two points, we invoke distance on one and pass the other as an argument:\nPoint p1 = new Point(0, 0);\nPoint p2 = new Point(3, 4);\ndouble dist = p1.distance(p2);  // dist is 5.0\nIt turns out you don’t need the printPoint method either. If you invoke System.out.println(blank), it prints the type of the object and the values of the attributes:\njava.awt.Point[x=3,y=4]\nPoint objects provide a method called toString that returns a string representation of a point. When you call println with objects, it automatically calls toString and displays the result.",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Mutable Objects</span>"
    ]
  },
  {
    "objectID": "ch10.html#sec:Rectangle",
    "href": "ch10.html#sec:Rectangle",
    "title": "10  Mutable Objects",
    "section": "10.3 Objects as Return Values",
    "text": "10.3 Objects as Return Values\nThe java.awt package also provides a class named Rectangle. To use it, you have to import it:\nimport java.awt.Rectangle;\nRectangle objects are similar to points, but they have four attributes: x, y, width, and height. The following example creates a Rectangle object and makes the variable box refer to it:\nRectangle box = new Rectangle(0, 0, 100, 200);\nFigure 10.2 shows the effect of this assignment.\n\n\n\n\n\n\n\nMemory diagram showing a Rectangle object.\n\n\nIf you run System.out.println(box), you get this:\njava.awt.Rectangle[x=0,y=0,width=100,height=200]\nAgain, println uses the toString method provided by Rectangle, which knows how to represent Rectangle objects as strings.\nYou can also write methods that return new objects. For example, findCenter takes a Rectangle as an argument and returns a Point with the coordinates of the center of the rectangle:\npublic static Point findCenter(Rectangle box) {\n    int x = box.x + box.width / 2;\n    int y = box.y + box.height / 2;\n    return new Point(x, y);\n}\nThe return type of this method is Point. The last line creates a new Point object and returns a reference to it.",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Mutable Objects</span>"
    ]
  },
  {
    "objectID": "ch10.html#rectangles-are-mutable",
    "href": "ch10.html#rectangles-are-mutable",
    "title": "10  Mutable Objects",
    "section": "10.4 Rectangles Are Mutable",
    "text": "10.4 Rectangles Are Mutable\nYou can change the contents of an object by making an assignment to one of its attributes. For example, to “move” a rectangle without changing its size, you can modify the x and y values:\nRectangle box = new Rectangle(0, 0, 100, 200);\nbox.x = box.x + 50;\nbox.y = box.y + 100;\nThe result is shown in Figure 10.3.\n\n\n\n\n\n\n\nMemory diagram showing updated attributes.\n\n\nWe can encapsulate this code in a method and generalize it to move the rectangle by any amount:\npublic static void moveRect(Rectangle box, int dx, int dy) {\n    box.x = box.x + dx;\n    box.y = box.y + dy;\n}\nThe variables dx and dy indicate how far to move the rectangle in each direction. Invoking this method has the effect of modifying the Rectangle that is passed as an argument:\nRectangle box = new Rectangle(0, 0, 100, 200);\nmoveRect(box, 50, 100);  // now at (50, 100, 100, 200)\nModifying objects by passing them as arguments to methods can be useful. But it can also make debugging difficult, because it is not always clear which method invocations modify their arguments.\nJava provides a number of methods that operate on Points and Rectangles. For example, translate has the same effect as moveRect, but instead of passing the rectangle as an argument, you use dot notation:\nbox.translate(50, 100);\nThis line invokes the translate method on the object that box refers to, which modifies the object.\nThis syntax—using dot notation to invoke a method on an object, rather than passing it as a parameter—is more consistent with the style of object-oriented programming.",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Mutable Objects</span>"
    ]
  },
  {
    "objectID": "ch10.html#aliasing",
    "href": "ch10.html#aliasing",
    "title": "10  Mutable Objects",
    "section": "10.5 Aliasing Revisited",
    "text": "10.5 Aliasing Revisited\nRemember that when you assign an object to a variable, you are assigning a reference to an object. It is possible to have multiple variables that refer to the same object. For example, this code creates two variables that refer to the same Rectangle:\nRectangle box1 = new Rectangle(0, 0, 100, 200);\nRectangle box2 = box1;\nFigure 10.4 shows the result: box1 and box2 refer to the same object, so any changes that affect one variable also affect the other.\n\n\n\n\n\n\n\nMemory diagram showing two variables that refer to the same Rectangle object.\n\n\nFor example, the following code uses grow to make box1 bigger by 50 units in all directions. It decreases x and y by 50, and it increases height and width by 100:\nbox1.grow(50, 50);                // grow box1 (alias)\nThe result is shown in Figure 10.5.\n\n\n\n\n\n\n\nMemory diagram showing the effect of invoking grow.\n\n\nNow, if we print box1, we are not surprised to see that it has changed:\njava.awt.Rectangle[x=-50,y=-50,width=200,height=300]\nAnd if we print box2, we should not be surprised to see that it has changed too, because it refers to the same object:\njava.awt.Rectangle[x=-50,y=-50,width=200,height=300]\nThis scenario is called “aliasing” because a single object has multiple names, or aliases, that refer to it.\nAs you can tell from this simple example, code that involves aliasing can get confusing fast, and it can be difficult to debug.",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Mutable Objects</span>"
    ]
  },
  {
    "objectID": "ch10.html#src.zip",
    "href": "ch10.html#src.zip",
    "title": "10  Mutable Objects",
    "section": "10.6 Java Library Source",
    "text": "10.6 Java Library Source\nSo far we have used several classes from the Java library, including System, String, Scanner, Math, and Random. These classes are written in Java, so you can read the source code to see how they work.\nThe Java library contains thousands of files, many of which are thousands of lines of code. That’s more than one person could read and understand fully, but don’t be intimidated!\nBecause it’s so large, the library source code is stored in a ZIP archive named src.zip. If you have Java installed on your computer, you should already have this file somewhere:\n\nOn Linux, it’s likely under: /usr/lib/jvm/.../lib\nIf not, you might have to install the openjdk-...-source package.\nOn macOS, it’s likely under:\n/Library/Java/JavaVirtualMachines/.../Contents/Home/lib\nOn Windows, it’s likely under: C:\\Program Files\\Java\\...\\lib\n\nWhen you open (or unzip) the file, you will see folders that correspond to Java packages. For example, open the java folder, and then open the awt folder. (If you don’t see a java folder at first, open the java.desktop folder.) You should now see Point.java and Rectangle.java, along with the other classes in the java.awt package.\nOpen Point.java in your editor and skim through the file. It uses language features we haven’t discussed yet, so you probably won’t understand every line. But you can get a sense of what professional Java source code looks like by browsing through the library.\nNotice how much of Point.java is documentation (see Appendix 19). Each method includes comments and tags like @param and @return. Javadoc reads these comments and generates documentation in HTML. You can see the same documentation online by doing a web search for “Java Point”.\nNow take a look at the grow and translate methods in the Rectangle class. There is more to them than you may have expected.",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Mutable Objects</span>"
    ]
  },
  {
    "objectID": "ch10.html#UML",
    "href": "ch10.html#UML",
    "title": "10  Mutable Objects",
    "section": "10.7 Class Diagrams",
    "text": "10.7 Class Diagrams\nTo summarize what you’ve learned so far, Point and Rectangle objects have attributes and methods. Attributes are an object’s data; methods are an object’s code. An object’s class definition specifies the attributes and methods that it has.\nUnified Modeling Language (UML) defines a graphical way to summarize this information. Figure 10.6 shows two examples, the UML class diagrams for the Point and Rectangle classes.\n\n\n\n\n\n\n\nUML class diagrams for Point and Rectangle.\n\n\nEach class is represented by a box with the name of the class, a list of attributes, and a list of methods.\nTo identify the types of attributes and parameters, UML uses a language-independent syntax, like x: int rather than Java syntax, int x.\nThe plus sign (+) identifies public attributes and methods. A minus sign (-) identifies private attributes and methods, which we discuss in the next chapter.\nBoth Point and Rectangle have additional methods; we show only the ones introduced in this chapter.\nIn contrast to memory diagrams, which visualize objects (and variables) at run-time, a class diagram visualizes the source code at compile-time.",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Mutable Objects</span>"
    ]
  },
  {
    "objectID": "ch10.html#scope-revisited",
    "href": "ch10.html#scope-revisited",
    "title": "10  Mutable Objects",
    "section": "10.8 Scope Revisited",
    "text": "10.8 Scope Revisited\nIn Section 4.5, we introduced the idea that variables have scope. The scope of a variable is the part of a program where a variable can be used.\nConsider the first few lines of the Rectangle.translate method from the Java library source code:\npublic void translate(int dx, int dy) {\n    int oldv = this.x;\n    int newv = oldv + dx;\n    if (dx &lt; 0) {\n    ...\nThis example uses three kinds of variables:\n\nParameters (dx and dy)\nLocal variables (oldv and newv)\nAttributes (this.x)\n\nParameters and local variables are created when a method is invoked, and they disappear when the method returns. They can be used anywhere inside the method, but not in other methods and not in other classes.\nAttributes are created when an object is created, and they disappear when the object is destroyed. They can be used in any of the object’s methods, using the keyword this. And if they are public, they can be used in other classes via references to the object, box1.x.\nWhen the Java compiler encounters a variable name, it searches backward for its declaration. The compiler first looks for local variables, then parameters, then attributes.",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Mutable Objects</span>"
    ]
  },
  {
    "objectID": "ch10.html#garbage",
    "href": "ch10.html#garbage",
    "title": "10  Mutable Objects",
    "section": "10.9 Garbage Collection",
    "text": "10.9 Garbage Collection\nIn the previous section, we said that attributes exist as long as the object exists. But when does an object cease to exist? Here is a simple example:\nPoint blank = new Point(3, 4);\nblank = null;\nThe first line creates a new Point object and makes blank refer to it. The second line changes blank so that instead of referring to the object, it refers to nothing. As shown in Figure 10.7, after the second assignment, there are no references to the Point object.\n\n\n\n\n\n\n\nMemory diagram showing the effect of setting a variable to null.\n\n\nIf there are no references to an object, there is no way to access its attributes or invoke a method on it. From the program’s point of view, it ceases to exist. However, it’s still present in the computer’s memory, taking up space.\nAs your program runs, the system automatically looks for stranded objects and deletes them; then the space can be reused for new objects. This process is called garbage collection.\nYou don’t have to do anything to make garbage collection happen, and in general, you don’t have to be aware of it. But in high-performance applications, you may notice a slight delay every now and then while Java reclaims space from discarded objects.",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Mutable Objects</span>"
    ]
  },
  {
    "objectID": "ch10.html#mutable-vs-immutable",
    "href": "ch10.html#mutable-vs-immutable",
    "title": "10  Mutable Objects",
    "section": "10.10 Mutable vs Immutable",
    "text": "10.10 Mutable vs Immutable\nPoints and Rectangles are mutable objects, because their attributes can be modified. You can modify their attributes directly, like box.x = 15, or you can invoke methods that modify their attributes, like box.translate(15, 0).\nIn contrast, immutable objects like Strings and Integers cannot be modified. They don’t allow direct access to their attributes or provide methods that change them.\nImmutable objects have advantages that help improve the reliability and performance of programs. You can pass strings (and other immutable objects) to methods without worrying about their contents changing as a side-effect of the method. That makes programs easier to debug and more reliable.\nAlso, two strings that contain the same characters can be stored in memory only once. That can reduce the amount of memory the program uses and can speed it up.\nIn the following example, s1 and s2 are created differently, but they refer to equivalent strings; that is, the two strings contain the same characters:\npublic class Surprise {\n    public static void main(String[] args) {\n        String s1 = \"Hi, Mom!\";\n        String s2 = \"Hi, \" + \"Mom!\";\n        if (s1 == s2) {                // true!\n            System.out.println(\"s1 and s2 are the same\");\n        }\n    }\n}\nBecause both strings are specified at compile time, the compiler can tell that they are equivalent. And because strings are immutable, there is no need to make two copies; the compiler can create one String and make both variables refer to it.\nAs a result, the test s1 == s2 turns out to be true, which means that s1 and s2 refer to the same object. In other words, they are not just equivalent; they are identical.\nAlthough immutable objects have some advantages, mutable objects have other advantages. Sometimes it is more efficient to modify an existing object, rather than create a new one. And some computations can be expressed more naturally using mutation.\nNeither design is always better, which is why you will see both.",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Mutable Objects</span>"
    ]
  },
  {
    "objectID": "ch10.html#stringbuilder",
    "href": "ch10.html#stringbuilder",
    "title": "10  Mutable Objects",
    "section": "10.11 StringBuilder Objects",
    "text": "10.11 StringBuilder Objects\nHere’s an example in which mutable objects are efficient and arguably more natural: building a long string by concatenating lots of small pieces.\nStrings are particularly inefficient for this operation. For example, consider the following program, which reads 10 lines from System.in and concatenates them into a single String:\nString text = \"\";\nfor (int i = 0; i &lt; 10; i++) {\n    String line = in.nextLine();        // new string\n    text = text + line + '\\n';    // two more strings\n}\nSystem.out.print(\"You entered:\\n\" + text);\nInside the for loop, in.nextLine() returns a new string each time it is invoked. The next line of code concatenates text and line, which creates another string, and then appends the newline character, which creates yet another string.\nAs a result, this loop creates 30 String objects! At the end, text refers to the most recent String. Garbage collection deletes the rest, but that’s a lot of garbage for a seemingly simple program.\nThe Java library provides the StringBuilder class for just this reason. It’s part of the java.lang package, so you don’t need to import it. Because StringBuilder objects are mutable, they can implement concatenation more efficiently.\nHere’s a version of the program that uses StringBuilder:\nStringBuilder text = new StringBuilder();\nfor (int i = 0; i &lt; 10; i++) {\n    String line = in.nextLine();\n    text.append(line);\n    text.append('\\n');\n}\nSystem.out.print(\"You entered:\\n\" + text);\nThe append method takes a String as a parameter and appends it to the end of the StringBuilder. Each time it is invoked, it modifies the StringBuilder; it doesn’t create any new objects.\nIf needed, you can return the StringBuilder’s contents as a string by calling the toString method:\nString result = text.toString();\nThe StringBuilder class also provides methods for inserting and deleting parts of strings efficiently. Programs that manipulate large amounts of text run much faster if you use StringBuilder instead of String.",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Mutable Objects</span>"
    ]
  },
  {
    "objectID": "ch10.html#vocabulary",
    "href": "ch10.html#vocabulary",
    "title": "10  Mutable Objects",
    "section": "10.12 Vocabulary",
    "text": "10.12 Vocabulary\n\nattribute:\n\nOne of the named data items that make up an object.\n\ndot notation:\n\nUse of the dot operator (.) to access an object’s attributes or methods.\n\nUML:\n\nUnified Modeling Language, a standard way to draw diagrams for software engineering.\n\nclass diagram:\n\nAn illustration of the attributes and methods for a class.\n\ngarbage collection:\n\nThe process of finding objects that have no references and reclaiming their storage space.\n\nmutable:\n\nAn object that can be modified at any time. Points and rectangles are mutable by design.",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Mutable Objects</span>"
    ]
  },
  {
    "objectID": "ch10.html#exercises",
    "href": "ch10.html#exercises",
    "title": "10  Mutable Objects",
    "section": "10.13 Exercises",
    "text": "10.13 Exercises\nThe code for this chapter is in the ch10 directory of ThinkJavaCode2. See page  for instructions on how to download the repository. Before you start the exercises, we recommend that you compile and run the examples.\nAt this point, you know enough to read Appendix 20, which is about simple 2D graphics and animations. During the next few chapters, you should take a detour to read this appendix and work through the exercises.\n\nExercise 10.1. The point of this exercise is to make sure you understand the mechanism for passing objects as parameters.\n\nFor the following program, draw a stack diagram showing the local variables and parameters of main and riddle just before riddle returns. Use arrows to show which objects each variable references.\nWhat is the output of the program?\nIs the blank object mutable or immutable? How can you tell?\n\npublic static int riddle(int x, Point p) {\n    x = x + 7;\n    return x + p.x + p.y;\n}\npublic static void main(String[] args) {\n    int x = 5;\n    Point blank = new Point(1, 2);\n\n    System.out.println(riddle(x, blank));\n    System.out.println(x);\n    System.out.println(blank.x);\n    System.out.println(blank.y);\n}\n\n\nExercise 10.2. The point of this exercise is to make sure you understand the mechanism for returning new objects from methods. The following code uses findCenter and distance as defined in this chapter.\n\nDraw a stack diagram showing the state of the program just before findCenter returns. Include all variables and parameters, and show the objects those variables refer to.\nDraw a stack diagram showing the state of the program just before distance returns. Show all variables, parameters, and objects.\nWhat is the output of this program? (Can you tell without running it?)\n\npublic static void main(String[] args) {\n    Point blank = new Point(5, 8);\n\n    Rectangle rect = new Rectangle(0, 2, 4, 4);\n    Point center = findCenter(rect);\n\n    double dist = distance(center, blank);\n    System.out.println(dist);\n}\n\n\nExercise 10.3. This exercise is about aliasing. Recall that aliases are two variables that refer to the same object. The following code uses findCenter and printPoint as defined in this chapter.\n\nDraw a diagram that shows the state of the program just before the end of main. Include all local variables and the objects they refer to.\nWhat is the output of the program?\nAt the end of main, are p1 and p2 aliased? Why or why not?\n\npublic static void main(String[] args) {\n    Rectangle box1 = new Rectangle(2, 4, 7, 9);\n    Point p1 = findCenter(box1);\n    printPoint(p1);\n\n    box1.grow(1, 1);\n    Point p2 = findCenter(box1);\n    printPoint(p2);\n}",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Mutable Objects</span>"
    ]
  },
  {
    "objectID": "ch11.html",
    "href": "ch11.html",
    "title": "11  Designing Classes",
    "section": "",
    "text": "11.1 The Time Class\nA common reason to define a new class is to encapsulate related data in an object that can be treated as a single unit. That way, we can use objects as parameters and return values, rather than passing and returning multiple values. You have already seen two types that encapsulate data in this way: Point and Rectangle.\nAnother example, which we will implement ourselves, is Time, which represents a time of day. The data encapsulated in a Time object includes an hour, a minute, and a number of seconds. Because every Time object contains these values, we define attributes to hold them.\nAttributes are also called instance variables, because each instance has its own variables (as opposed to “class variables”, coming up in Section 12.3).\nThe first step is to decide what type each variable should be. It seems clear that hour and minute should be integers. Just to keep things interesting, let’s make second a double.\nInstance variables are declared at the beginning of the class definition, outside any method. By itself, this code fragment is a legal class definition:\nThe Time class is public, which means that it can be used in other classes. But the instance variables are private, which means they can be accessed only from inside the Time class. If you try to read or write them from another class, you will get a compiler error.\nPrivate instance variables help keep classes isolated from each other, so that changes in one class won’t require changes in other classes. It also simplifies what other programmers need to know to use your classes. This kind of isolation is called information hiding.",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Designing Classes</span>"
    ]
  },
  {
    "objectID": "ch11.html#the-time-class",
    "href": "ch11.html#the-time-class",
    "title": "11  Designing Classes",
    "section": "",
    "text": "public class Time {\n    private int hour;\n    private int minute;\n    private double second;\n}",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Designing Classes</span>"
    ]
  },
  {
    "objectID": "ch11.html#constructors",
    "href": "ch11.html#constructors",
    "title": "11  Designing Classes",
    "section": "11.2 Constructors",
    "text": "11.2 Constructors\nAfter declaring instance variables, the next step is to define a constructor, which is a special method that initializes the object. The syntax for constructors is similar to that of other methods, except for the following:\n\nThe name of the constructor is the same as the name of the class.\nConstructors have no return type (and no return value).\nThe keyword static is omitted.\n\nHere is an example constructor for the Time class:\npublic Time() {\n    this.hour = 0;\n    this.minute = 0;\n    this.second = 0.0;\n}\nThis constructor does not take any arguments. Each line initializes an instance variable to 0 (which is midnight for a Time object).\nThe name this is a keyword that refers to the object we are creating. You can use this the same way you use the name of any other object. For example, you can read and write the instance variables of this, and you can pass this as an argument to other methods. But you do not declare this, and you can’t make an assignment to it.\nA common error when writing constructors is to put a return statement at the end. Like void methods, constructors do not return values.\nTo create a Time object, you must use the new operator:\npublic static void main(String[] args) {\n    Time time = new Time();\n}\nWhen you use new, Java creates the object and invokes your constructor to initialize the instance variables. When the constructor is done, new returns a reference to the new object. In this example, the reference gets assigned to the variable time, which has type Time. Figure 11.1 shows the result.\n\n\n\n\n\n\n\nMemory diagram of a Time object.\n\n\nBeginners sometimes make the mistake of using new in the constructor:\npublic Time() {\n    new Time();         // StackOverflowError\n    this.hour = 0;\n    this.minute = 0;\n    this.second = 0.0;\n}\nDoing so causes an infinite recursion, since new invokes the same constructor, which uses new again, which invokes the constructor again, and so on.",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Designing Classes</span>"
    ]
  },
  {
    "objectID": "ch11.html#value-constructors",
    "href": "ch11.html#value-constructors",
    "title": "11  Designing Classes",
    "section": "11.3 Value Constructors",
    "text": "11.3 Value Constructors\nLike other methods, constructors can be overloaded, which means you can provide multiple constructors with different parameters. Java knows which constructor to invoke by matching the arguments you provide with the parameters of the constructor.\nIt is common to provide both a “default constructor” that takes no arguments, like the previous one, and a “value constructor”, like this one:\npublic Time(int hour, int minute, double second) {\n    this.hour = hour;\n    this.minute = minute;\n    this.second = second;\n}\nTo invoke this constructor, you have to provide arguments to the new operator. The following example creates a Time object that represents a fraction of a second before noon:\nTime time = new Time(11, 59, 59.9);\nOverloading constructors provides the flexibility to create an object first and then fill in the attributes, or collect all the information before creating the object itself.\nOnce you get the hang of it, writing constructors gets boring. You can write them quickly just by looking at the list of instance variables. In fact, some IDEs can generate them for you.\nHere is the complete class definition so far:\npublic class Time {\n    private int hour;\n    private int minute;\n    private double second;\n\n    public Time() {\n        this.hour = 0;\n        this.minute = 0;\n        this.second = 0.0;\n    }\n\n    public Time(int hour, int minute, double second) {\n        this.hour = hour;\n        this.minute = minute;\n        this.second = second;\n    }\n}\nNotice how the second constructor declares the parameters hour, minute, and second. Java allows you to declare parameters (and local variables) with the same names as instance variables. They don’t have to use the same names, but it’s common practice.\nThe right side of this.hour = hour; refers to the parameter hour, since it was declared most recently. This situation is called shadowing, because the parameter “hides” the instance variable with the same name.\nJava provides the keyword this so you can access instance variables, regardless of shadowing. As a result, this constructor copies the values from the parameters to the instance variables.",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Designing Classes</span>"
    ]
  },
  {
    "objectID": "ch11.html#getters-and-setters",
    "href": "ch11.html#getters-and-setters",
    "title": "11  Designing Classes",
    "section": "11.4 Getters and Setters",
    "text": "11.4 Getters and Setters\nRecall that the instance variables of Time are private. We can access them from within the Time class, but if we try to read or write them from another class, the compiler reports an error.\nA class that uses objects defined in another class is called a client. For example, here is a new class called TimeClient:\npublic class TimeClient {\n\n    public static void main(String[] args) {\n        Time time = new Time(11, 59, 59.9);\n        System.out.println(time.hour);      // compiler error\n    }\n}\nIf you compile this code, you get an error message like “hour has private access in Time”. There are three ways to solve this problem:\n\nMake the instance variables public.\nProvide methods to access the instance variables.\nDecide that it’s not a problem and refuse to let other classes access the instance variables.\n\nThe first choice is appealing because it’s simple. But here is the problem: when class \\(A\\) accesses the instance variables of class \\(B\\) directly, \\(A\\) becomes dependent on \\(B\\). If anything in \\(B\\) changes later, it is likely that \\(A\\) will have to change too.\nBut if \\(A\\) uses only methods to interact with \\(B\\), \\(A\\) and \\(B\\) are less dependent, which means that we can make changes in \\(B\\) without affecting \\(A\\) (as long as we don’t change the method parameters). So we generally avoid making instance variables public.\nThe second option is to provide methods that access the instance variables. For example, we might want the instance variables to be “read only”; that is, code in other classes should be able to read them but not write them. We can do that by providing one method for each instance variable:\npublic int getHour() {\n    return this.hour;\n}\n\npublic int getMinute() {\n    return this.minute;\n}\n\npublic double getSecond() {\n    return this.second;\n}\nMethods like these are formally called “accessors”, but more commonly referred to as getters. By convention, the method that gets a variable named something is called getSomething.\nWe can fix the compiler error in TimeClient by using the getter:\nSystem.out.println(time.getHour());\nIf we decide that TimeClient should also be able to modify the instance variables of Time, we can provide methods to do that too:\npublic void setHour(int hour) {\n    this.hour = hour;\n}\n\npublic void setMinute(int minute) {\n    this.minute = minute;\n}\n\npublic void setSecond(double second) {\n    this.second = second;\n}\nThese methods are formally called “mutators”, but more commonly known as setters. The naming convention is similar; the method that sets something is usually called setSomething.\nWriting getters and setters can get boring, but many IDEs can generate them for you based on the instance variables.",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Designing Classes</span>"
    ]
  },
  {
    "objectID": "ch11.html#displaying-objects",
    "href": "ch11.html#displaying-objects",
    "title": "11  Designing Classes",
    "section": "11.5 Displaying Objects",
    "text": "11.5 Displaying Objects\nTo display Time objects, we can write a method to display the hour, minute, and second. Using printTime in Section 4.4 as a starting point, we could write the following:\npublic static void printTime(Time t) {\n    System.out.print(t.hour);\n    System.out.print(\":\");\n    System.out.print(t.minute);\n    System.out.print(\":\");\n    System.out.println(t.second);\n}\nThe output of this method, given the time object from the first example, would be 11:59:59.9. We can use printf to make the code more concise:\npublic static void printTime(Time t) {\n    System.out.printf(\"%02d:%02d:%04.1f\\n\",\n        t.hour, t.minute, t.second);\n}\nAs a reminder, you need to use \\%d with integers, and \\%f with floating-point numbers. The 02 option means “total width 2, with leading zeros if necessary”, and the 04.1 option means “total width 4, one digit after the decimal point, leading zeros if necessary”. The output is the same: 11:59:59.9.\nThere’s nothing wrong with a method like printTime, but it is not consistent with object-oriented style. A more idiomatic solution is to provide a special method called toString.",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Designing Classes</span>"
    ]
  },
  {
    "objectID": "ch11.html#the-tostring-method",
    "href": "ch11.html#the-tostring-method",
    "title": "11  Designing Classes",
    "section": "11.6 The toString Method",
    "text": "11.6 The toString Method\nEvery object has a method called toString that returns a string representation of the object. When you display an object using print or println, Java invokes the object’s toString method.\nBy default, it simply displays the type of the object and its address in hexadecimal. So, say you create a Time object and display it with println:\npublic static void main(String[] args) {\n    Time time = new Time(11, 59, 59.9);\n    System.out.println(time);\n}\nThe output looks something like this:\nTime@80cc7c0\nThis address can be useful for debugging, if you want to keep track of individual objects.\nBut you can override this behavior by providing your own toString method. For example, here is a toString method for Time:\npublic String toString() {\n    return String.format(\"%02d:%02d:%04.1f\\n\",\n        this.hour, this.minute, this.second);\n}\nThe definition does not have the keyword static, because it is not a static method. It is an instance method, so called because when you invoke it, you invoke it on an instance of the class. Instance methods are sometimes called “non-static”; you might see this term in an error message.\nThe body of the method is similar to printTime in the previous section, with two changes:\n\nInside the method, we use this to refer to the current instance; that is, the object the method is invoked on.\nInstead of printf, it uses String.format, which returns a formatted String rather than displaying it.\n\nNow you can call toString directly:\nTime time = new Time(11, 59, 59.9);\nString s = time.toString();\nThe value of s is the string \"11:59:59.9\". You can also invoke toString indirectly by invoking print or println:\nSystem.out.println(time);\nThis code displays the string \"11:59:59.9\". Either way, when you use this inside toString, it refers to the same object as time.",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Designing Classes</span>"
    ]
  },
  {
    "objectID": "ch11.html#equals",
    "href": "ch11.html#equals",
    "title": "11  Designing Classes",
    "section": "11.7 The equals Method",
    "text": "11.7 The equals Method\nWe have seen two ways to check whether values are equal: the == operator and the equals method. With objects, you can use either one, but they are not the same:\n\nThe == operator checks whether two references are identical; that is, whether they refer to the same object.\nThe equals method checks whether two objects are equivalent; that is, whether they have the same values.\n\nThe definition of identity is always the same, so the == operator always does the same thing. But the definition of equivalence is different for different objects, so objects can define their own equals methods.\nConsider the following variables and the corresponding memory diagram in Figure 11.2:\nTime time1 = new Time(9, 30, 0.0);\nTime time2 = time1;\nTime time3 = new Time(9, 30, 0.0);\n\n\n\n\n\n\n\nMemory diagram of three Time variables.\n\n\nThe assignment operator copies references, so time1 and time2 refer to the same object. Because they are identical, time1 == time2 is true. But time1 and time3 refer to two different objects. Because they are not identical, time1 == time3 is false.\nBy default, the equals method does the same thing as ==. For Time objects, that’s probably not what we want. For example, time1 and time3 represent the same time of day, so we should consider them equivalent.\nWe can provide an equals method that implements this idea:\npublic boolean equals(Time that) {\n    final double DELTA = 0.001;\n    return this.hour == that.hour\n        && this.minute == that.minute\n        && Math.abs(this.second - that.second) &lt; DELTA;\n}\nequals is an instance method, so it doesn’t have the keyword static. It uses this to refer to the current object, and that to refer to the other. that is not a keyword, so we could have given this parameter a different name. But using that makes the code nicely readable.\nWe can invoke equals like this:\ntime1.equals(time3);\nInside the equals method, this refers to the same object as time1, and that refers to the same object as time3. Since their instance variables are “equal”, the result is true.\nBecause hour and minute are integers, we compare them with ==. But second is a floating-point number. Because of rounding errors, it is not good to compare floating-point numbers with == (see Section 2.7). Instead, we check whether the difference is smaller than a threshold, DELTA.\nMany objects have a similar notion of equivalence; that is, two objects are considered equal if their instance variables are equal. But other definitions are possible.",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Designing Classes</span>"
    ]
  },
  {
    "objectID": "ch11.html#addingtime",
    "href": "ch11.html#addingtime",
    "title": "11  Designing Classes",
    "section": "11.8 Adding Times",
    "text": "11.8 Adding Times\nSuppose you are going to a movie that starts at 18:50 (that is, 6:50 PM), and the running time is 2 hours, 16 minutes. What time does the movie end? We’ll use Time objects to figure it out:\nTime startTime = new Time(18, 50, 0.0);\nTime runningTime = new Time(2, 16, 0.0);\nHere are two ways we could “add” the Time objects:\n\nWrite a static method that takes two Time objects as parameters.\nWrite an instance method that gets invoked on one object and takes the other as a parameter.\n\nTo demonstrate the difference, we’ll do both. Here is the static method:\npublic static Time add(Time t1, Time t2) {\n    Time sum = new Time();\n    sum.hour = t1.hour + t2.hour;\n    sum.minute = t1.minute + t2.minute;\n    sum.second = t1.second + t2.second;\n    return sum;\n}\nAnd here’s how we would invoke it:\nTime endTime = Time.add(startTime, runningTime);\nHere’s what it looks like as an instance method:\npublic Time add(Time t2) {\n    Time sum = new Time();\n    sum.hour = this.hour + t2.hour;\n    sum.minute = this.minute + t2.minute;\n    sum.second = this.second + t2.second;\n    return sum;\n}\nAnd here’s how we would invoke it:\nTime endTime = startTime.add(runningTime);\nNotice the differences:\n\nThe static method has the keyword static; the instance method does not.\nThe static method has two parameters, t1 and t2. The instance method has one explicit parameter, t2, and the implicit parameter, this.\nWe invoked the static method with the Time class; we invoked the instance method with the startTime object.\n\nThat’s all there is to it. Static methods and instance methods do the same thing, and you can convert from one to the other with just a few changes.\nHowever, there’s a problem with both of these methods; they are not correct. The result from either method is 20:66, which is not a valid time.\nIf second exceeds 59, we have to carry into the minutes column, and if minute exceeds 59, we have to carry into hour.\nHere is a better version of the instance method, add:\npublic Time add(Time t2) {\n    Time sum = new Time();\n    sum.hour = this.hour + t2.hour;\n    sum.minute = this.minute + t2.minute;\n    sum.second = this.second + t2.second;\n\n    if (sum.second &gt;= 60.0) {\n        sum.second -= 60.0;\n        sum.minute += 1;\n    }\n    if (sum.minute &gt;= 60) {\n        sum.minute -= 60;\n        sum.hour += 1;\n    }\n    if (sum.hour &gt;= 24) {\n        sum.hour -= 24;\n    }\n    return sum;\n}\nIf hour exceeds 23, we subtract 24 hours, but there’s no days attribute to carry into.",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Designing Classes</span>"
    ]
  },
  {
    "objectID": "ch11.html#vocabulary",
    "href": "ch11.html#vocabulary",
    "title": "11  Designing Classes",
    "section": "11.9 Vocabulary",
    "text": "11.9 Vocabulary\n\nclass:\n\nIn Chapter 1, we defined a class as a collection of related methods. Now you know that a class is also a template for a new type of object.\n\ninstance:\n\nA member of a class. Every object is an instance of a class.\n\ninstantiate:\n\nCreate a new instance of a class in the computer’s memory.\n\ninstance variable:\n\nAn attribute of an object; a non-static variable defined at the class level.\n\ninformation hiding:\n\nThe practice of making instance variables private to limit dependencies between classes.\n\nconstructor:\n\nA special method that initializes the instance variables of a newly constructed object.\n\nshadowing:\n\nOccurs when a local variable or parameter has the same name as an attribute.\n\nclient:\n\nA class that uses objects defined in another class.\n\ngetter:\n\nA method that returns the value of an instance variable.\n\nsetter:\n\nA method that assigns a value to an instance variable.\n\noverride:\n\nTo replace a default implementation of a method, such as toString.\n\ninstance method:\n\nA non-static method that has access to this and the instance variables.\n\nidentical:\n\nReferences to the same object (at the same location in memory).\n\nequivalent:\n\nObjects that are equal in value, as defined by the equals method.",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Designing Classes</span>"
    ]
  },
  {
    "objectID": "ch11.html#exercises",
    "href": "ch11.html#exercises",
    "title": "11  Designing Classes",
    "section": "11.10 Exercises",
    "text": "11.10 Exercises\nThe code for this chapter is in the ch11 directory of ThinkJavaCode2. See page  for instructions on how to download the repository. Before you start the exercises, we recommend that you compile and run the examples.\n\nExercise 11.1. The implementation of increment in this chapter is not very efficient. Can you rewrite it so it doesn’t use any loops?\n**Hint:* Remember the remainder operator—it works with floating-point too.*\n\n\nExercise 11.2. In the board game Scrabble, each tile contains a letter, which is used to spell words in rows and columns, and a score, which is used to determine the value of words. The point of this exercise is to practice the mechanical part of creating a new class definition:\n\nWrite a definition for a class named Tile that represents Scrabble tiles. The instance variables should include a character named letter and an integer named value.\nWrite a constructor that takes parameters named letter and value, and initializes the instance variables.\nWrite a method named printTile that takes a Tile object as a parameter and displays the instance variables in a reader-friendly format.\nWrite a main method that creates a Tile object with the letter Z and the value 10, and then uses printTile to display the state of the object.\nImplement the toString and equals methods for a Tile.\nCreate getters and setters for each of the attributes.\n\n\n\nExercise 11.3. Write a class definition for Date, an object type that contains three integers: year, month, and day. This class should provide two constructors. The first should take no parameters and initialize a default date. The second should take parameters named year, month and day, and use them to initialize the instance variables.\nWrite a main method that creates a new Date object named birthday. The new object should contain your birth date. You can use either constructor.\n\n\nExercise 11.4. A “rational number” is a number that can be represented as the ratio of two integers. For example, \\(2/3\\) is a rational number, and you can think of 7 as a rational number with an implicit 1 in the denominator.\nThe purpose of this exercise is to write a class definition that includes a variety of methods, including constructors, static methods, instance methods, modifiers, and pure methods:\n\nDefine a class called Rational. A Rational object should have two integer instance variables that store the numerator and denominator.\nWrite a constructor that takes no arguments and sets the numerator to 0 and denominator to 1.\nWrite an instance method called printRational that displays a Rational object in a reasonable format.\nWrite a main method that creates a new object with type Rational, sets its instance variables to the values of your choice, and displays the object.\nYou now have a minimal testable program. Test it and, if necessary, debug it.\nWrite a toString method for Rational and test it using println.\nWrite a second constructor that takes two arguments and uses them to initialize the instance variables.\nWrite an instance method called negate that reverses the sign of a rational number. This method should be a modifier, so it should be void. Add lines to main to test the new method.\nWrite an instance method called invert that swaps the numerator and denominator. It should be a modifier. Add lines to main to test the new method.\nWrite an instance method called toDouble that converts the rational number to a double (floating-point number) and returns the result. This method is a pure method; it does not modify the object. As always, test the new method.\nWrite an instance method named reduce that reduces a rational number to its lowest terms by finding the greatest common divisor (GCD) of the numerator and denominator and dividing through. This method should be a pure method; it should not modify the instance variables of the object on which it is invoked.\n**Hint:* Finding the GCD takes only a few lines of code. Search the web for “Euclidean algorithm”.*\nWrite an instance method called add that takes a Rational number as an argument, adds it to this, and returns a new Rational object. There are several ways to add fractions. You can use any one you want, but you should make sure that the result of the operation is reduced so that the numerator and denominator have no common divisor (other than 1).",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Designing Classes</span>"
    ]
  },
  {
    "objectID": "ch12.html",
    "href": "ch12.html",
    "title": "12  Arrays of Objects",
    "section": "",
    "text": "12.1 Card Objects\nIf we want to define a class to represent a playing card, it is pretty clear what the instance variables should be: rank and suit. It is not as obvious what types they should be.\nOne possibility is a String containing things like \"Spade\" for suits and \"Queen\" for ranks. A problem with this choice is that it would not be easy to compare cards to see which had a higher rank or suit.\nAn alternative is to use integers to encode the ranks and suits. By encode, we don’t mean to encrypt or translate into a secret code. We mean to define a mapping between a sequence of numbers and the things we want to represent.\nHere is a mapping for suits:\nWe use the mathematical symbol \\(\\mapsto\\) to make it clear that these mappings are not part of the program. They are part of the program design, but they never appear explicitly in the code.\nEach of the numerical ranks (2 through 10) maps to the corresponding integer. For the face cards, we can use the following:\nWith this encoding, the class definition for the Card type looks like this:\nThe instance variables are private: we can access them from inside this class, but not from other classes.\nThe constructor takes a parameter for each instance variable. To create a Card object, we use the new operator:\nThe result is a reference to a Card that represents the 3 of Clubs.",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Arrays of Objects</span>"
    ]
  },
  {
    "objectID": "ch12.html#card-objects",
    "href": "ch12.html#card-objects",
    "title": "12  Arrays of Objects",
    "section": "",
    "text": "Clubs\n\\(\\mapsto\\)\n0\n\n\nDiamonds\n\\(\\mapsto\\)\n1\n\n\nHearts\n\\(\\mapsto\\)\n2\n\n\nSpades\n\\(\\mapsto\\)\n3\n\n\n\n\n\n\n\n\nAce\n\\(\\mapsto\\)\n1\n\n\nJack\n\\(\\mapsto\\)\n11\n\n\nQueen\n\\(\\mapsto\\)\n12\n\n\nKing\n\\(\\mapsto\\)\n13\n\n\n\n\npublic class Card {\n    private int rank;\n    private int suit;\n\n    public Card(int rank, int suit) {\n        this.rank = rank;\n        this.suit = suit;\n    }\n}\n\n\nCard threeOfClubs = new Card(3, 0);",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Arrays of Objects</span>"
    ]
  },
  {
    "objectID": "ch12.html#card-tostring",
    "href": "ch12.html#card-tostring",
    "title": "12  Arrays of Objects",
    "section": "12.2 Card toString",
    "text": "12.2 Card toString\nWhen you create a new class, the first step is to declare the instance variables and write constructors. A good next step is to write toString, which is useful for debugging and incremental development.\nTo display Card objects in a way that humans can read easily, we need to “decode” the integer values as words. A natural way to do that is with an array of Strings. For example, we can create the array like this:\nString[] suits = new String[4];\nAnd then assign values to the elements:\nsuits[0] = \"Clubs\";\nsuits[1] = \"Diamonds\";\nsuits[2] = \"Hearts\";\nsuits[3] = \"Spades\";\nOr we can create the array and initialize the elements at the same time, as you saw in Section 7.3:\nString[] suits = {\"Clubs\", \"Diamonds\", \"Hearts\", \"Spades\"};\nThe memory diagram in Figure 12.1 shows the result. Each element of the array is a reference to a String.\n\n\n\n\n\n\n\nMemory diagram of an array of strings.\n\n\nWe also need an array to decode the ranks:\nString[] ranks = {null, \"Ace\", \"2\", \"3\", \"4\", \"5\", \"6\",\n           \"7\", \"8\", \"9\", \"10\", \"Jack\", \"Queen\", \"King\"};\nThe zeroth element should never be used, because the only valid ranks are 1–13. We set it to null to indicate an unused element.\nUsing these arrays, we can create a meaningful String by using suit and rank as indexes.\nString s = ranks[this.rank] + \" of \" + suits[this.suit];\nThe expression ranks[this.rank] means “use the instance variable rank from this object as an index into the array ranks.” We select the string for this.suit in a similar way.\nNow we can wrap all the previous code in a toString method:\npublic String toString() {\n    String[] ranks = {null, \"Ace\", \"2\", \"3\", \"4\", \"5\", \"6\",\n               \"7\", \"8\", \"9\", \"10\", \"Jack\", \"Queen\", \"King\"};\n    String[] suits = {\"Clubs\", \"Diamonds\", \"Hearts\", \"Spades\"};\n    String s = ranks[this.rank] + \" of \" + suits[this.suit];\n    return s;\n}\nWhen we display a card, println automatically calls toString. The output of the following code is Jack of Diamonds:\nCard card = new Card(11, 1);\nSystem.out.println(card);",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Arrays of Objects</span>"
    ]
  },
  {
    "objectID": "ch12.html#classvar",
    "href": "ch12.html#classvar",
    "title": "12  Arrays of Objects",
    "section": "12.3 Class Variables",
    "text": "12.3 Class Variables\nSo far you have seen local variables, which are declared inside a method, and instance variables, which are declared in a class definition, usually before the method definitions. Now it’s time to learn about class variables. They are shared across all instances of the class.\nLike instance variables, class variables are defined in a class definition, before the method definitions. But they are identified by the keyword static. Here is a version of Card in which RANKS and SUITS are defined as class variables:\npublic class Card {\n\n    public static final String[] RANKS = {\n        null, \"Ace\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\",\n        \"8\", \"9\", \"10\", \"Jack\", \"Queen\", \"King\"};\n\n    public static final String[] SUITS = {\n        \"Clubs\", \"Diamonds\", \"Hearts\", \"Spades\"};\n\n    // instance variables and constructors go here\n\n    public String toString() {\n        return RANKS[this.rank] + \" of \" + SUITS[this.suit];\n    }\n}\nClass variables are allocated when the program begins and persist until the program ends. In contrast, instance variables like rank and suit are allocated when the program creates new objects, and they are deleted when the object is garbage-collected (see Section 10.9).\nClass variables are often used to store constant values that are needed in several places. In that case, they should also be declared as final. Note that whether a variable is static or final involves two separate considerations: static means the variable is shared, and final means the variable (or in this case, the reference) is constant.\nNaming static final variables with capital letters is a common convention that makes it easier to recognize their role in the class. In the toString method, we refer to SUITS and RANKS as if they were local variables, but we can tell that they are class variables.\nOne advantage of defining SUITS and RANKS as class variables is that they don’t need to be created (and garbage-collected) every time toString is called. They may also be needed in other methods and classes, so it’s helpful to make them available everywhere.",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Arrays of Objects</span>"
    ]
  },
  {
    "objectID": "ch12.html#the-compareto-method",
    "href": "ch12.html#the-compareto-method",
    "title": "12  Arrays of Objects",
    "section": "12.4 The compareTo Method",
    "text": "12.4 The compareTo Method\nAs you saw in Section 11.7, it’s helpful to create an equals method to test whether two objects are equivalent:\npublic boolean equals(Card that) {\n    return this.rank == that.rank\n        && this.suit == that.suit;\n}\nIt would also be nice to have a method for comparing cards, so we can tell if one is higher or lower than another. For primitive types, we can use comparison operators like &lt; and &gt; to compare values. But these operators don’t work for object types.\nFor strings, Java provides a compareTo method, as you saw in Section 6.10. We can write our own version of compareTo for the classes that we define, as we did for the equals method.\nSome types are “totally ordered”, which means that you can compare any two values and tell which is bigger. Integers and strings are totally ordered. Other types are “unordered”, which means that there is no meaningful way to say that one element is bigger than another. In Java, the boolean type is unordered; if you try to compare true &lt; false, you get a compiler error.\nThe set of playing cards is “partially ordered”, which means that sometimes we can compare cards and sometimes not. For example, we know that the 3 of Clubs is higher than the 2 of Clubs, and the 3 of Diamonds is higher than the 3 of Clubs. But which is better, the 3 of Clubs or the 2 of Diamonds? One has a higher rank, but the other has a higher suit.\nTo make cards comparable, we have to decide which is more important: rank or suit. The choice is arbitrary, and it might be different for different games. But when you buy a new deck of cards, it comes sorted with all the Clubs together, followed by all the Diamonds, and so on. So for now, let’s say that suit is more important. With that decided, we can write compareTo as follows:\npublic int compareTo(Card that) {\n    if (this.suit &lt; that.suit) {\n        return -1;\n    }\n    if (this.suit &gt; that.suit) {\n        return 1;\n    }\n    if (this.rank &lt; that.rank) {\n        return -1;\n    }\n    if (this.rank &gt; that.rank) {\n        return 1;\n    }\n    return 0;\n}\ncompareTo returns -1 if this is a lower card, +1 if this is a higher card, and 0 if this and that are equivalent. It compares suits first. If the suits are the same, it compares ranks. If the ranks are also the same, it returns 0.",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Arrays of Objects</span>"
    ]
  },
  {
    "objectID": "ch12.html#cards-are-immutable",
    "href": "ch12.html#cards-are-immutable",
    "title": "12  Arrays of Objects",
    "section": "12.5 Cards Are Immutable",
    "text": "12.5 Cards Are Immutable\nThe instance variables of Card are private, so they can’t be accessed from other classes. We can provide getters to allow other classes to read the rank and suit values:\npublic int getRank() {\n    return this.rank;\n}\n\npublic int getSuit() {\n    return this.suit;\n}\nWhether or not to provide setters is a design decision. If we did, cards would be mutable, so you could transform one card into another. That is probably not a feature we want, and in general, mutable objects are more error-prone. So it might be better to make cards immutable. To do that, all we have to do is not provide any modifier methods (including setters).\nThat’s easy enough, but it is not foolproof, because a fool might come along later and add a modifier. We can prevent that possibility by declaring the instance variables final:\npublic class Card {\n    private final int rank;\n    private final int suit;\n\n    ...\n}\nYou can initialize these variables inside a constructor, but if someone writes a method that tries to modify them, they’ll get a compiler error. This kind of safeguard helps prevent future mistakes and hours of debugging.",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Arrays of Objects</span>"
    ]
  },
  {
    "objectID": "ch12.html#cardarray",
    "href": "ch12.html#cardarray",
    "title": "12  Arrays of Objects",
    "section": "12.6 Arrays of Cards",
    "text": "12.6 Arrays of Cards\nJust as you can create an array of String objects, you can create an array of Card objects. The following statement creates an array of 52 cards. Figure 12.2 shows the memory diagram for this array.\nCard[] cards = new Card[52];\n\n\n\n\n\n\n\nMemory diagram of an unpopulated Card array.\n\n\nAlthough we call it an “array of cards”, the array contains references to cards; it does not contain the Card objects themselves. Initially the references are all null.\nEven so, you can access the elements of the array in the usual way:\nif (cards[0] == null) {\n    System.out.println(\"No card yet!\");\n}\nBut if you try to access the instance variables of non-existent Card objects, you will get a NullPointerException:\nSystem.out.println(cards[0].rank);  // NullPointerException\nThat code won’t work until we put cards in the array. One way to populate the array is to write nested for loops:\nint index = 0;\nfor (int suit = 0; suit &lt;= 3; suit++) {\n    for (int rank = 1; rank &lt;= 13; rank++) {\n        cards[index] = new Card(rank, suit);\n        index++;\n    }\n}\nThe outer loop iterates suits from 0 to 3. For each suit, the inner loop iterates ranks from 1 to 13. Since the outer loop runs 4 times, and the inner loop runs 13 times for each suit, the body is executed 52 times.\nWe use a separate variable index to keep track of where in the array the next card should go. Figure 12.3 shows what the array looks like after the first two cards have been created.\n\n\n\n\n\n\n\nMemory diagram of a Card array with two cards.\n\n\nWhen you work with arrays, it is convenient to have a method that displays the contents. You have seen the pattern for traversing an array several times, so the following method should be familiar:\npublic static void printDeck(Card[] cards) {\n    for (Card card : cards) {\n        System.out.println(card);\n    }\n}\nSince cards has type Card[], pronounced “card array”, an element of cards has type Card. So println invokes the toString method in the Card class.\nThen again, we don’t have to write our own printDeck method. The Arrays class provides a toString method that invokes toString on the elements of an array and concatenates the results:\nSystem.out.println(Arrays.toString(cards))",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Arrays of Objects</span>"
    ]
  },
  {
    "objectID": "ch12.html#sequential-search",
    "href": "ch12.html#sequential-search",
    "title": "12  Arrays of Objects",
    "section": "12.7 Sequential Search",
    "text": "12.7 Sequential Search\nThe next method we’ll write is search, which takes an array of cards and a Card object as parameters. It returns the index where the Card appears in the array, or -1 if it doesn’t. This version of search uses the algorithm in Section 7.5, which is called sequential search:\npublic static int search(Card[] cards, Card target) {\n    for (int i = 0; i &lt; cards.length; i++) {\n        if (cards[i].equals(target)) {\n            return i;\n        }\n    }\n    return -1;\n}\nThe method returns as soon as it discovers the card, which means we don’t have to traverse the entire array if we find the target. If we get to the end of the loop, we know the card is not in the array.\nIf the cards in the array are not in order, there is no way to search faster than sequential search. We have to look at every card, because otherwise we can’t be certain the card we want is not there. But if the cards are in order, we can use better algorithms.\nSequential search is relatively inefficient, especially for large arrays. If you pay the price to keep the array sorted, finding elements becomes much easier.",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Arrays of Objects</span>"
    ]
  },
  {
    "objectID": "ch12.html#binary-search",
    "href": "ch12.html#binary-search",
    "title": "12  Arrays of Objects",
    "section": "12.8 Binary Search",
    "text": "12.8 Binary Search\nWhen you look for a word in a dictionary, you don’t search page by page from front to back. Since the words are in alphabetical order, you probably use a binary search algorithm:\n\nStart on a page near the middle of the dictionary.\nCompare a word on the page to the word you are looking for. If you find it, stop.\nIf the word on the page comes before the word you are looking for, flip to somewhere later in the dictionary and go to step 2.\nIf the word on the page comes after the word you are looking for, flip to somewhere earlier in the dictionary and go to step 2.\n\nThis algorithm is much faster than sequential search, because it rules out half of the remaining words each time you make a comparison. If at any point you find two adjacent words on the page, and your word comes between them, you can conclude that your word is not in the dictionary.\nGetting back to the array of cards, we can write a faster version of search if we know the cards are in order:\npublic static int binarySearch(Card[] cards, Card target) {\n    int low = 0;\n    int high = cards.length - 1;\n    while (low &lt;= high) {\n        int mid = (low + high) / 2;                 // step 1\n        int comp = cards[mid].compareTo(target);\n\n        if (comp == 0) {                            // step 2\n            return mid;\n        } else if (comp &lt; 0) {                      // step 3\n            low = mid + 1;\n        } else {                                    // step 4\n            high = mid - 1;\n        }\n    }\n    return -1;\n}\nFirst, we declare low and high variables to represent the range we are searching. Initially, we search the entire array, from 0 to cards.length - 1.\nInside the while loop, we repeat the four steps of binary search:\n\nChoose an index between low and high—call it mid—and compare the card at mid to the target.\nIf you found the target, return its index (which is mid).\nIf the card at mid is lower than the target, search the range from mid + 1 to high.\nIf the card at mid is higher than the target, search the range from low to mid - 1.\n\nIf low exceeds high, there are no cards in the range, so we terminate the loop and return -1.\nThis algorithm depends on only the compareTo method of the object, so we can use this code with any object type that provides compareTo.",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Arrays of Objects</span>"
    ]
  },
  {
    "objectID": "ch12.html#tracing-the-code",
    "href": "ch12.html#tracing-the-code",
    "title": "12  Arrays of Objects",
    "section": "12.9 Tracing the Code",
    "text": "12.9 Tracing the Code\nTo see how binary search works, it’s helpful to add the following print statement at the beginning of the loop:\nSystem.out.println(low + \", \" + high);\nUsing a sorted deck of cards, we can search for the Jack of Clubs like this:\nCard card = new Card(11, 0);\nSystem.out.println(binarySearch(cards, card));\nWe expect to find this card at position 10 (since the Ace of Clubs is at position 0). Here is the output of binarySearch:\n0, 51\n0, 24\n0, 11\n6, 11\n9, 11\n10\nYou can see the range of cards shrinking as the while loop runs, until eventually index 10 is found. If we search for a card that’s not in the array—like new Card(15, 1), or the 15 of Diamonds—we get the following:\n0, 51\n26, 51\n26, 37\n26, 30\n26, 27\n-1\nEach time through the loop, we cut the distance between low and high in half. After \\(k\\) iterations, the number of remaining cards is \\(52 / 2^k\\). To find the number of iterations it takes to complete, we set \\(52 / 2^k = 1\\) and solve for \\(k\\). The result is \\(\\log_2 52\\), which is about 5.7. So we might have to look at 5 or 6 cards, as opposed to all 52 if we did a sequential search.\nMore generally, if the array contains \\(n\\) elements, binary search requires \\(\\log_2 n\\) comparisons, and sequential search requires \\(n\\). For large values of \\(n\\), binary search is substantially faster.",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Arrays of Objects</span>"
    ]
  },
  {
    "objectID": "ch12.html#vocabulary",
    "href": "ch12.html#vocabulary",
    "title": "12  Arrays of Objects",
    "section": "12.10 Vocabulary",
    "text": "12.10 Vocabulary\n\nencode:\n\nTo represent one set of values using another set of values by constructing a mapping between them.\n\nclass variable:\n\nA variable declared within a class as static. There is only one copy of a class variable, no matter how many objects there are.\n\nsequential search:\n\nAn algorithm that searches array elements, one by one, until a target value is found.\n\nbinary search:\n\nAn algorithm that searches a sorted array by starting in the middle, comparing an element to the target, and eliminating half of the remaining elements.",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Arrays of Objects</span>"
    ]
  },
  {
    "objectID": "ch12.html#exercises",
    "href": "ch12.html#exercises",
    "title": "12  Arrays of Objects",
    "section": "12.11 Exercises",
    "text": "12.11 Exercises\nThe code for this chapter is in the ch12 directory of ThinkJavaCode2. See page  for instructions on how to download the repository. Before you start the exercises, we recommend that you compile and run the examples.\n\nExercise 12.1. Encapsulate the deck-building code from Section 12.6 in a method called makeDeck that takes no parameters and returns a fully populated array of Cards.\n\n\nExercise 12.2. In some card games, Aces are ranked higher than Kings. Modify the compareTo method to implement this ordering.\n\n\nExercise 12.3. In Poker a “flush” is a hand that contains five or more cards of the same suit. A hand can contain any number of cards.\n\nWrite a method called suitHist that takes an array of cards as a parameter and returns a histogram of the suits in the hand. Your solution should traverse the array only once, as in Section 7.7.\nWrite a method called hasFlush that takes an array of cards as a parameter and returns true if the hand contains a flush (and false otherwise).\nA “royal flush” includes the Ace, King, Queen, Jack, and 10 (all in the same suit). Write a method called hasRoyal that determines whether an array of cards contains a royal flush.\n\n\n\nExercise 12.4. Working with cards is more fun if you can display them on the screen. If you have not already read Appendix 20 about 2D graphics, you should read it before working on this exercise. In the code directory for this chapter, ch12, you will find the following:\n\n**cardset-oxymoron\nA directory containing images of playing cards.\n**CardTable.java\nA sample program that demonstrates how to read and display images.\n\n**CardTable.java* demonstrates the use of a 2D array; specifically, an array of card images. The declaration looks like this:*\nprivate Image[][] images;\nThe variable images refers to a 2D array of Image objects, which are defined in the java.awt package. Here’s the code that creates the array itself:\nimages = new Image[14][4];\nThe array has 14 rows (one for each rank, plus an unused row for rank 0) and 4 columns (one for each suit). Here’s the loop that populates the array:\nString cardset = \"cardset-oxymoron\";\nString suits = \"cdhs\";\n\nfor (int suit = 0; suit &lt;= 3; suit++) {\n    char c = suits.charAt(suit);\n\n    for (int rank = 1; rank &lt;= 13; rank++) {\n        String s = String.format(\"%s/%02d%c.gif\",\n                                 cardset, rank, c);\n        images[rank][suit] = new ImageIcon(s).getImage();\n    }\n}\nThe variable cardset is the name of the directory that contains the image files. suits is a string that contains the single-letter abbreviations for the suits. These strings are used to assemble s, which contains the filename for each image. For example, when rank=1 and suit=2, the value of s is \"cardset-oxymoron/01h.gif\", which is an image of the Ace of Hearts.\nThe last line of the loop reads the image file, extracts an Image object, and assigns it to a location in the array, as specified by the indexes rank and suit. For example, the image of the Ace of Hearts is stored in row 1, column 2.\nIf you compile and run CardTable.java, you should see images of a deck of cards laid out on a green table. You can use this class as a starting place to implement your own card games.\nAs a starting place, try placing cards on the table in the starting configuration for the solitaire game Klondike (https://en.wikipedia.org/wiki/Klondike_(solitaire)).\nYou can get the image for the back of the card by reading the file back192.gif.",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Arrays of Objects</span>"
    ]
  },
  {
    "objectID": "ch13.html",
    "href": "ch13.html",
    "title": "13  Objects of Arrays",
    "section": "",
    "text": "13.1 Decks of Cards\nHere is the beginning of a Deck class that encapsulates an array of Card objects:\nThe constructor initializes the instance variable with an array of n cards, but it doesn’t create any Card objects. Figure 13.1 shows what a Deck looks like with no cards.\nWe’ll add another constructor that creates a standard 52-card array and populates it with Card objects:\nThis method is similar to the example in Section 12.6; we just turned it into a constructor. We can use it to create a complete Deck like this:\nNow that we have a Deck class, we have a logical place to put methods that pertain to decks. Looking at the methods we have written so far, one obvious candidate is printDeck from Section 12.6. Here’s how it looks, rewritten as an instance method of Deck:\nNotice that when we transform a static method into an instance method, the code is shorter. Here’s how we invoke it:",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Objects of Arrays</span>"
    ]
  },
  {
    "objectID": "ch13.html#deck",
    "href": "ch13.html#deck",
    "title": "13  Objects of Arrays",
    "section": "",
    "text": "public class Deck {\n    private Card[] cards;\n\n    public Deck(int n) {\n        this.cards = new Card[n];\n    }\n\n    public Card[] getCards() {\n        return this.cards;\n    }\n}\n\n\n\n\n\n\n\n\nMemory diagram of an unpopulated Deck object.\n\n\n\npublic Deck() {\n    this.cards = new Card[52];\n    int index = 0;\n    for (int suit = 0; suit &lt;= 3; suit++) {\n        for (int rank = 1; rank &lt;= 13; rank++) {\n            this.cards[index] = new Card(rank, suit);\n            index++;\n        }\n    }\n}\n\nDeck deck = new Deck();\n\npublic void print() {\n    for (Card card : this.cards) {\n        System.out.println(card);\n    }\n}\n\ndeck.print();",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Objects of Arrays</span>"
    ]
  },
  {
    "objectID": "ch13.html#shuffle",
    "href": "ch13.html#shuffle",
    "title": "13  Objects of Arrays",
    "section": "13.2 Shuffling Decks",
    "text": "13.2 Shuffling Decks\nFor most card games, you have to shuffle the deck; that is, put the cards in a random order. In Section 7.6 you saw how to generate random numbers, but it is not obvious how to use them to shuffle a deck.\nOne possibility is to model the way humans shuffle; for example, we could divide the deck in two halves and then choose alternately from each one. Humans usually don’t shuffle perfectly, so after about seven iterations, the order of the deck is pretty well randomized.\nBut a computer program would have the annoying property of doing a perfect shuffle every time, which is not very random. In fact, after eight perfect shuffles, you would find the deck back in the order you started in! For more on this, see https://en.wikipedia.org/wiki/Faro_shuffle.\nA better shuffling algorithm is to traverse the deck one card at a time, and at each iteration, choose two cards and swap them. To outline this algorithm, we’ll use a combination of Java statements and English comments. This technique is sometimes called pseudocode:\npublic void shuffle() {\n    for each index i {\n        // choose a random number between i and length - 1\n        // swap the ith card and the randomly-chosen card\n    }\n}\nThe nice thing about pseudocode is that it often makes clear what other methods you are going to need. In this case, we need a method that chooses a random integer in a given range and a method that takes two indexes and swaps the cards at those positions:\nprivate static int randomInt(int low, int high) {\n    // return a random number between low and high,\n    // including both\n}\n\nprivate void swapCards(int i, int j) {\n    // swap the ith and the jth cards in the array\n}\nMethods like randomInt and swapCards are called helper methods, because they help you solve parts of the problem. Helper methods are often private, because they are used only by methods in the class and are not needed by methods in other classes.\nThe process of writing pseudocode first and then writing helper methods to make it work is a kind of top-down design (see https://en.wikipedia.org/wiki/Top-down_and_bottom-up_design). It is an alternative to “incremental development” and “encapsulation and generalization”, the other design processes you have seen in this book.\nOne of the exercises at the end of the chapter asks you to write the helper methods randomInt and swapCards, and use them to implement shuffle.\nWhen you do the exercise, notice that randomInt is a class method and swapCards is an instance method. Do you understand why?",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Objects of Arrays</span>"
    ]
  },
  {
    "objectID": "ch13.html#sorting",
    "href": "ch13.html#sorting",
    "title": "13  Objects of Arrays",
    "section": "13.3 Selection Sort",
    "text": "13.3 Selection Sort\nNow that we have shuffled the deck, we need a way to put it back in order. There is an algorithm for sorting that is ironically similar to the algorithm for shuffling. It’s called selection sort, because it works by traversing the array repeatedly and selecting the lowest (or highest) remaining card each time.\nDuring the first iteration, we find the lowest card and swap it with the card in the zeroth position. During the \\(i\\)th iteration, we find the lowest card to the right of \\(i\\) and swap it with the \\(i\\)th card. Here is pseudocode for selection sort:\npublic void selectionSort() {\n    for each index i {\n        // find the lowest card at or to the right of i\n        // swap the ith card and the lowest card found\n    }\n}\nAgain, the pseudocode helps with the design of the helper methods. For this algorithm, we can reuse swapCards from the previous section, so we need only a method to find the lowest card; we’ll call it indexLowest:\nprivate int indexLowest(int low, int high) {\n    // find the lowest card between low and high\n}\nOne of the exercises at the end of the chapter asks you to write indexLowest, and then use it and swapCards to implement selectionSort.",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Objects of Arrays</span>"
    ]
  },
  {
    "objectID": "ch13.html#mergesort",
    "href": "ch13.html#mergesort",
    "title": "13  Objects of Arrays",
    "section": "13.4 Merge Sort",
    "text": "13.4 Merge Sort\nSelection sort is a simple algorithm, but it is not very efficient. To sort \\(n\\) items, it has to traverse the array \\(n-1\\) times. Each traversal takes an amount of time proportional to \\(n\\). The total time, therefore, is proportional to \\(n^2\\).\nWe will develop a more efficient algorithm called merge sort. To sort \\(n\\) items, merge sort takes time proportional to \\(n \\log_2 n\\). That may not seem impressive, but as \\(n\\) gets big, the difference between \\(n^2\\) and \\(n \\log_2 n\\) can be enormous.\nFor example, \\(\\log_2\\) of one million is around 20. So if you had to sort a million numbers, merge sort would require 20 million steps. But selection sort would require one trillion steps!\nThe idea behind merge sort is this: if you have two decks, each of which has already been sorted, you can quickly merge them into a single, sorted deck. Try this out with a deck of cards:\n\nForm two decks with about 10 cards each, and sort them so they are face up with the lowest cards on top. Place the decks in front of you.\nCompare the top card from each deck and choose the lower one. Flip it over and add it to the merged deck.\nRepeat step 2 until one of the decks is empty. Then take the remaining cards and add them to the merged deck.\n\nThe result should be a single sorted deck. In the next few sections, we’ll explain how to implement this algorithm in Java.",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Objects of Arrays</span>"
    ]
  },
  {
    "objectID": "ch13.html#subdecks",
    "href": "ch13.html#subdecks",
    "title": "13  Objects of Arrays",
    "section": "13.5 Subdecks",
    "text": "13.5 Subdecks\n\nThe first step of merge sort is to split the deck into two “subdecks”, each with about half of the cards. So we need a method that takes a deck, and a range of indexes, and returns a new deck that contains the specified subset of cards:\npublic Deck subdeck(int low, int high) {\n    Deck sub = new Deck(high - low + 1);\n    for (int i = 0; i &lt; sub.cards.length; i++) {\n        sub.cards[i] = this.cards[low + i];\n    }\n    return sub;\n}\nThe first line creates an unpopulated Deck object that contains an array of null references. Inside the for loop, the subdeck gets populated with references to Card objects.\nThe length of the subdeck is high - low + 1, because both the low card and the high card are included. This sort of computation can be confusing, and forgetting the “+ 1” often leads to off-by-one errors. Drawing a picture is usually the best way to avoid them.\nFigure 13.2 is a memory diagram of a subdeck with low = 0 and high = 4. The result is a hand with five cards that are shared with the original deck; that is, they are aliased.\n\n\n\n\n\n\n\nMemory diagram showing the effect of subdeck.\n\n\nAliasing might not be a good idea, because changes to shared cards would be reflected in multiple decks. But since Card objects are immutable, this kind of aliasing is not a problem. And it saves some memory because we don’t create duplicate Card objects.",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Objects of Arrays</span>"
    ]
  },
  {
    "objectID": "ch13.html#merging-decks",
    "href": "ch13.html#merging-decks",
    "title": "13  Objects of Arrays",
    "section": "13.6 Merging Decks",
    "text": "13.6 Merging Decks\nThe next helper method we need is merge, which takes two sorted subdecks and returns a new deck containing all cards from both decks, in order. Here’s what the algorithm looks like in pseudocode, assuming the subdecks are named d1 and d2:\nprivate static Deck merge(Deck d1, Deck d2) {\n    // create a new deck, d3, big enough for all the cards\n\n    // use the index i to keep track of where we are at in\n    // the first deck, and the index j for the second deck\n    int i = 0;\n    int j = 0;\n\n    // the index k traverses the result deck\n    for (int k = 0; k &lt; d3.length; k++) {\n        // if d1 is empty, use top card from d2\n        // if d2 is empty, use top card from d1\n        // otherwise, compare the top two cards\n\n        // add lowest card to the new deck at k\n        // increment i or j (depending on card)\n    }\n    // return the new deck\n}\nAn exercise at the end of the chapter asks you to implement merge. It’s a little tricky, so be sure to test it with different subdecks. Once your merge method is working, you can use it to write a simplified version of merge sort:\npublic Deck almostMergeSort() {\n    // divide the deck into two subdecks\n    // sort the subdecks using selectionSort\n    // merge the subdecks, return the result\n}\nIf you have working versions of subdeck, selectionSort, and merge, you should have no trouble getting this method working. But it is still not very efficient, because it uses selectionSort to sort the subdecks. We can make it more efficient if we use mergeSort instead, but that means we have to make it recursive!",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Objects of Arrays</span>"
    ]
  },
  {
    "objectID": "ch13.html#adding-recursion",
    "href": "ch13.html#adding-recursion",
    "title": "13  Objects of Arrays",
    "section": "13.7 Adding Recursion",
    "text": "13.7 Adding Recursion\nTo make mergeSort work recursively, you have to add a base case; otherwise, it repeats forever. The simplest base case is a subdeck with one card. If there is only one card, it can’t be out of order, so we consider it sorted. And if it is already sorted, we can just return it.\nAnd it will turn out to be convenient if we handle another base case, a subdeck with zero cards. By the same logic, if there are no cards, they can’t be out of order. So we consider an empty deck to be sorted, and return it.\nWith these base cases, a recursive version of mergeSort looks like this:\npublic Deck mergeSort() {\n    // if the deck has 0 or 1 cards, return it\n    // otherwise, divide the deck into two subdecks\n    // sort the subdecks using mergeSort\n    // merge the subdecks\n    // return the result\n}\nAs usual, there are two ways to think about recursive programs: you can follow the flow of execution, or you can make the “leap of faith” (see Section 8.4). This example should encourage you to make the leap of faith.\nWhen you use selectionSort to sort the subdecks, you don’t feel compelled to follow the flow of execution. You assume it works because you already debugged it. When you make mergeSort recursive, you just replace one sorting algorithm with another. There is no reason to read the program differently.\nWell, almost. You have to think about the base cases and make sure that you reach them. But other than that, writing the recursive version should be no problem. As an exercise at the end of this chapter, you’ll have a chance to finish off this example.",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Objects of Arrays</span>"
    ]
  },
  {
    "objectID": "ch13.html#static-context",
    "href": "ch13.html#static-context",
    "title": "13  Objects of Arrays",
    "section": "13.8 Static Context",
    "text": "13.8 Static Context\nFigure 13.3 shows a UML class diagram for Deck, including the instance variable, cards, and the methods we have so far. In UML diagrams, private attributes and methods begin with a minus sign (-) and static methods are underlined.\n\n\n\n\n\n\n\nUML diagram for the Deck class.\n\n\nThe helper methods randomInt and merge are static, because they do not read or write any instance variables. All other methods are instance methods, because they access the instance variable, cards.\nWhen you have static methods and instance methods in the same class, it is easy to get them confused.\nTo invoke an instance method, you need an instance:\nDeck deck = new Deck();\ndeck.print();  // correct\nDeck with a capital D is a class, and deck with a lowercase d is an object.\nSay you try to invoke print like this:\nDeck.print();  // wrong!\nYou get a compiler error like this:\nNon-static method print() cannot be referenced from a\nstatic context.\nBy “static context”, the compiler means you are trying to invoke a method in a context that requires a static method.\nOn the other hand, if you have a Deck object, you can use it to invoke a static method:\nDeck deck = new Deck();\nint i = deck.randomInt(0, 51);  // legal, but not good style\nThis is legal, but it is not considered good style, because someone reading this code would expect randomInt to be an instance method.\nAnother common error is to use this in a static method. For example, say you write something like this:\nprivate static Deck merge(Deck d1, Deck d2) {\n    return this.cards;  // wrong!\n}\nYou get a compiler error like this:\nNon-static variable this cannot be referenced from a\nstatic context.\nThe problem is that cards is an instance variable, so it is non-static; therefore, you can’t access it from a static method. In general, you can’t use this in a static method, because a static method is not invoked on an object.\nFor beginners, error messages about non-static context can be confusing and frustrating. We hope this section helps.",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Objects of Arrays</span>"
    ]
  },
  {
    "objectID": "ch13.html#piles-of-cards",
    "href": "ch13.html#piles-of-cards",
    "title": "13  Objects of Arrays",
    "section": "13.9 Piles of Cards",
    "text": "13.9 Piles of Cards\nNow that we have classes that represent cards and decks, let’s use them to make a game. One of the simplest card games that children play is called “War” (see https://en.wikipedia.org/wiki/War_(card_game)).\nInitially, the deck is divided evenly into two piles, one for each player. During each round, each player takes the top card from their pile and places it, face up, in the center. Whoever has the highest-ranking card, ignoring suit, takes the two cards and adds them to the bottom of their pile. The game continues until one player has won the entire deck.\nWe could use the Deck class to represent the individual piles. However, our implementation of Deck uses a Card array, and the length of an array can’t change. As the game progresses, we need to be able to add and remove cards from the piles.\nWe can solve this problem with an ArrayList, which is in the java.util package. An ArrayList is a collection, which is an object that contains other objects. It provides methods to add and remove elements, and it grows and shrinks automatically.\nWe define a new class named Pile to represent a pile of cards. It uses an ArrayList to store Card objects:\npublic class Pile {\n    private ArrayList&lt;Card&gt; cards;\n\n    public Pile() {\n        this.cards = new ArrayList&lt;Card&gt;();\n    }\n}\nWhen you declare an ArrayList, you specify the type it contains in angle brackets (&lt;&gt;). This declaration says that cards is not just an ArrayList; it’s an ArrayList of Card objects. The constructor initializes this.cards with an empty ArrayList.\nNow let’s think about the methods we need to play the game. At the beginning of each round, each player draws a card from the top of their pile. So we define a method to do that:\npublic Card popCard() {\n    return this.cards.remove(0);  // from the top of the pile\n}\npopCard removes the Card at the beginning of the ArrayList, which we think of as the top of the pile. Because we use ArrayList.remove, it automatically shifts the remaining cards to fill the gap.\nAt the end of each round, the winner adds cards to the bottom of their pile. So we define a method to do that:\npublic void addCard(Card card) {\n    this.cards.add(card);        // to the bottom of the pile\n}\nArrayList provides a method, add, that adds an element to the end of the collection, which we think of as the bottom of the pile.\nTo know when to stop the game, we have to check if one of the piles is empty. Here’s a method to do that:\npublic boolean isEmpty() {\n    return this.cards.isEmpty();\n}\nSo far, these methods don’t do very much; they just invoke methods on the instance variable, cards. Methods like these are called wrapper methods because they wrap one method with another.\nFinally, to start the game, we need to divide the deck into two equal parts. We can do that with subdeck from Section [subdeck] and a new method, addDeck:\npublic void addDeck(Deck deck) {\n    for (Card card : deck.getCards()) {\n        this.cards.add(card);\n    }\n}\naddDeck takes a Deck object, loops through the cards, and adds them to the Pile. Notice that it does not remove the cards from the Deck, so the Deck and the Pile share cards. But that won’t be a problem because cards are immutable.",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Objects of Arrays</span>"
    ]
  },
  {
    "objectID": "ch13.html#playing-war",
    "href": "ch13.html#playing-war",
    "title": "13  Objects of Arrays",
    "section": "13.10 Playing War",
    "text": "13.10 Playing War\nNow we can use Deck and Pile to implement the game. We’ll start by creating a deck and shuffling:\nDeck deck = new Deck();\ndeck.shuffle();\nThen we divide the Deck into two piles:\nPile p1 = new Pile();\np1.addDeck(deck.subdeck(0, 25));\n\nPile p2 = new Pile();\np2.addDeck(deck.subdeck(26, 51));\nThe game itself is a loop that repeats until one of the piles is empty. At each iteration, we draw a card from each pile and compare their ranks:\nwhile (!p1.isEmpty() && !p2.isEmpty()) {\n    // pop a card from each pile\n    Card c1 = p1.popCard();\n    Card c2 = p2.popCard();\n\n    // compare the cards\n    int diff = c1.getRank() - c2.getRank();\n    if (diff &gt; 0) {\n        p1.addCard(c1);\n        p1.addCard(c2);\n    } else if (diff &lt; 0) {\n        p2.addCard(c1);\n        p2.addCard(c2);\n    } else {\n        // it's a tie\n    }\nIf the two cards have the same rank, it’s a tie. In that case, each player draws four more cards. Whoever has the higher fourth card takes all cards in play. If there’s another tie, they draw another four cards, and so on.\nOne of the exercises at the end of this chapter asks you to implement the else block when there’s a tie.\nAfter the while loop ends, we display the winner based on which pile is not empty:\nif (p2.isEmpty()) {\n    System.out.println(\"Player 1 wins!\");\n} else {\n    System.out.println(\"Player 2 wins!\");\n}\nArrayList provides many other methods that we didn’t use for this example. Take a minute to read the documentation, which you can find by doing a web search for “Java ArrayList”.",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Objects of Arrays</span>"
    ]
  },
  {
    "objectID": "ch13.html#vocabulary",
    "href": "ch13.html#vocabulary",
    "title": "13  Objects of Arrays",
    "section": "13.11 Vocabulary",
    "text": "13.11 Vocabulary\n\npseudocode:\n\nA way of designing programs by writing rough drafts in a combination of English and Java.\n\nhelper method:\n\nA method that implements part of a more complex algorithm; often it is not particularly useful on its own.\n\ntop-down design:\n\nBreaking down a problem into subproblems, and solving each subproblem one at a time.\n\nselection sort:\n\nA simple sorting algorithm that searches for the smallest or largest element \\(n\\) times.\n\nmerge sort:\n\nA recursive sorting algorithm that divides an array into two parts, sorts each part (using merge sort), and merges the results.\n\noff-by-one:\n\nA common programming mistake that results in iterating one time too many, or too few.\n\nstatic context:\n\nThe parts of a class that run without reference to a specific instance of the class.\n\ncollection:\n\nA Java library class, like ArrayList, that represents a group of objects.\n\nwrapper method:\n\nA method that calls another method without doing much additional work.",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Objects of Arrays</span>"
    ]
  },
  {
    "objectID": "ch13.html#exercises",
    "href": "ch13.html#exercises",
    "title": "13  Objects of Arrays",
    "section": "13.12 Exercises",
    "text": "13.12 Exercises\nThe code for this chapter is in the ch13 directory of ThinkJavaCode2. See page  for instructions on how to download the repository. Before you start the exercises, we recommend that you compile and run the examples.\n\nExercise 13.1. Write a toString method for the Deck class. It should return a single string that represents the cards in the deck. When it’s printed, this string should display the same results as the print method in Section 13.1.\n**Hint:* You can use the + operator to concatenate strings, but that is not very efficient. Consider using StringBuilder instead; see Section 10.11.*\n\n\nExercise 13.2.\nThe goal of this exercise is to implement the shuffling algorithm from this chapter.\n\nIn the repository for this book, you should find the file named Deck.java. Check that you can compile it in your environment.\nImplement the randomInt method. You can use the nextInt method provided by java.util.Random, which you saw in Section 7.6.\n**Hint:* To avoid creating a Random object every time randomInt is invoked, consider defining a class variable.*\nWrite a swapCards method that takes two indexes and swaps the cards at the given locations.\nFill in the shuffle method by using the algorithm in Section 13.2.\n\n\n\nExercise 13.3. The goal of this exercise is to implement the sorting algorithms from this chapter. Use the Deck.java* file from the previous exercise or create a new one from scratch.*\n\nImplement the indexLowest method. Use the Card.compareTo method to find the lowest card in a given range of the deck, from lowIndex to highIndex, including both.\nFill in selectionSort by using the algorithm in Section 13.3.\nUsing the pseudocode in Section 13.4, implement the merge method. The best way to test it is to build and shuffle a deck. Then use subdeck to form two small subdecks, and use selection sort to sort them. Finally, pass the two halves to merge and see if it works.\nFill in almostMergeSort, which divides the deck in half, then uses selectionSort to sort the two halves, and uses merge to create a new, sorted deck. You should be able to reuse code from the previous step.\nImplement mergeSort recursively. Remember that selectionSort is void and mergeSort returns a new Deck, which means that they get invoked differently:\ndeck.selectionSort();      // modifies an existing deck\ndeck = deck.mergeSort();   // replaces old deck with new\n\n\n\nExercise 13.4. You can learn more about the sorting algorithms presented in this chapter at https://www.toptal.com/developers/sorting-algorithms. This site provides explanations of the algorithms, along with animations that show how they work. It also includes an analysis of their efficiency.\nFor example, “insertion sort” is an algorithm that inserts elements into place, one at a time. Read about it on the website and play the animations. Then write a method named insertionSort that implements this algorithm.\nOne goal of this exercise is to practice top-down design. Your solution should use a helper method, named insert, that implements the inner loop of the algorithm. insertionSort should invoke this method \\(n-1\\) times.\n\n\nExercise 13.5. Find and open the file War.java* in the repository. The main method contains all the code from the last section of this chapter. Check that you can compile and run this code before proceeding.*\nThe program is incomplete; it does not handle the case when two cards have the same rank. Finish implementing the main method, beginning at the line that says: // it's a tie.\nWhen there’s a tie, draw three cards from each pile and store them in a collection, along with the original two. Then draw one more card from each pile and compare them. Whoever wins the tie takes all ten of these cards.\nIf one pile does not have at least four cards, the game ends immediately. If a tie ends with a tie, draw three more cards, and so on.\nNotice that this program depends on Deck.shuffle, so you might have to do Exercise 13.2 first.",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Objects of Arrays</span>"
    ]
  },
  {
    "objectID": "ch14.html",
    "href": "ch14.html",
    "title": "14  Extending Classes",
    "section": "",
    "text": "14.1 CardCollection\nTo implement Crazy Eights, we need to represent a deck of cards, a discard pile, a draw pile, and a hand for each player. And we need to be able to deal, draw, and discard cards.\nThe Deck and Pile classes from the previous chapter meet some of these requirements. But unless we make some changes, neither of them represents a hand of cards very well.\nFurthermore, Deck and Pile are essentially two versions of the same code: one based on arrays, and the other based on ArrayList. It would be helpful to combine their features into one class that meets the needs of both.\nWe will define a class named CardCollection and add the code we want one step at a time. Since this class will represent different piles and hands of cards, we’ll add a label attribute to tell them apart:\nAs with the Pile class, we need a way to add cards to the collection. Here is the addCard method from the previous chapter:\nUntil now, we have used this explicitly to make it easy to identify attributes. Inside addCard and other instance methods, you can access instance variables without using the keyword this. So from here on, we will drop it:\nWe also need to be able to remove cards from the collection. The following method takes an index, removes the card at that location, and shifts the following cards left to fill the gap:\nIf we are dealing cards from a shuffled deck, we don’t care which card gets removed. It is most efficient to choose the last one, so we don’t have to shift any cards left. Here is an overloaded version of popCard that removes and returns the last card:\nCardCollection also provides isEmpty, which returns true if there are no cards left, and size, which returns the number of cards:\nTo access the elements of an ArrayList, you can’t use the array [] operator. Instead, you have to use the methods get and set. Here is a wrapper for get:\nlastCard gets the last card (but doesn’t remove it):\nIn order to control the ways card collections are modified, we don’t provide a wrapper for set. The only modifiers we provide are the two versions of popCard and the following version of swapCards:\nFinally, we use swapCards to implement shuffle, which we described in Section 13.2:",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Extending Classes</span>"
    ]
  },
  {
    "objectID": "ch14.html#cardcollection",
    "href": "ch14.html#cardcollection",
    "title": "14  Extending Classes",
    "section": "",
    "text": "public class CardCollection {\n\n    private String label;\n    private ArrayList&lt;Card&gt; cards;\n\n    public CardCollection(String label) {\n        this.label = label;\n        this.cards = new ArrayList&lt;Card&gt;();\n    }\n}\n\npublic void addCard(Card card) {\n    this.cards.add(card);\n}\n\npublic void addCard(Card card) {\n    cards.add(card);\n}\n\npublic Card popCard(int i) {\n    return cards.remove(i);\n}\n\npublic Card popCard() {\n    int i = cards.size() - 1;    // from the end of the list\n    return popCard(i);\n}\n\npublic boolean isEmpty() {\n    return cards.isEmpty();\n}\npublic int size() {\n    return cards.size();\n}\n\npublic Card getCard(int i) {\n    return cards.get(i);\n}\n\npublic Card lastCard() {\n    int i = cards.size() - 1;\n    return cards.get(i);\n}\n\npublic void swapCards(int i, int j) {\n    Card temp = cards.get(i);\n    cards.set(i, cards.get(j));\n    cards.set(j, temp);\n}\n\npublic void shuffle() {\n    Random random = new Random();\n    for (int i = cards.size() - 1; i &gt; 0; i--) {\n        int j = random.nextInt(i + 1);\n        swapCards(i, j);\n    }\n}",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Extending Classes</span>"
    ]
  },
  {
    "objectID": "ch14.html#inheritance",
    "href": "ch14.html#inheritance",
    "title": "14  Extending Classes",
    "section": "14.2 Inheritance",
    "text": "14.2 Inheritance\nAt this point, we have a class that represents a collection of cards. It provides functionality common to decks of cards, piles of cards, hands of cards, and potentially other collections.\nHowever, each kind of collection will be slightly different. Rather than add every possible feature to CardCollection, we can use inheritance to define subclasses. A subclass is a class that “extends” an existing class; that is, it has the attributes and methods of the existing class, plus more.\nHere is the complete definition of our new and improved Deck class:\npublic class Deck extends CardCollection {\n\n    public Deck(String label) {\n        super(label);\n        for (int suit = 0; suit &lt;= 3; suit++) {\n            for (int rank = 1; rank &lt;= 13; rank++) {\n                addCard(new Card(rank, suit));\n            }\n        }\n    }\n}\nThe first line uses the keyword extends to indicate that Deck extends the class CardCollection. That means a Deck object has the same instance variables and methods as a CardCollection. Another way to say the same thing is that Deck “inherits from” CardCollection. We could also say that CardCollection is a superclass, and Deck is one of its subclasses.\nIn Java, classes may extend only one superclass. Classes that do not specify a superclass with extends automatically inherit from java.lang.Object. So in this example, Deck extends CardCollection, which in turn extends Object. The Object class provides the default equals and toString methods, among other things.\nConstructors are not inherited, but all other public attributes and methods are. The only additional method in Deck, at least for now, is a constructor. So you can create a Deck object like this:\nDeck deck = new Deck(\"Deck\");\nThe first line of the constructor uses super, which is a keyword that refers to the superclass of the current class. When super is used as a method, as in this example, it invokes the constructor of the superclass.\nSo in this case, super invokes the CardCollection constructor, which initializes the attributes label and cards. When it returns, the Deck constructor resumes and populates the (empty) ArrayList with Card objects.\nThat’s it for the Deck class. Next we need a way to represent a hand, which is the collection of cards held by a player, and a pile, which is a collection of cards on the table. We could define two classes, one for hands and one for piles, but there is not much difference between them. So we’ll use one class, called Hand, for both hands and piles. Here’s what the definition looks like:\npublic class Hand extends CardCollection {\n\n    public Hand(String label) {\n        super(label);\n    }\n\n    public void display() {\n        System.out.println(getLabel() + \": \");\n        for (int i = 0; i &lt; size(); i++) {\n            System.out.println(getCard(i));\n        }\n        System.out.println();\n    }\n}\nLike Deck, the Hand class extends CardCollection. So it inherits methods like getLabel, size, and getCard, which are used in display. Hand also provides a constructor, which invokes the constructor of CardCollection.\nIn summary, a Deck is just like a CardCollection, but it provides a different constructor. And a Hand is just like a CardCollection, but it provides an additional method, display.",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Extending Classes</span>"
    ]
  },
  {
    "objectID": "ch14.html#dealing",
    "href": "ch14.html#dealing",
    "title": "14  Extending Classes",
    "section": "14.3 Dealing Cards",
    "text": "14.3 Dealing Cards\nTo begin the game, we need to deal cards to each of the players. And during the game, we need to move cards between hands and piles. If we add the following method to CardCollection, it can meet both of these requirements:\npublic void deal(CardCollection that, int n) {\n    for (int i = 0; i &lt; n; i++) {\n        Card card = popCard();\n        that.addCard(card);\n    }\n}\nThe deal method removes cards from the collection it is invoked on, this, and adds them to the collection it gets as a parameter, that. The second parameter, n, is the number of cards to deal. We will use this method to implement dealAll, which deals (or moves) all of the remaining cards:\npublic void dealAll(CardCollection that) {\n    int n = cards.size();\n    deal(that, n);\n}\nAt this point, we can create a Deck and start dealing cards. Here’s a simple example that deals five cards to a hand, and deals the rest into a draw pile:\nDeck deck = new Deck(\"Deck\");\ndeck.shuffle();\n\nHand hand = new Hand(\"Hand\");\ndeck.deal(hand, 5);\nhand.display();\n\nHand drawPile = new Hand(\"Draw Pile\");\ndeck.dealAll(drawPile);\nSystem.out.printf(\"Draw Pile has %d cards.\\n\",\n                  drawPile.size());\nBecause the deck is shuffled randomly, you should get a different hand each time you run this example. The output will look something like this:\nHand:\n5 of Diamonds\nAce of Hearts\n6 of Clubs\n6 of Diamonds\n2 of Clubs\n\nDraw Pile has 47 cards.\nIf you are a careful reader, you might notice something strange about this example. Take another look at the definition of deal. Notice that the first parameter is supposed to be a CardCollection. But we invoked it like this:\nHand hand = new Hand(\"Hand\");\ndeck.deal(hand, 5);\nThe argument is a Hand, not a CardCollection. So why is this example legal?\nIt’s because Hand is a subclass of CardCollection, so a Hand object is also considered to be a CardCollection object. If a method expects a CardCollection, you can give it a Hand, a Deck, or a CardCollection.\nBut it doesn’t work the other way around: not every CardCollection is a Hand, so if a method expects a Hand, you have to give it a Hand, not a CardCollection or a Deck.\nIf it seems strange that an object can belong to more than one type, remember that this happens in real life too. Every cat is also a mammal, and every mammal is also an animal. But not every animal is a mammal, and not every mammal is a cat.",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Extending Classes</span>"
    ]
  },
  {
    "objectID": "ch14.html#the-player-class",
    "href": "ch14.html#the-player-class",
    "title": "14  Extending Classes",
    "section": "14.4 The Player Class",
    "text": "14.4 The Player Class\nThe Deck and Hand classes we have defined so far could be used for any card game; we have not yet implemented any of the rules specific to Crazy Eights. And that’s probably a good thing, since it makes it easy to reuse these classes if we want to make another game in the future.\nBut now it’s time to implement the rules. We’ll use two classes: Player, which encapsulates player strategy, and Eights, which creates and maintains the state of the game. Here is the beginning of the Player definition:\npublic class Player {\n\n    private String name;\n    private Hand hand;\n\n    public Player(String name) {\n        this.name = name;\n        this.hand = new Hand(name);\n    }\nA Player has two private attributes: a name and a hand. The constructor takes the player’s name as a string and saves it in an instance variable. In this example, we have to use this to distinguish between the instance variable and the parameter with the same name.\nThe primary method that Player provides is play, which decides which card to discard during each turn:\npublic Card play(Eights eights, Card prev) {\n    Card card = searchForMatch(prev);\n    if (card == null) {\n        card = drawForMatch(eights, prev);\n    }\n    return card;\n}\nThe first parameter is a reference to the Eights object that encapsulates the state of the game (coming up in the next section). The second parameter, prev, is the card on top of the discard pile.\nplay invokes two helper methods: searchForMatch and drawForMatch. Since we have not written them yet, this is an example of top-down design.\nHere’s searchForMatch, which looks in the player’s hand for a card that matches the previously played card:\npublic Card searchForMatch(Card prev) {\n    for (int i = 0; i &lt; hand.size(); i++) {\n        Card card = hand.getCard(i);\n        if (cardMatches(card, prev)) {\n            return hand.popCard(i);\n        }\n    }\n    return null;\n}\nThe strategy is pretty simple: the for loop searches for the first card that’s legal to play and returns it. If there are no cards that match, it returns null. In that case, we have to draw cards until we get a match, which is what drawForMatch does:\npublic Card drawForMatch(Eights eights, Card prev) {\n    while (true) {\n        Card card = eights.drawCard();\n        System.out.println(name + \" draws \" + card);\n        if (cardMatches(card, prev)) {\n            return card;\n        }\n        hand.addCard(card);\n    }\n}\nThe while loop runs until it finds a match (we’ll assume for now that it always finds one). The loop uses the Eights object to draw a card. If it matches, drawForMatch returns the card. Otherwise it adds the card to the player’s hand and repeats.\nBoth searchForMatch and drawForMatch use cardMatches, which is a static method, also defined in Player. This method is a straightforward translation of the rules of the game:\npublic static boolean cardMatches(Card card1, Card card2) {\n    return card1.getSuit() == card2.getSuit()\n        || card1.getRank() == card2.getRank()\n        || card1.getRank() == 8;\n}\nFinally, Player provides a score method, which computes penalty points for cards left in a player’s hand at the end of the game.",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Extending Classes</span>"
    ]
  },
  {
    "objectID": "ch14.html#the-eights-class",
    "href": "ch14.html#the-eights-class",
    "title": "14  Extending Classes",
    "section": "14.5 The Eights Class",
    "text": "14.5 The Eights Class\nIn Section 13.2, we introduced top-down design. In this way of developing programs, we identify high-level goals, like shuffling a deck, and break them into smaller problems, like choosing a random element or swapping two elements.\nIn this section, we present bottom-up design, which goes the other way around: first we identify simple pieces we need and then we assemble them into more-complex algorithms.\nLooking at the rules of Crazy Eights, we can identify some of the methods we’ll need:\n\nCreate the deck, the players, and the discard and draw piles. Deal the cards and set up the game. (Eights constructor)\nCheck whether the game is over. (isDone)\nIf the draw pile is empty, shuffle the discard pile and move the cards into the draw pile. (reshuffle)\nDraw a card, reshuffling the discard pile if necessary. (drawCard)\nKeep track of whose turn it is, and switch from one player to the next. (nextPlayer)\nDisplay the state of the game, and wait for the user before running the next turn. (displayState)\n\nNow we can start implementing the pieces. Here is the beginning of the class definition for Eights, which encapsulates the state of the game:\npublic class Eights {\n\n    private Player one;\n    private Player two;\n    private Hand drawPile;\n    private Hand discardPile;\n    private Scanner in;\nIn this version, there are always two players. One of the exercises at the end of the chapter asks you to modify this code to handle more players. The Eights class also includes a draw pile, a discard pile, and a Scanner, which we will use to prompt the user after each turn.\nThe constructor for Eights initializes the instance variables and deals the cards, similar to Section 14.3. The next piece we’ll need is a method that checks whether the game is over. If either hand is empty, we’re done:\npublic boolean isDone() {\n    return one.getHand().isEmpty() || two.getHand().isEmpty();\n}\nWhen the draw pile is empty, we have to shuffle the discard pile. Here is a method for that:\npublic void reshuffle() {\n    Card prev = discardPile.popCard();\n    discardPile.dealAll(drawPile);\n    discardPile.addCard(prev);\n    drawPile.shuffle();\n}\nThe first line saves the top card from discardPile. The next line transfers the rest of the cards to drawPile. Then we put the saved card back into discardPile and shuffle drawPile. We can use reshuffle as part of the draw method:\npublic Card drawCard() {\n    if (drawPile.isEmpty()) {\n        reshuffle();\n    }\n    return drawPile.popCard();\n}\nThe nextPlayer method takes the current player as a parameter and returns the player who should go next:\npublic Player nextPlayer(Player current) {\n    if (current == one) {\n        return two;\n    } else {\n        return one;\n    }\n}\nThe last method from our bottom-up design is displayState. It displays the hand of each player, the contents of the discard pile, and the number of cards in the draw pile. Finally, it waits for the user to press the Enter key:\npublic void displayState() {\n    one.display();\n    two.display();\n    discardPile.display();\n    System.out.println(\"Draw pile:\");\n    System.out.println(drawPile.size() + \" cards\");\n    in.nextLine();\n}\nUsing these pieces, we can write takeTurn, which executes one player’s turn. It reads the top card off the discard pile and passes it to player.play, which you saw in the previous section. The result is the card the player chose, which is added to the discard pile:\npublic void takeTurn(Player player) {\n    Card prev = discardPile.lastCard();\n    Card next = player.play(this, prev);\n    discardPile.addCard(next);\n\n    System.out.println(player.getName() + \" plays \" + next);\n    System.out.println();\n}\nFinally, we use takeTurn and the other methods to write playGame:\npublic void playGame() {\n    Player player = one;\n\n    // keep playing until there's a winner\n    while (!isDone()) {\n        displayState();\n        takeTurn(player);\n        player = nextPlayer(player);\n    }\n\n    // display the final score\n    one.displayScore();\n    two.displayScore();\n}\nDone! The result of bottom-up design is similar to top-down: we have a high-level method that calls helper methods. The difference is the development process we used to arrive at this solution.",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Extending Classes</span>"
    ]
  },
  {
    "objectID": "ch14.html#class-relationships",
    "href": "ch14.html#class-relationships",
    "title": "14  Extending Classes",
    "section": "14.6 Class Relationships",
    "text": "14.6 Class Relationships\nThis chapter demonstrates two common relationships between classes:\n\ncomposition:\n\nInstances of one class contain references to instances of another class. For example, an instance of Eights contains references to two Player objects, two Hand objects, and a Scanner.\n\ninheritance:\n\nOne class extends another class. For example, Hand extends CardCollection, so every instance of Hand is also a CardCollection.\n\n\nComposition is also known as a HAS-A relationship, as in “Eights has a Scanner”. Inheritance is also known as an IS-A relationship, as in “Hand is a CardCollection”. This vocabulary provides a concise way to talk about an object-oriented design.\nThere is also a standard way to represent these relationships graphically in UML class diagrams. As you saw in Section 10.7, the UML representation of a class is a box with three sections: the class name, the attributes, and the methods. The latter two sections are optional when showing relationships.\n\n\n\n\n\n\n\nUML diagram for the classes in this chapter.\n\n\nRelationships between classes are represented by arrows: composition arrows have a standard arrow head, and inheritance arrows have a hollow triangle head (usually pointing up). Figure 14.1 shows the classes defined in this chapter and the relationships among them.\nUML is an international standard, so almost any software engineer in the world could look at this diagram and understand our design. And class diagrams are only one of many graphical representations defined in the UML standard.",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Extending Classes</span>"
    ]
  },
  {
    "objectID": "ch14.html#vocabulary",
    "href": "ch14.html#vocabulary",
    "title": "14  Extending Classes",
    "section": "14.7 Vocabulary",
    "text": "14.7 Vocabulary\n\ninheritance:\n\nThe ability to define a new class that has the same instance variables and methods of an existing class.\n\nsubclass:\n\nA class that inherits from, or extends, an existing class.\n\nsuperclass:\n\nAn existing class that is extended by another class.\n\nbottom-up design:\n\nA way of developing programs by identifying simple pieces, implementing them first, and then assembling them into more-complex algorithms.\n\nHAS-A:\n\nA relationship between two classes in which one class “has” an instance of another class as one of its attributes.\n\nIS-A:\n\nA relationship between two classes in which one class extends another class; the subclass “is” an instance of the superclass.",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Extending Classes</span>"
    ]
  },
  {
    "objectID": "ch14.html#exercises",
    "href": "ch14.html#exercises",
    "title": "14  Extending Classes",
    "section": "14.8 Exercises",
    "text": "14.8 Exercises\nThe code for this chapter is in the ch14 directory of ThinkJavaCode2. See page  for instructions on how to download the repository. Before you start the exercises, we recommend that you compile and run the examples.\n\nExercise 14.1. Design a better strategy for the Player.play method. For example, if there are multiple cards you can play, and one of them is an 8, you might want to play the 8.\nThink of other ways you can minimize penalty points, such as playing the highest-ranking cards first. Write a new class that extends Player and overrides play to implement your strategy.\n\n\nExercise 14.2. Write a loop that plays the game 100 times and keeps track of how many times each player wins. If you implemented multiple strategies in the previous exercise, you can play them against each other to evaluate which one works best.\n**Hint:* Design a Genius class that extends Player and overrides the play method, and then replace one of the players with a Genius object.*\n\n\nExercise 14.3. One limitation of the program we wrote in this chapter is that it handles only two players. Modify the Eights class to create an ArrayList of players, and modify nextPlayer to select the next player.\n\n\nExercise 14.4. When we designed the program for this chapter, we tried to minimize the number of classes. As a result, we ended up with a few awkward methods. For example, cardMatches is a static method in Player, but it would be more natural if it were an instance method in Card.\nThe problem is that Card is supposed to be useful for any card game, not just Crazy Eights. You can solve this problem by adding a new class, EightsCard, that extends Card and provides a method, match, that checks whether two cards match according to the rules of Crazy Eights.\nAt the same time, you could create a new class, EightsHand, that extends Hand and provides a method, scoreHand, that adds up the scores of the cards in the hand. And while you’re at it, you could add a method named scoreCard to EightsCard.\nWhether or not you actually make these changes, draw a UML class diagram that shows this alternative object hierarchy.",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Extending Classes</span>"
    ]
  },
  {
    "objectID": "ch15.html",
    "href": "ch15.html",
    "title": "15  Arrays of Arrays",
    "section": "",
    "text": "15.1 Conway’s Game of Life\nThe Game of Life, or GoL for short, was developed by John Conway and popularized in 1970 in Martin Gardner’s column in Scientific American. Conway calls it a “zero-player game” because no players are needed to choose strategies or make decisions. After you set up the initial conditions, you watch the game play itself. That turns out to be more interesting than it sounds; you can read about it at https://en.wikipedia.org/wiki/Conway's_Game_of_Life.\nThe game board is a 2D grid of square cells. Each cell is either “alive” or “dead”; the color of the cell indicates its state. Figure 15.1 shows an example grid configuration; the five black cells are alive.\nThe game proceeds in time steps, during which each cell interacts with its neighbors in the eight adjacent cells. At each time step, the following rules are applied:\nNotice some consequences of these rules. If you start with a single live cell, it dies. If all cells are dead, no cells come to life. But if you have four cells in a square, they keep each other alive, so that’s a “stable” configuration.\nAnother initial configuration is shown in Figure 15.2. If you start with three horizontal cells, the center cell lives, the left and right cells die, and the top and bottom cells come to life. The result after the first time step is three vertical cells.\nDuring the next time step, the center cell lives, the top and bottom cells die, and the left and right cells come to life. The result is three horizontal cells, so we’re back where we started, and the cycle repeats forever.\nPatterns like this are called “periodic”, because they repeat after a period of two or more time steps. But they are also considered stable, because the total number of live cells doesn’t grow over time.\nMost simple starting configurations either die out quickly or reach a stable configuration. But there are a few starting conditions that display remarkable complexity. One of those is the R-pentomino (https://www.conwaylife.com/wiki/R-pentomino), which starts with only five cells, runs for 1,103 time steps, and ends in a stable configuration with 116 live cells.\nIn the following sections, we’ll implement the Game of Life in Java. We’ll first implement the cells, then the grid of cells, and finally the game itself.",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Arrays of Arrays</span>"
    ]
  },
  {
    "objectID": "ch15.html#conways-game-of-life",
    "href": "ch15.html#conways-game-of-life",
    "title": "15  Arrays of Arrays",
    "section": "",
    "text": "A “Glider” in the Game of Life.\n\n\n\n\nA live cell with fewer than two live neighbors dies, as if by underpopulation.\nA live cell with more than three live neighbors dies, as if by overpopulation.\nA dead cell with exactly three live neighbors becomes a live cell, as if by reproduction.\n\n\n\n\n\n\n\n\n\n\n\nA “Blinker” in the Game of Life.",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Arrays of Arrays</span>"
    ]
  },
  {
    "objectID": "ch15.html#the-cell-class",
    "href": "ch15.html#the-cell-class",
    "title": "15  Arrays of Arrays",
    "section": "15.2 The Cell Class",
    "text": "15.2 The Cell Class\nWhen drawing a cell, we’ll need to know its location on the screen and size in pixels. To represent the location, we use the x and y coordinates of the upper-left corner. And to represent the size, we use an integer, size.\nTo represent the state of a cell, we use an integer, state, which is 0 for dead cells and 1 for live cells. We could use a boolean instead, but it’s good practice to design classes to be reusable (e.g., for other games that have more states).\nHere is a Cell class that declares these instance variables:\npublic class Cell {\n    private final int x;\n    private final int y;\n    private final int size;\n    private int state;\n}\nNotice that x, y, and size are constants. Once the cell is created, we don’t want it to move or change size. But state can and should change, so it is not a constant.\nThe next step is to write a constructor. Here’s one that takes x, y, and size as parameters, and sets state to a default value:\npublic Cell(int x, int y, int size) {\n    this.x = x;\n    this.y = y;\n    this.size = size;\n    this.state = 0;\n}\nThe following method draws a cell. Like the paint method in Appendix 20, it takes a graphics context as a parameter:\npublic static final Color[] COLORS = {Color.WHITE, Color.BLACK};\n\npublic void draw(Graphics g) {\n    g.setColor(COLORS[state]);\n    g.fillRect(x + 1, y + 1, size - 1, size - 1);\n    g.setColor(Color.LIGHT_GRAY);\n    g.drawRect(x, y, size, size);\n}\nThe draw method uses the state of the cell to select a color from an array of Color objects. Then it uses to fillRect to draw the center of the cell and drawRect to draw a light-gray border.\nWe also need methods to get and set the cell’s state. We could just provide getState and setState, but the code will be more readable if we provide methods customized for the Game of Life:\npublic boolean isOff() {\n    return state == 0;\n}\n\npublic boolean isOn() {\n    return state == 1;\n}\n\npublic void turnOff() {\n    state = 0;\n}\n\npublic void turnOn() {\n    state = 1;\n}",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Arrays of Arrays</span>"
    ]
  },
  {
    "objectID": "ch15.html#two-dimensional-arrays",
    "href": "ch15.html#two-dimensional-arrays",
    "title": "15  Arrays of Arrays",
    "section": "15.3 Two-Dimensional Arrays",
    "text": "15.3 Two-Dimensional Arrays\nTo represent a grid of cells, we can use a multidimensional array. To create a 2D array, we specify the number of rows and columns:\nint rows = 4;\nint cols = 3;\nCell[][] array = new Cell[rows][cols];\nThe result is an array with four rows and three columns. Initially, the elements of the array are null. We can fill the array with Cell objects like this:\nfor (int r = 0; r &lt; rows; r++) {\n    int y = r * size;\n    for (int c = 0; c &lt; cols; c++) {\n        int x = c * size;\n        array[r][c] = new Cell(x, y, size);\n    }\n}\nThe loop variables r and c are the row and column indexes of the cells. The variables x and y are the coordinates, respectively. For example, if size is 10 pixels, the cell at index (1, 2) would be at coordinates (10, 20) on the screen.\nIn Java, a 2D array is really an array of arrays. You can think of it as an array of rows, where each row is an array. Figure 15.3 shows what it looks like.\n\n\n\n\n\n\n\nStoring rows and columns with a 2D array.\n\n\nWhen we write array[r][c], Java uses the first index to select a row and the second index to select an element from the row. This way of representing 2D data is known as row-major order.",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Arrays of Arrays</span>"
    ]
  },
  {
    "objectID": "ch15.html#the-gridcanvas-class",
    "href": "ch15.html#the-gridcanvas-class",
    "title": "15  Arrays of Arrays",
    "section": "15.4 The GridCanvas Class",
    "text": "15.4 The GridCanvas Class\nNow that we have a Cell class and a way to represent a 2D array of cells, we can write a class to represent a grid of cells. We encapsulate the code from the previous section and generalize it to construct a grid with any number of rows and columns:\npublic class GridCanvas extends Canvas {\n    private Cell[][] array;\n\n    public GridCanvas(int rows, int cols, int size) {\n        array = new Cell[rows][cols];\n        for (int r = 0; r &lt; rows; r++) {\n            int y = r * size;\n            for (int c = 0; c &lt; cols; c++) {\n                int x = c * size;\n                array[r][c] = new Cell(x, y, size);\n            }\n        }\n\n        // set the canvas size\n        setSize(cols * size, rows * size);\n    }\n}\nUsing vocabulary from the previous chapter, GridCanvas “is a” Canvas that “has a” 2D array of cells. By extending the Canvas class from java.awt, we inherit methods for drawing graphics on the screen.\nIn fact, the code is surprisingly straightforward: to draw the grid, we simply draw each cell. We use nested for loops to traverse the 2D array:\npublic void draw(Graphics g) {\n    for (Cell[] row : array) {\n        for (Cell cell : row) {\n            cell.draw(g);\n        }\n    }\n}\nThe outer loop traverses the rows; the inner loop traverses the cells in each row. You can almost read this method in English: “For each row in the array, and for each cell in the row, draw the cell in the graphics context.” Each cell contains its coordinates and size, so it knows how to draw itself.\nClasses that extend Canvas are supposed to provide a method called paint that “paints” the contents of the Canvas. It gets invoked when the Canvas is created and anytime it needs to be redrawn; for example, when its window is moved or resized.\nHere’s the paint method for GridCanvas. When the window management system calls paint, paint calls draw, which draws the cells:\npublic void paint(Graphics g) {\n    draw(g);\n}",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Arrays of Arrays</span>"
    ]
  },
  {
    "objectID": "ch15.html#other-grid-methods",
    "href": "ch15.html#other-grid-methods",
    "title": "15  Arrays of Arrays",
    "section": "15.5 Other Grid Methods",
    "text": "15.5 Other Grid Methods\nIn addition to draw and paint, the GridCanvas class provides methods for working with the grid itself. numRows and numCols return the number of rows and columns. We can get this information from the 2D array, using length:\npublic int numRows() {\n    return array.length;\n}\n\npublic int numCols() {\n    return array[0].length;\n}\nBecause we are using row-major order, the 2D array is an array of rows. numRows simply returns the length of the rows array. numCols returns the length of the first row, which is the number of columns. Since the rows all have the same length, we have to check only one.\nGridCanvas also provides a method that gets the Cell at a given location, and for convenience when starting the game, a method that turns on the Cell at a given location.\npublic Cell getCell(int r, int c) {\n    return array[r][c];\n}\n\npublic void turnOn(int r, int c) {\n    array[r][c].turnOn();\n}",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Arrays of Arrays</span>"
    ]
  },
  {
    "objectID": "ch15.html#conwaymain",
    "href": "ch15.html#conwaymain",
    "title": "15  Arrays of Arrays",
    "section": "15.6 Starting the Game",
    "text": "15.6 Starting the Game\nNow we’re ready to implement the game. To encapsulate the rules of GoL, we define a class named Conway. The Conway class “has a” GridCanvas that represents the state of the game.\nThis constructor makes a GridCanvas with 5 rows and 10 columns, with cells that are 20 pixels wide and high. It then sets up the initial conditions:\npublic class Conway {\n    private GridCanvas grid;\n\n    public Conway() {\n        grid = new GridCanvas(5, 10, 20);\n        grid.turnOn(2, 1);\n        grid.turnOn(2, 2);\n        grid.turnOn(2, 3);\n        grid.turnOn(1, 7);\n        grid.turnOn(2, 7);\n        grid.turnOn(3, 7);\n    }\n}\nBefore we implement the rest of the game, we’ll write a main method that creates a Conway object and displays it. We can use this method to test Cell and GridCanvas, and to develop the other methods we need:\npublic static void main(String[] args) {\n    String title = \"Conway's Game of Life\";\n    Conway game = new Conway();\n    JFrame frame = new JFrame(title);\n    frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n    frame.setResizable(false);\n    frame.add(game.grid);\n    frame.pack();\n    frame.setVisible(true);\n    game.mainloop();\n}\nAfter constructing the game object, main constructs a JFrame, which creates a window on the screen. The JFrame is configured to exit the program when closed. Resizing the window is disabled.\nmain then adds the GridCanvas inside the frame, resizes (“packs”) the frame to fit the canvas, and makes the frame visible. Figure 15.4 shows the result.\n\n\n\n\n\n\n\nScreenshot of the initial Conway application.",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Arrays of Arrays</span>"
    ]
  },
  {
    "objectID": "ch15.html#mainloop",
    "href": "ch15.html#mainloop",
    "title": "15  Arrays of Arrays",
    "section": "15.7 The Simulation Loop",
    "text": "15.7 The Simulation Loop\nAt the end of main, we call mainloop, which uses a while loop to simulate the time steps of the Game of Life. Here’s a rough draft of this method:\nprivate void mainloop() {\n    while (true) {\n        this.update();\n        grid.repaint();\n        Thread.sleep(500);    // compiler error\n    }\n}\nDuring each time step, we update the state of the game and repaint the grid. We will present the update method in Section 15.10.\nrepaint comes from the Canvas class. By default, it calls the paint method we provided, which calls draw. The reason we use it here is that repaint does not require a Graphics object as a parameter.\nThread.sleep(500) causes the program to “sleep” for 500 milliseconds, or a half second. Otherwise, the program would run so fast we would not be able to see the animation.\nThere’s just one problem: compiling this code results in the error “unreported exception InterruptedException”. This message means we need to do some exception handling.",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Arrays of Arrays</span>"
    ]
  },
  {
    "objectID": "ch15.html#exception-handling",
    "href": "ch15.html#exception-handling",
    "title": "15  Arrays of Arrays",
    "section": "15.8 Exception Handling",
    "text": "15.8 Exception Handling\nSo far, the only exceptions you have seen are run-time errors like “array index out of bounds” and “null pointer”. When one of these exceptions occurs, Java displays a message and ends the program.\nIf you don’t want the program to end, you can handle exceptions with a try-catch statement. The syntax is similar to an if-else statement, and the logic is, too. Here’s what it looks like:\ntry {\n    Thread.sleep(500);\n} catch (InterruptedException e) {\n    // do nothing\n}\nFirst, Java runs the code in the try block, which calls Thread.sleep in this example. If an InterruptedException occurs during the try block, Java executes the catch block. In this example, the catch block contains a comment, so it doesn’t do anything.\nIf a different exception occurs during the try block, Java does whatever it would do otherwise, which is probably to display a message and end the program. If no exceptions occur during the try block, the catch block doesn’t run and the program continues.\nIn this example, the effect of the try-catch statement is to ignore an “interrupted” exception if it occurs. As an alternative, we could use the catch block to display a customized message, end the program, or handle the exception in whatever way is appropriate. For example, if user input causes an exception, we could catch the exception and prompt the user to try again later.\nThere’s more to learn about exception handling. You can read about exceptions in the Java tutorials (see https://thinkjava.org/exceptions).",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Arrays of Arrays</span>"
    ]
  },
  {
    "objectID": "ch15.html#counting-neighbors",
    "href": "ch15.html#counting-neighbors",
    "title": "15  Arrays of Arrays",
    "section": "15.9 Counting Neighbors",
    "text": "15.9 Counting Neighbors\nNow that you know about try and catch, we can use them to implement a useful method in GridCanvas. Part of the GoL logic is to count the number of live neighbors. Most cells have eight neighbors, as shown in Figure 15.5.\nHowever, cells on the edges and in the corners have fewer neighbors. If we try to count all possible neighbors, we’ll go out of bounds. The following method uses a try-catch statement to deal with these special cases:\npublic int test(int r, int c) {\n    try {\n        if (array[r][c].isOn()) {\n            return 1;\n        }\n    } catch (ArrayIndexOutOfBoundsException e) {\n        // cell doesn't exist\n    }\n    return 0;\n}\n\n\n\n\n\n\n\nCells in the interior of the grid have eight neighbors. Cells in the corners and along the edges have fewer neighbors.\n\n\nThe test method takes a row index, r, and a column index, c. It tries to look up the Cell at that location. If both indexes are in bounds, the Cell exists. In that case, test returns 1 if the Cell is on. Otherwise, it skips the catch block and returns 0.\nIf either index is out of bounds, the array lookup throws an exception, but the catch block ignores it. Then test resumes and returns 0. So the non-existent cells around the perimeter are considered to be off.\nNow we can use test to implement countAlive, which takes a grid location, (r, c), and returns the number of live neighbors surrounding that location:\nprivate int countAlive(int r, int c) {\n    int count = 0;\n    count += grid.test(r - 1, c - 1);\n    count += grid.test(r - 1, c);\n    count += grid.test(r - 1, c + 1);\n    count += grid.test(r, c - 1);\n    count += grid.test(r, c + 1);\n    count += grid.test(r + 1, c - 1);\n    count += grid.test(r + 1, c);\n    count += grid.test(r + 1, c + 1);\n    return count;\n}\nBecause test handles “out of bounds” exceptions, countAlive works for any values of r and c.",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Arrays of Arrays</span>"
    ]
  },
  {
    "objectID": "ch15.html#sec:update",
    "href": "ch15.html#sec:update",
    "title": "15  Arrays of Arrays",
    "section": "15.10 Updating the Grid",
    "text": "15.10 Updating the Grid\nNow we are ready to write update, which gets invoked each time through the simulation loop. It uses the GoL rules to compute the state of the grid after the next time step:\npublic void update() {\n    int[][] counts = countNeighbors();\n    updateGrid(counts);\n}\nThe rules of GoL specify that you have to update the cells “simultaneously”; that is, you have to count the neighbors for all cells before you can update any of them.\nWe do that by traversing the grid twice: first, countNeighbors counts the live neighbors for each cell and puts the results in an array named counts; second, updateGrid updates the cells. Here’s countNeighbors:\nprivate int[][] countNeighbors() {\n    int rows = grid.numRows();\n    int cols = grid.numCols();\n\n    int[][] counts = new int[rows][cols];\n    for (int r = 0; r &lt; rows; r++) {\n        for (int c = 0; c &lt; cols; c++) {\n            counts[r][c] = countAlive(r, c);\n        }\n    }\n    return counts;\n}\ncountNeighbors traverses the cells in the grid and uses countAlive from the previous section to count the neighbors. The return value is a 2D array of integers with the same size as grid. Figure 15.6 illustrates an example.\n\n\n\n\n\n\n\nThe result of countNeighbors for the grid in Section 15.6.\n\n\nIn contrast to the draw method of GridCanvas, which uses enhanced for loops, countNeighbors uses standard for loops. The reason is that, in this example, we need the indexes r and c to store the neighbor counts.\nupdateGrid uses getCell to select each Cell in the grid, and updateCell to do the update:\nprivate void updateGrid(int[][] counts) {\n    int rows = grid.numRows();\n    int cols = grid.numCols();\n\n    for (int r = 0; r &lt; rows; r++) {\n        for (int c = 0; c &lt; cols; c++) {\n            Cell cell = grid.getCell(r, c);\n            updateCell(cell, counts[r][c]);\n        }\n    }\n}\nupdateCell implements the GoL rules: if the cell is alive, it dies if it has fewer than two or more than three neighbors; if the cell is dead, it comes to life if it has exactly three:\nprivate static void updateCell(Cell cell, int count) {\n    if (cell.isOn()) {\n        if (count &lt; 2 || count &gt; 3) {\n            cell.turnOff();\n        }\n    } else {\n        if (count == 3) {\n            cell.turnOn();\n        }\n    }\n}\nNotice that updateGrid and updateCell are both private, because they are helper methods not intended to be invoked from outside the class. updateCell is also static, because it does not depend on grid.\nNow our implementation of the Game of Life is complete. We think it’s is pretty fun, and we hope you agree. But more importantly, this example is meant to demonstrate the use of 2D arrays and an object-oriented design that’s a little more substantial than in previous chapters.",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Arrays of Arrays</span>"
    ]
  },
  {
    "objectID": "ch15.html#vocabulary",
    "href": "ch15.html#vocabulary",
    "title": "15  Arrays of Arrays",
    "section": "15.11 Vocabulary",
    "text": "15.11 Vocabulary\n\nmultidimensional array:\n\nAn array with more than one dimension; a 2D array is an “array of arrays”.\n\nrow-major order:\n\nStoring data in a 2D array, first by rows and then by columns.",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Arrays of Arrays</span>"
    ]
  },
  {
    "objectID": "ch15.html#exercises",
    "href": "ch15.html#exercises",
    "title": "15  Arrays of Arrays",
    "section": "15.12 Exercises",
    "text": "15.12 Exercises\nThe code for this chapter is in the ch15 directory of ThinkJavaCode2. See page  for instructions on how to download the repository. Before you start the exercises, we recommend that you compile and run the examples.\n\nExercise 15.1. In GridCanvas, write a method named countOn that returns the total number of cells that are “on”. This method can be used, for example, to track the population in Game of Life over time.\n\n\nExercise 15.2. In our version of the Game of Life, the grid has a finite size. As a result, moving objects such as Gliders either crash into the wall or go out of bounds.\nAn interesting variation of the Game of Life is a “toroidal” grid, meaning that the cells “wrap around” on the edges. Modify the test method of GridCanvas so that the coordinates r and c map to the opposite side of the grid if they are too low or two high.\nRun your code with a Glider (see Figure 15.1) to see if it works. You can initialize the Glider by modifying the constructor in the Conway class, or by reading it from a file (see the next exercise).\n\n\nExercise 15.3. The LifeWiki site (https://conwaylife.com/wiki/) has a fascinating collection of patterns for the Game of Life. These patterns are stored in a file format that is easy to read, in files with the suffix “.cells”.\nFor example, here is an 8 x 10 grid with a Glider near the upper-left corner:\n!Name: Glider\n..........\n..O.......\n...O......\n.OOO......\n..........\n..........\n..........\n..........\nLines that begin with ! are comments and should be ignored. The rest of the file describes the grid, row by row. A period represents a dead cell, and an uppercase O represents a live cell. See https://conwaylife.com/wiki/Plaintext for more examples.\n\nCreate a plain text file with the contents shown above, and save the file as glider.cells* in the same directory as your code.*\nDefine a constructor for the Conway class that takes a string representing the name (or path) of a “.cells” file. Here is a starting point:\npublic Conway(String path) {\n    File file = new File(path);\n    Scanner scan = new Scanner(file);\n}\nModify the main method to invoke the constructor as follows:\nConway game = new Conway(\"glider.cells\");\nHandle the FileNotFoundException that may be thrown when creating a Scanner for a File by invoking printStackTrace on the exception object and calling System.exit() with a status of 1, indicating an error.\nContinue implementing the constructor by reading all non-comment lines into an ArrayList via hasNextLine and nextLine of the Scanner.\nDetermine the number of rows and columns of the grid by examining the ArrayList contents.\nCreate and initialize a GridCanvas based on the ArrayList.\n\nOnce your constructor is working, you will be able to run many of the patterns on the LifeWiki. You might want to add a margin of empty cells around the initial pattern, to give it room to grow.\n\n\nExercise 15.4. Some files on the LifeWiki use “run-length encoding” (RLE) instead of plain text. The basic idea of RLE is to describe the number of dead and alive cells, rather than type out each individual cell.\nFor example, glider.cells* from the previous exercise could be represented this way with RLE:*\n#C Name: Glider\nx = 10, y = 8\n$2bo$3bo$b3o!\nThe first line specifies x (the number of columns) and y (the number of rows). Subsequent lines consist of the letters b (dead), o (alive), and $ (end of line), optionally preceded by a count. The pattern ends with !, after which any remaining file contents are ignored.\nLines beginning with # have special meaning and are not part of the pattern. For example, #C is a comment line. You can read more about RLE format on https://conwaylife.com/wiki/RLE.\n\nCreate a plain text file with the preceding contents, and save the file as glider.rle* in the same directory as your code.*\nModify your constructor from the previous exercise to check the last three characters of the path. If they are \"rle\", then you will need to process the file as RLE. Otherwise, assume the file is in “.cells” format.\nIn the end, your constructor should be able to read and initialize grids in both formats. Test your constructor by modifying the main method to read different files.",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Arrays of Arrays</span>"
    ]
  },
  {
    "objectID": "ch16.html",
    "href": "ch16.html",
    "title": "16  Reusing Classes",
    "section": "",
    "text": "16.1 Langton’s Ant\nWe begin by defining a Langton class that has a grid and information about the ant. The constructor takes the grid dimensions as parameters:\ngrid is a GridCanvas object, which represents the state of the cells. xpos and ypos are the coordinates of the ant, and head is the “heading” of the ant; that is, which direction it is facing. head is an integer with four possible values, where 0 means the ant is facing “north” (i.e., toward the top of the screen), 1 means “east”, etc.\nHere’s an update method that implements the rules for Langton’s Ant:\nThe flipCell method gets the Cell at the ant’s location, figures out which way to turn, and changes the state of the cell:\nWe use the remainder operator, %, to make head wrap around: if head is 3 and we turn right, it wraps around to 0; if head is 0 and we turn left, it wraps around to 3.\nNotice that to turn right, we add 1 to head. To turn left, we could subtract 1, but -1 % 4 is -1 in Java. So we add 3 instead, since one left turn is the same as three right turns.\nThe moveAnt method moves the ant forward one square, using head to determine which way is forward:\nHere is the main method we use to create and display the Langton object:\nMost of this code is the same as the main we used to create and run Conway, in Section 15.6. It creates and configures a JFrame and runs mainloop.\nAnd that’s everything! If you run this code with a grid size of 61 x 61 or larger, you will see the ant eventually settle into a repeating pattern.\nBecause we designed Cell and GridCanvas to be reusable, we didn’t have to modify them at all. However, we now have two copies of main and mainloop—one in Conway, and one in Langton.",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Reusing Classes</span>"
    ]
  },
  {
    "objectID": "ch16.html#langtons-ant",
    "href": "ch16.html#langtons-ant",
    "title": "16  Reusing Classes",
    "section": "",
    "text": "public class Langton {\n    private GridCanvas grid;\n    private int xpos;\n    private int ypos;\n    private int head; // 0=North, 1=East, 2=South, 3=West\n\n    public Langton(int rows, int cols) {\n        grid = new GridCanvas(rows, cols, 10);\n        xpos = rows / 2;\n        ypos = cols / 2;\n        head = 0;\n    }\n}\n\n\npublic void update() {\n    flipCell();\n    moveAnt();\n}\n\nprivate void flipCell() {\n    Cell cell = grid.getCell(xpos, ypos);\n    if (cell.isOff()) {\n        head = (head + 1) % 4;    // turn right\n        cell.turnOn();\n    } else {\n        head = (head + 3) % 4;    // turn left\n        cell.turnOff();\n    }\n}\n\n\n\nprivate void moveAnt() {\n    if (head == 0) {\n        ypos -= 1;\n    } else if (head == 1) {\n        xpos += 1;\n    } else if (head == 2) {\n        ypos += 1;\n    } else {\n        xpos -= 1;\n    }\n}\n\npublic static void main(String[] args) {\n    String title = \"Langton's Ant\";\n    Langton game = new Langton(61, 61);\n    JFrame frame = new JFrame(title);\n    frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n    frame.setResizable(false);\n    frame.add(game.grid);\n    frame.pack();\n    frame.setVisible(true);\n    game.mainloop();\n}",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Reusing Classes</span>"
    ]
  },
  {
    "objectID": "ch16.html#refactor",
    "href": "ch16.html#refactor",
    "title": "16  Reusing Classes",
    "section": "16.2 Refactoring",
    "text": "16.2 Refactoring\nWhenever you see repeated code like main, you should think about ways to remove it. In Chapter 14, we used inheritance to eliminate repeated code. We’ll do something similar with Conway and Langton.\nFirst, we define a superclass named Automaton, in which we will put the code that Conway and Langton have in common:\npublic class Automaton {\n    private GridCanvas grid;\n\n    public void run(String title, int rate) {\n        JFrame frame = new JFrame(title);\n        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n        frame.setResizable(false);\n        frame.add(this.grid);\n        frame.pack();\n        frame.setVisible(true);\n        this.mainloop(rate);\n    }\n}\nAutomaton declares grid as an instance variable, so every Automaton “has a” GridCanvas. It also provides run, which contains the code that creates and configures the JFrame.\nThe run method takes two parameters: the window title and the frame rate; that is, the number of time steps to show per second. It uses title when creating the JFrame, and it passes rate to mainloop:\nprivate void mainloop(int rate) {\n    while (true) {\n\n        // update the drawing\n        this.update();\n        grid.repaint();\n\n        // delay the simulation\n        try {\n            Thread.sleep(1000 / rate);\n        } catch (InterruptedException e) {\n            // do nothing\n        }\n    }\n}\nmainloop contains the code you first saw in Section 15.7. It runs a while loop forever (or until the window closes). Each time through the loop, it runs update to update grid and then repaint to redraw the grid.\nThen it calls Thread.sleep with a delay that depends on rate. For example, if rate is 2, we should draw two frames per second, so the delay is a half second, or 500 milliseconds.\nThis process of reorganizing existing code, without changing its behavior, is known as refactoring. We’re almost finished; we just need to redesign Conway and Langton to extend Automaton.",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Reusing Classes</span>"
    ]
  },
  {
    "objectID": "ch16.html#abstract-classes",
    "href": "ch16.html#abstract-classes",
    "title": "16  Reusing Classes",
    "section": "16.3 Abstract Classes",
    "text": "16.3 Abstract Classes\nIf we were not planning to implement any other zero-person games, we could leave well enough alone. But there are a few problems with the current design:\n\nThe grid attribute is private, making it inaccessible in Conway and Langton. We could make it public, but then other (unrelated) classes would have access to it as well.\nThe Automaton class has no constructors, and even if it did, there would be no reason to create an instance of this class.\nThe Automaton class does not provide an implementation of update. In order to work properly, subclasses need to provide one.\n\nJava provides language features to solve these problems:\n\nWe can make the grid attribute protected, which means it’s accessible to subclasses but not other classes.\nWe can make the class abstract, which means it cannot be instantiated. If you attempt to create an object for an abstract class, you will get a compiler error.\nWe can declare update as an abstract method, meaning that it must be overridden in subclasses. If the subclass does not override an abstract method, you will get a compiler error.\n\nHere’s what Automaton looks like as an abstract class (using the methods mainloop and run from Section 16.2):\npublic abstract class Automaton {\n    protected GridCanvas grid;\n\n    public abstract void update();\n\n    private void mainloop(int rate) {\n        // this method invokes update\n    }\n\n    public void run(String title, int rate) {\n        // this method invokes mainloop\n    }\n}\nNotice that the update method has no body. The declaration specifies the name, arguments, and return type. But it does not provide an implementation, because it is an abstract method.\nNotice also the word abstract on the first line, which declares that Automaton is an abstract class. In order to have any abstract methods, a class must be declared as abstract.\nAny class that extends Automaton must provide an implementation of update; the declaration here allows the compiler to check.\nHere’s what Conway looks like as a subclass of Automaton:\npublic class Conway extends Automaton {\n\n    // same methods as before, except mainloop is removed\n\n    public static void main(String[] args) {\n        String title = \"Conway's Game of Life\";\n        Conway game = new Conway();\n        game.run(title, 2);\n    }\n}\nConway extends Automaton, so it inherits the protected instance variable grid and the methods mainloop and run. But because Automaton is abstract, Conway has to provide update and a constructor (which it has already).\nAbstract classes are essentially “incomplete” class definitions that specify methods to be implemented by subclasses. But they also provide attributes and methods to be inherited, thus eliminating repeated code.",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Reusing Classes</span>"
    ]
  },
  {
    "objectID": "ch16.html#uml-diagram",
    "href": "ch16.html#uml-diagram",
    "title": "16  Reusing Classes",
    "section": "16.4 UML Diagram",
    "text": "16.4 UML Diagram\nAt the beginning of the chapter, we had three classes: Cell, GridCanvas, and Conway. We then developed Langton, which had almost the same main and mainloop methods as Conway. So we refactored the code and created Automaton. Figure 16.1 summarizes the final design.\n\n\n\n\n\n\n\nUML class diagram of Conway and Langton applications.\n\n\nThe diagram shows three examples of inheritance: Conway is an Automaton, Langton is an Automaton, and GridCanvas is a Canvas. It also shows two examples of composition: Automaton has a GridCanvas, and GridCanvas has a 2D array of Cells.\nThe diagram also shows that Automaton uses JFrame, GridCanvas uses Graphics, and Cell uses Graphics and Color.\nAutomaton is in italics to indicate that it is an abstract class. As it happens, Graphics is an abstract class, too.\nConway and Langton are concrete classes, because they provide an implementation for all of their methods. In particular, they implement the update method that was declared abstract in Automaton.\nOne of the challenges of object-oriented programming is keeping track of a large number of classes and the relationships between them. UML class diagrams can help.",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Reusing Classes</span>"
    ]
  },
  {
    "objectID": "ch16.html#vocabulary",
    "href": "ch16.html#vocabulary",
    "title": "16  Reusing Classes",
    "section": "16.5 Vocabulary",
    "text": "16.5 Vocabulary\n\nrefactor:\n\nTo restructure or reorganize existing source code without changing its behavior.\n\nabstract class:\n\nA class that is declared as abstract; it cannot be instantiated, and it may (or may not) include abstract methods.\n\nconcrete class:\n\nA class that is not declared as abstract; each of its methods must have an implementation.",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Reusing Classes</span>"
    ]
  },
  {
    "objectID": "ch16.html#exercises",
    "href": "ch16.html#exercises",
    "title": "16  Reusing Classes",
    "section": "16.6 Exercises",
    "text": "16.6 Exercises\nThe code for this chapter is in the ch16 directory of ThinkJavaCode2. See page  for instructions on how to download the repository. Before you start the exercises, we recommend that you compile and run the examples.\n\nExercise 16.1. The last section of this chapter introduced Automaton as an abstract class and rewrote Conway as a subclass of Automaton. Now it’s your turn: rewrite Langton as a subclass of Automaton, removing the code that’s no longer needed.\n\n\nExercise 16.2. Mathematically speaking, Game of Life and Langton’s Ant are cellular automata. “Cellular” means it has cells, and “automaton” means it runs itself. See https://en.wikipedia.org/wiki/Cellular_automaton for more discussion.\nImplement another cellular automaton of your choice. You may have to modify Cell and/or GridCanvas, in addition to extending Automaton. For example, Brian’s Brain (https://en.wikipedia.org/wiki/Brian's_Brain) requires three states: “on”, “dying”, and “off”.",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Reusing Classes</span>"
    ]
  },
  {
    "objectID": "ch17.html",
    "href": "ch17.html",
    "title": "17  Advanced Topics",
    "section": "",
    "text": "17.1 Polygon Objects\nThe word polygon means “many angles”; the most basic polygons are triangles (three angles), rectangles (four angles), pentagons (five angles), and so forth. Polygons are an important part of computer graphics because they are used to compose more complex images.\nJava provides a Polygon class (in java.awt) that we can use to represent and draw polygons. The following code creates an empty Polygon and adds three points, forming a triangle:\nInternally, Polygon objects have three attributes:\nWhen a Polygon is created, npoints is 0 and the two arrays are initialized with length 4. As points are added, npoints is incremented. If npoints exceeds the length of the arrays, larger arrays are created, and the previous values are copied over (similar to how ArrayList works).\nThe Polygon class provides many useful methods, like contains, intersects, and translate. We’ll get to those later, but first we’re going to do some specialization.",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Advanced Topics</span>"
    ]
  },
  {
    "objectID": "ch17.html#polygon-objects",
    "href": "ch17.html#polygon-objects",
    "title": "17  Advanced Topics",
    "section": "",
    "text": "Polygon p = new Polygon();\np.addPoint(57, 110);\np.addPoint(100, 35);\np.addPoint(143, 110);\n\n\npublic int npoints;     // total number of points\npublic int[] xpoints;   // array of X coordinates\npublic int[] ypoints;   // array of Y coordinates",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Advanced Topics</span>"
    ]
  },
  {
    "objectID": "ch17.html#adding-color",
    "href": "ch17.html#adding-color",
    "title": "17  Advanced Topics",
    "section": "17.2 Adding Color",
    "text": "17.2 Adding Color\nSpecialization is useful for adding new features to an existing class, especially when you can’t (or don’t want to) change its design. For example, we can extend the Polygon class by adding a draw method and a Color attribute:\npublic class DrawablePolygon extends Polygon {\n    protected Color color;\n\n    public DrawablePolygon() {\n        super();\n        color = Color.GRAY;\n    }\n\n    public void draw(Graphics g) {\n        g.setColor(color);\n        g.fillPolygon(this);\n    }\n}\nAs a reminder, constructors are not inherited when you extend a class. If you don’t define a constructor, the compiler will generate one that does nothing.\nThe constructor for DrawablePolygon uses super to invoke the constructor for Polygon, which initializes the attributes npoints, xpoints, and ypoints. Then DrawablePolygon initializes the color attribute to GRAY.\nDrawablePolygon has the same attributes and methods that Polygon has, so you can use addPoint as before, or you can directly access npoints, xpoints, and ypoints (since they are public). You can also use methods like contains, intersects, and translate.\nThe following code creates a DrawablePolygon with the same points as in the previous section and sets its color to GREEN:\nDrawablePolygon p = new DrawablePolygon();\np.addPoint(57, 110);\np.addPoint(100, 35);\np.addPoint(143, 110);\np.color = Color.GREEN;",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Advanced Topics</span>"
    ]
  },
  {
    "objectID": "ch17.html#regular-polygons",
    "href": "ch17.html#regular-polygons",
    "title": "17  Advanced Topics",
    "section": "17.3 Regular Polygons",
    "text": "17.3 Regular Polygons\nIn mathematics, a regular polygon has all sides the same length and all angles equal in measure. Regular polygons are a special case of polygons, so we will use specialization to define a class for them.\nWe could extend the Polygon class, as we did in the previous section. But then we would not have the Color functionality we just added. So we will make RegularPolygon extend DrawablePolygon.\nTo construct a RegularPolygon, we specify the number of sides, the radius (distance from the center to a vertex), and the color. For example:\nRegularPolygon rp = new RegularPolygon(6, 50, Color.BLUE);\n\n\n\n\n\n\n\nDetermining the x and y coordinates of vertex V1, given the radius r and angle θ. The center of the polygon is at the origin (0, 0).\n\n\nThe constructor uses trigonometry to find the coordinates of each vertex. Figure 17.1 illustrates the process. The number of sides (\\(n=6\\)) and the radius (\\(r=50\\)) are given as parameters.\n\nImagine a clock hand starting at V0 and rotating counterclockwise to V1, V2, and so forth. In Figure 17.1, the hand is currently at V1.\nThe angle \\(\\theta\\) is \\(2 \\pi / n\\), since there are \\(2\\pi\\) radians in a circle. In other words, we are dividing the rotation of the clock hand into \\(n\\) equal angles.\nBy definition, \\(\\cos(\\theta) = x/r\\) and \\(\\sin(\\theta) = y/r\\). Therefore, \\(x = r \\cos(\\theta)\\) and \\(y = r \\sin(\\theta)\\).\nWe can determine the other \\((x, y)\\) coordinates by multiplying \\(\\theta\\) by \\(i\\), where \\(i\\) is the vertex number.\n\nHere is the constructor for RegularPolygon:\npublic RegularPolygon(int nsides, int radius, Color color) {\n\n    // initialize DrawablePolygon attributes\n    this.npoints = nsides;\n    this.xpoints = new int[nsides];\n    this.ypoints = new int[nsides];\n    this.color = color;\n\n    // the amount to rotate for each vertex (in radians)\n    double theta = 2.0 * Math.PI / nsides;\n\n    // compute x and y coordinates, centered at the origin\n    for (int i = 0; i &lt; nsides; i++) {\n        double x = radius * Math.cos(i * theta);\n        double y = radius * Math.sin(i * theta);\n        xpoints[i] = (int) Math.round(x);\n        ypoints[i] = (int) Math.round(y);\n    }\n}\nThis constructor initializes all four DrawablePolygon attributes, so it doesn’t have to invoke super().\nIt initializes xpoints and ypoints by creating arrays of integer coordinates. Inside the for loop, it uses Math.sin and Math.cos (see Section 4.6) to compute the coordinates of the vertices as floating-point numbers. Then it rounds them off to integers and stores them in the arrays.\nWhen we construct a RegularPolygon, the vertices are centered at the point \\((0, 0)\\). If we want the center of the polygon to be somewhere else, we can use translate, which we inherit from Polygon:\nRegularPolygon rp = new RegularPolygon(6, 50, Color.BLUE);\nrp.translate(100, 100);\nThe result is a six-sided polygon with radius 50 centered at the point \\((100, 100)\\).",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Advanced Topics</span>"
    ]
  },
  {
    "objectID": "ch17.html#more-constructors",
    "href": "ch17.html#more-constructors",
    "title": "17  Advanced Topics",
    "section": "17.4 More Constructors",
    "text": "17.4 More Constructors\nClasses in the Java library often have more than one constructor for convenience. We can do the same with RegularPolygon. For example, we can make the color parameter optional by defining a second constructor:\npublic RegularPolygon(int nsides, int radius) {\n    this(nsides, radius, Color.GRAY);\n}\nThe keyword this, when used in a constructor, invokes another constructor in the same class. It has a similar syntax as the keyword super, which invokes a constructor in the superclass.\nSimilarly, we could make the radius parameter optional too:\npublic RegularPolygon(int nsides) {\n    this(nsides, 50);\n}\nNow, suppose we invoke the RegularPolygon constructor like this:\nRegularPolygon rp = new RegularPolygon(6);\nBecause we provide only one integer argument, Java calls the third constructor, which calls the second one, which calls the first one. The result is a RegularPolygon with the specified value of nsides, 6, the default value of radius, 50, and the default color, GRAY.\nWhen writing constructors, it’s a good idea to validate the values you get as arguments. Doing so prevents run-time errors later in the program, which makes the code easier to debug.\nFor RegularPolygon, the number of sides should be at least three, the radius should be greater than zero, and the color should not be null. We can add the following lines to the first constructor:\npublic RegularPolygon(int nsides, int radius, Color color) {\n\n    // validate the arguments\n    if (nsides &lt; 3) {\n        throw new IllegalArgumentException(\"invalid nsides\");\n    }\n    if (radius &lt;= 0) {\n        throw new IllegalArgumentException(\"invalid radius\");\n    }\n    if (color == null) {\n        throw new NullPointerException(\"invalid color\");\n    }\n\n    // the rest of the method is omitted\nIn this example, we throw an exception to indicate that one of the arguments is invalid. By default, these exceptions terminate the program and display an error message along with the stack trace.\nBecause we added this code to the most general constructor, we don’t have to add it to the others.",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Advanced Topics</span>"
    ]
  },
  {
    "objectID": "ch17.html#sec:drawing",
    "href": "ch17.html#sec:drawing",
    "title": "17  Advanced Topics",
    "section": "17.5 An Initial Drawing",
    "text": "17.5 An Initial Drawing\nNow that we have DrawablePolygon and RegularPolygon, let’s take them for a test drive. We’ll need a Canvas for drawing them, so we define a new class, Drawing, that extends Canvas:\npublic class Drawing extends Canvas {\n    private ArrayList&lt;DrawablePolygon&gt; list;\n\n    public Drawing(int width, int height) {\n        setSize(width, height);\n        setBackground(Color.WHITE);\n        list = new ArrayList&lt;DrawablePolygon&gt;();\n    }\npublic void add(DrawablePolygon dp) {\n        list.add(dp);\n    }\n\n    public void paint(Graphics g) {\n        for (DrawablePolygon dp : list) {\n            dp.draw(g);\n        }\n    }\n}\nThe Drawing class has an ArrayList of DrawablePolygon objects. When we create a Drawing object, the list is initially empty. The add method takes a DrawablePolygon and adds it to the list.\nDrawing overrides the paint method that it inherits from Canvas. paint loops through the list of DrawablePolygon objects and invokes draw on each one.\nHere is an example that creates three RegularPolygon objects and draws them. Figure 17.2 shows the result.\npublic static void main(String[] args) {\n\n    // create some regular polygons\n    DrawablePolygon p1 = new RegularPolygon(3, 50, Color.GREEN);\n    DrawablePolygon p2 = new RegularPolygon(6, 50, Color.ORANGE);\n    DrawablePolygon p3 = new RegularPolygon(360, 50, Color.BLUE);\n\n    // move them out of the corner\n    p1.translate(100, 80);\n    p2.translate(250, 120);\n    p3.translate(400, 160);\n\n    // create drawing, add polygons\n    Drawing drawing = new Drawing(500, 250);\n    drawing.add(p1);\n    drawing.add(p2);\n    drawing.add(p3);\n// set up the window frame\n    JFrame frame = new JFrame(\"Drawing\");\n    frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n    frame.add(drawing);\n    frame.pack();\n    frame.setVisible(true);\n}\n\n\n\n\n\n\n\nInitial drawing of three RegularPolygon objects.\n\n\nThe first block of code creates RegularPolygon objects with 3, 6, and 360 sides. As you can see, a polygon with 360 sides is a pretty good approximation of a circle.\nThe second block of code translates the polygons to different locations. The third block of code creates the Drawing and adds the polygons to it. And the fourth block of code creates a JFrame, adds the Drawing to it, and displays the result.\nMost of these pieces should be familiar, but one part of this program might surprise you. When we create the RegularPolygon objects, we assign them to DrawablePolygon variables. It might not be obvious why that’s legal.\nRegularPolygon extends DrawablePolygon, so every RegularPolygon object is also a DrawablePolygon. The parameter of Drawing.add has to be a DrawablePolygon, but it can be any type of DrawablePolygon, including RegularPolygon and other subclasses.\nThis design is an example of polymorphism, a fancy word that means “having many forms”. Drawing.add is a polymorphic method, because the parameter can be one of many types. And the ArrayList in Drawing is a polymorphic data structure, because the elements can be different types.",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Advanced Topics</span>"
    ]
  },
  {
    "objectID": "ch17.html#blinking-polygons",
    "href": "ch17.html#blinking-polygons",
    "title": "17  Advanced Topics",
    "section": "17.6 Blinking Polygons",
    "text": "17.6 Blinking Polygons\nAt this point, we have a simple program that draws polygons; we can make it more fun by adding animation. Chapter 15 introduced the idea of simulating time steps. Here’s a loop that runs the animation:\nwhile (true) {\n    drawing.step();\n    try {\n        Thread.sleep(1000 / 30);\n    } catch (InterruptedException e) {\n        // do nothing\n    }\n}\nEach time through the loop, we call step to update the Drawing. Then we sleep with a delay calculated to update about 30 times per second.\nHere’s what the step method of Drawing looks like:\npublic void step() {\n    for (DrawablePolygon dp : list) {\n        dp.step();\n    }\n    repaint();\n}\nIt invokes step on each DrawablePolygon in the list and then repaints (clears and redraws) the canvas.\nIn order for this code to compile, we need DrawablePolygon to provide a step method. Here’s a version that doesn’t do anything; we’ll override it in subclasses:\npublic void step() {\n    // do nothing\n}\nNow let’s design a new type of polygon that blinks. We’ll define a class named BlinkingPolygon that extends RegularPolygon and adds two more attributes: visible, which indicates whether the polygon is visible, and count, which counts the number of time steps since the last blink:\npublic class BlinkingPolygon extends RegularPolygon {\n    protected boolean visible;\n    protected int count;\n\n    public BlinkingPolygon(int nsides, int radius, Color c) {\n        super(nsides, radius, c);\n        visible = true;\n        count = 0;\n    }\n\n    public void draw(Graphics g) {\n        if (visible) {\n            super.draw(g);\n        }\n    }\n\n    public void step() {\n        count++;\n        if (count == 10) {\n            visible = !visible;\n            count = 0;\n        }\n    }\n}\nThe constructor uses super to call the RegularPolygon constructor. Then it initializes visible and count. Initially, the BlinkingPolygon is visible.\nThe draw method draws the polygon only if it is visible. It uses super to call draw in the parent class. But the parent class is RegularPolygon, which does not provide a draw method. In this case, super invokes draw from the DrawablePolygon class.\nThe step method increments count. Every 10 time steps, it toggles visible and resets count to 0.",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Advanced Topics</span>"
    ]
  },
  {
    "objectID": "ch17.html#interfaces",
    "href": "ch17.html#interfaces",
    "title": "17  Advanced Topics",
    "section": "17.7 Interfaces",
    "text": "17.7 Interfaces\nYou might be getting tired of polygons at this point. Can’t we draw anything else? Of course we can, but Drawing is currently based on DrawablePolygon. To draw other types of objects, we have to generalize the code.\nThe Drawing class does essentially three things: (1) it maintains a list of objects, (2) it invokes the draw method on each object, and (3) it invokes the step method on each object.\nSo here’s one way we could make the code more general:\n\nDefine a new superclass, which we call Actor, that provides the two methods needed by Drawing:\npublic class Actor {\n    public void draw(Graphics g) {\n        // do nothing\n    }\n    public void step() {\n        // do nothing\n    }\n}\nIn the Drawing class, replace DrawablePolygon with Actor.\nAny class that we want to draw must now extend Actor.\n\nThere’s just one problem: DrawablePolygon already extends Polygon, and classes can extend only one superclass. Also, the Actor class seems pointless, since the methods it defines don’t do anything.\nJava provides another mechanism for inheritance that solves these problems. We can define Actor as an interface instead of a class, like this:\npublic interface Actor {\n    void draw(Graphics g);\n    void step();\n}\nLike a class definition, an interface definition contains methods. But it contains only the declarations of the methods, not their implementations.\nLike an abstract class, an interface specifies methods that must be provided by subclasses. The difference is that an abstract class can implement some methods; an interface cannot.\nAll interface methods are public by default, since they are intended to be used by other classes. So there is no need to declare them as public.\nTo inherit from an interface, you use the keyword implements instead of extends. Here’s a version of DrawablePolygon that extends Polygon and implements Actor. So it inherits methods from Polygon, and it is required to provide the methods in Actor; namely draw and step:\npublic class DrawablePolygon extends Polygon implements Actor {\n    // rest of the class omitted\n}\nIn terms of inheritance, DrawablePolygon is both a Polygon and an Actor. So the following assignments are legal:\nPolygon p1 = new DrawablePolygon();\nActor a2 = new DrawablePolygon();\nAnd the same is true for subclasses of DrawablePolygon; these assignments are legal too:\nPolygon p2 = new RegularPolygon(5, 50, Color.YELLOW);\nActor a2 = new RegularPolygon(5, 50, Color.YELLOW);\nInterfaces are another example of polymorphism. a1 and a2 are the same type of variable, but they refer to objects with different types. And similarly with p1 and p2.\nClasses may extend only one superclass, but they may implement as many interfaces as needed. Java library classes often implement multiple interfaces.",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Advanced Topics</span>"
    ]
  },
  {
    "objectID": "ch17.html#event-listeners",
    "href": "ch17.html#event-listeners",
    "title": "17  Advanced Topics",
    "section": "17.8 Event Listeners",
    "text": "17.8 Event Listeners\nNow that our Drawing is based on Actor instead of DrawablePolygon, we can draw other types of graphics. Here is the beginning of a class that reads an image from a file and shows the image moving across the canvas. The class is called Sprite because a moving image is sometimes called a sprite, in the context of computer graphics:\npublic class Sprite implements Actor, KeyListener {\n    private int xpos;\n    private int ypos;\n    private int dx;\n    private int dy;\n    private Image image;\n\n    public Sprite(String path, int xpos, int ypos) {\n        this.xpos = xpos;\n        this.ypos = ypos;\n        try {\n            this.image = ImageIO.read(new File(path));\n        } catch (IOException exc) {\n            exc.printStackTrace();\n        }\n    }\n}\nThe instance variables xpos and ypos represent the location of the sprite. dx and dy represent the velocity of the sprite in the \\(x\\) and \\(y\\) directions.\nThe constructor takes as parameters the name of a file and the initial position. It uses ImageIO, from the javax.imageio package, to read the file. If an error occurs during reading, an IOException is caught, and the program displays the stack trace for debugging.\nSprite implements two interfaces: Actor and KeyListener. Actor requires that we provide draw and step methods:\npublic void draw(Graphics g) {\n        g.drawImage(image, xpos, ypos, null);\n    }\n\n    public void step() {\n        xpos += dx;\n        ypos += dy;\n    }\nThe draw method draws the image at the sprite’s current position. The step method changes the position based on dx and dy, which are initially zero.\nKeyListener is an interface for receiving keyboard events, which means we can detect and respond to key presses. A class that implements KeyListener has to provide the following methods:\n\nvoid keyPressed(KeyEvent e)\nInvoked when a key has been “pressed”. This method is invoked repeatedly while a key is being held down.\nvoid keyReleased(KeyEvent e)\nInvoked when a key has been “released”, meaning it is no longer down.\nvoid keyTyped(KeyEvent e)\nInvoked when a key has been “typed”, which generally means it has been both pressed and released.\n\nThese methods get invoked when the user presses and releases any key. They take a KeyEvent object as a parameter, which specifies which key was pressed, released, or typed.\nWe can use these methods to design a simple animation using the arrow keys. When the user presses up or down, the sprite will move up or down. When the user presses left or right, the sprite will move left or right.\nHere’s an implementation of keyPressed that uses a switch statement to test which arrow key was pressed and sets dx or dy accordingly. (There is no default branch, so we ignore all other keys.)\npublic void keyPressed(KeyEvent e) {\n    switch (e.getKeyCode()) {\n        case KeyEvent.VK_UP:\n            dy = -5;\n            break;\n        case KeyEvent.VK_DOWN:\n            dy = +5;\n            break;\n        case KeyEvent.VK_LEFT:\n            dx = -5;\n            break;\n        case KeyEvent.VK_RIGHT:\n            dx = +5;\n            break;\n    }\n}\nThe values of dx and dy determine how much the sprite moves each time step is invoked. While the user holds down an arrow key, the sprite will move at a constant speed.\nHere’s an implementation of keyReleased that runs when the user releases the key:\npublic void keyReleased(KeyEvent e) {\n    switch (e.getKeyCode()) {\n        case KeyEvent.VK_UP:\n        case KeyEvent.VK_DOWN:\n            dy = 0;\n            break;\n        case KeyEvent.VK_LEFT:\n        case KeyEvent.VK_RIGHT:\n            dx = 0;\n            break;\n    }\n}\nWhen the user releases the key, keyReleased sets dx or dy to 0, so the sprite stops moving in that direction.\nWe don’t need the keyTyped method for this example, but it’s required by the interface; if we don’t provide one, the compiler will complain. So we provide an implementation that does nothing:\npublic void keyTyped(KeyEvent e) {\n    // do nothing\n}\nNow, here’s the code we need to create a Sprite, add it to a Drawing, and configure it as a KeyListener:\nSprite sprite = new Sprite(\"face-smile.png\", 25, 150);\ndrawing.add(sprite);\ndrawing.addKeyListener(sprite);\ndrawing.setFocusable(true);\nRecall that the add method is one that we wrote in Section 17.5. It adds an Actor to the list of objects to be drawn.\nThe addKeyListener method is inherited from Canvas. It adds a KeyListener to the list of objects that will receive key events.\nIn graphical applications, key events are sent to components only when they have the keyboard focus. The setFocusable method ensures that drawing will have the focus initially, without the user having to click it first.",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Advanced Topics</span>"
    ]
  },
  {
    "objectID": "ch17.html#timers",
    "href": "ch17.html#timers",
    "title": "17  Advanced Topics",
    "section": "17.9 Timers",
    "text": "17.9 Timers\nNow that you know about interfaces and events, we can show you a better way to create animations. Previously, we implemented the animation loop by using while (true) and Thread.sleep. Java provides a Timer class (in javax.swing) that encapsulates this behavior.\nA Timer is useful for executing code at regular intervals. The constructor for Timer takes two parameters:\n\nint delay                 // milliseconds between events\nActionListener listener   // for handling timer events\n\nThe ActionListener interface requires only one method, actionPerformed. This is the method the Timer invokes after the given delay.\nUsing a Timer, we can reorganize the code in main by defining a class that implements ActionListener:\npublic class VideoGame implements ActionListener {\n    private Drawing drawing;\n\n    public VideoGame() {\n        Sprite sprite = new Sprite(\"face-smile.png\", 50, 50);\n        drawing = new Drawing(800, 600);\n        drawing.add(sprite);\n        drawing.addKeyListener(sprite);\n        drawing.setFocusable(true);\n\n        JFrame frame = new JFrame(\"Video Game\");\n        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n        frame.add(drawing);\n        frame.pack();\n        frame.setVisible(true);\n    }\n\n    public void actionPerformed(ActionEvent e) {\n        drawing.step();\n    }\n\n    public static void main(String[] args) {\n        VideoGame game = new VideoGame();\n        Timer timer = new Timer(33, game);\n        timer.start();\n    }\n}\nThe main method constructs a VideoGame object, which creates a Sprite, a Drawing, and a JFrame. Then it constructs a Timer object and starts the timer. Every 33 milliseconds, the Timer invokes actionPerformed, which invokes step on the Drawing.\nDrawing.step invokes step on all of its Actor objects, which causes them to update their position, color, or other aspects of their appearance. The Drawing.step then repaints the Canvas, and the time step is done.\nAt this point, you have all of the elements you need to write your own video games. In the exercises at the end of this chapter, we have some suggestions for getting started.\nWe hope this final chapter has been a helpful summary of topics presented throughout the book, including input and output, decisions and loops, classes and methods, arrays and objects, inheritance, and graphics. Congratulations on making it to the end!",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Advanced Topics</span>"
    ]
  },
  {
    "objectID": "ch17.html#vocabulary",
    "href": "ch17.html#vocabulary",
    "title": "17  Advanced Topics",
    "section": "17.10 Vocabulary",
    "text": "17.10 Vocabulary\n\ngeneralization:\n\nThe process of extracting common code from two or more classes and moving it into a superclass.\n\nspecialization:\n\nExtending a class to add new attributes or methods, or to modify existing behavior.\n\npolymorphism:\n\nA language feature that allows objects to be assigned to variables of related types.\n\nsprite:\n\nA computer graphic that may be moved or otherwise manipulated on the screen.",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Advanced Topics</span>"
    ]
  },
  {
    "objectID": "ch17.html#exercises",
    "href": "ch17.html#exercises",
    "title": "17  Advanced Topics",
    "section": "17.11 Exercises",
    "text": "17.11 Exercises\nThe code for this chapter is in the ch17 directory of ThinkJavaCode2. See page  for instructions on how to download the repository. Before you start the exercises, we recommend that you compile and run the examples.\nThe following exercises give you a chance to practice using the features in this chapter by extending the example code.\n\nExercise 17.1. The Polygon class does not provide a toString method; it inherits the default toString from java.lang.Object, which includes only the class’s name and memory location. Write a more useful toString method for DrawablePolygon that includes its \\((x, y)\\) points.\n\n\nExercise 17.2. Write a class MovingPolygon that extends RegularPolygon and implements Actor. It should have instance variables posx and posy that specify its position, and dx and dy that specify its velocity (and direction). During each time step, it should update its position. If it gets to the edge of the Drawing, it should reverse direction by changing the sign of dx or dy.\n\n\nExercise 17.3. Modify the VideoGame class so it displays a Sprite and a MovingPolygon (from the previous exercise). Add code that detects collisions between Actor objects in the same Drawing, and invoke a method on both objects when they collide.\n**Hint:* You might want to add a method to the Actor interface, guaranteeing that all Actor objects know how to handle collisions.*\n\n\nExercise 17.4. Java provides other event listeners that you can implement to make your programs interactive. For example, the interfaces MouseListener, MouseMotionListener, and MouseWheelListener allow you to respond to mouse input. Use the MouseListener interface to implement an Actor that can respond to mouse clicks.",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Advanced Topics</span>"
    ]
  },
  {
    "objectID": "appa.html",
    "href": "appa.html",
    "title": "18  Tools",
    "section": "",
    "text": "18.1 Installing DrJava\nThe easiest way to start programming in Java is to use a website that compiles and runs Java code in the browser. Examples include https://repl.it/, https://trinket.io/, https://jdoodle.com/, and others.\nIf you are unable to install software on your computer (which is often the case in public schools and Internet cafés), you can use these online development environments for almost everything in this book.\nBut if you want to compile and run Java programs on your own computer, you will need the following:\nThe JDK we recommend is OpenJDK, an open source implementation of Java SE (Standard Edition). The IDE we recommend is DrJava, which is an open source development environment written in Java (see Figure 18.1).\nTo install OpenJDK, visit https://adoptopenjdk.net. Download and run the installer for your operating system.\nTo install DrJava, visit http://drjava.org/ and download the JAR file. We recommend that you save it to your Desktop folder or another convenient location. Simply double-click the JAR file to run DrJava. Refer to the DrJava documentation (http://drjava.org/docs/quickstart/) for more details.\nWhen running DrJava for the first time, we recommend you change three settings from the Edit \\(&gt;\\) Preferences menu under Miscellaneous: set the Indent Level to 4, check the Automatically Close Block Comments box, and uncheck the Keep Emacs-style Backup Files box.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Tools</span>"
    ]
  },
  {
    "objectID": "appa.html#drjava",
    "href": "appa.html#drjava",
    "title": "18  Tools",
    "section": "",
    "text": "The Java Development Kit (JDK), which includes the compiler, the Java Virtual Machine (JVM) that interprets the compiled byte code, and other tools such as Javadoc.\nA text editor such as Atom, Notepad++, or Sublime Text, and/or an IDE such as DrJava, Eclipse, jGrasp, or NetBeans.\n\n\n\n\n\n\n\n\n\nDrJava editing the Hello World program.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Tools</span>"
    ]
  },
  {
    "objectID": "appa.html#interactions",
    "href": "appa.html#interactions",
    "title": "18  Tools",
    "section": "18.2 DrJava Interactions",
    "text": "18.2 DrJava Interactions\nOne of the most useful features of DrJava is the “Interactions” pane at the bottom of the window. It provides the ability to try out code quickly, without having to write a class definition and save/compile/run the program. Figure 18.2 shows an example.\n\n\n\n\n\nThe Interactions pane in DrJava.\n\n\nThere is one subtle detail to note when using the Interactions pane. If you don’t end an expression (or statement) with a semicolon, DrJava automatically displays its value. Notice in Figure 18.2 that the variable declarations end with semicolons, but the logic expressions in the following lines do not. This feature saves you from having to type System.out.println every time.\nWhat’s nice about this feature is that you don’t have to create a new class, declare a main method, write arbitrary expressions inside System.out.println statements, save the source file, and get all of your code to compile in advance. Also, you can press the up/down arrows on the keyboard to repeat previous commands and experiment with incremental differences.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Tools</span>"
    ]
  },
  {
    "objectID": "appa.html#commandline",
    "href": "appa.html#commandline",
    "title": "18  Tools",
    "section": "18.3 Command-Line Interface",
    "text": "18.3 Command-Line Interface\nOne of the most powerful and useful skills you can learn is how to use the command-line interface, also called the “terminal”. The command line is a direct interface to the operating system. It allows you to run programs, manage files and directories, and monitor system resources. Many advanced tools, both for software development and general-purpose computing, are available only at the command line.\nMany good tutorials are available online for learning the command line for your operating system; just search the web for “command line tutorial”. On Unix systems like Linux and macOS, you can get started with just four commands: change the working directory (cd), list directory contents (ls), compile Java programs (javac), and run Java programs (java).\nFigure 18.3 shows an example in which the Hello.java source file is stored in the Desktop directory. After changing to that location and listing the files, we use the javac command to compile Hello.java. Running ls again, we see that the compiler generated a new file, Hello.class, which contains the byte code. We run the program by using the java command, which displays the output on the following line.\n\n\n\n\n\nCompiling and running Hello.java from the command line.\n\n\nNote that the javac command requires a filename (or multiple source files separated by spaces), whereas the java command requires a single class name. If you use DrJava, it runs these commands for you behind the scenes and displays the output in the Interactions pane.\nTaking time to learn this efficient and elegant way of interacting with the operating system will make you more productive. People who don’t use the command line don’t know what they’re missing.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Tools</span>"
    ]
  },
  {
    "objectID": "appa.html#cltesting",
    "href": "appa.html#cltesting",
    "title": "18  Tools",
    "section": "18.4 Command-Line Testing",
    "text": "18.4 Command-Line Testing\nAs described in Section 1.9, it’s more effective to program and debug your code little by little than to attempt writing everything all at once. And after you’ve completed programming an algorithm, it’s important to test that it works correctly on a variety of inputs.\nThroughout the book, we illustrate techniques for testing your programs. Most, if not all, testing is based on a simple idea: does the program do what we expect it to do? For simple programs, it’s not difficult to run them several times and see what happens. But at some point, you will get tired of typing the same test cases over and over.\nWe can automate the process of entering input and comparing expected output with actual output using the command line. The basic idea is to store the test cases in plain text files and trick Java into thinking they are coming from the keyboard. Here are step-by-step instructions:\n\nMake sure you can compile and run the Convert.java example in the ch03 directory of ThinkJavaCode2. (See page  for instructions on how to download the repository.)\nIn the same directory as Convert.java, create a plain text file named test.in (“in” is for “input”). Enter the following line and save the file:\n193.04\nCreate a second plain text file named test.exp (“exp” is for “expected”). Enter the following line and save the file:\n193.04 cm = 6 ft, 4 in\nOpen a terminal, and change to the directory with these files. Run the following command to test the program:\njava Convert &lt; test.in &gt; test.out\n\nOn the command line, &lt; and &gt; are redirection operators. The first one redirects the contents of test.in to System.in, as if it were entered from the keyboard. The second one redirects the contents of System.out to a new file test.out, much like a screen capture. In other words, the test.out file contains the output of your program.\nBy the way, it’s perfectly okay to compile your programs in DrJava (or another environment) and run them from the command line. Knowing both techniques allows you to use the right tool for the job.\n\n\n\n\n\nUsing meld to compare expected output with the actual output.\n\n\nAt this point, we just need to compare the contents test.out with test.exp. If the files are the same, then the program outputted what we expected it to output. If not, then we found a bug, and we can use the output to begin debugging our program. Fortunately, there’s a simple way to compare files on the command line:\ndiff test.exp test.out\nThe diff utility summarizes the differences between two files. If there are no differences, it displays nothing, which in our case is what we want. If the expected output differs from the actual output, we need to continue debugging. Usually, the program is at fault, and diff provides some insight about what is broken. But there’s also a chance that we have a correct program and the expected output is wrong.\nInterpreting the results from diff can be confusing, but fortunately many graphical tools can show the differences between two files. For example, on Windows you can install WinMerge, on macOS you can use opendiff (which comes with Xcode), and on Linux there’s meld, shown in Figure 18.4.\nRegardless of what tool you use, the goal is the same. Debug your program until the actual output is identical to the expected output.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Tools</span>"
    ]
  },
  {
    "objectID": "appa.html#checkstyle",
    "href": "appa.html#checkstyle",
    "title": "18  Tools",
    "section": "18.5 Running Checkstyle",
    "text": "18.5 Running Checkstyle\nCheckstyle is a command-line tool that can be used to determine if your source code follows a set of style rules. It also checks for common programming mistakes, such as class and method design problems.\nYou can download the latest version as a JAR file from https://checkstyle.sourceforge.io/. To run Checkstyle, move (or copy) the JAR file to the same directory as your program. Open a terminal in that location, and run the following command:\njava -jar checkstyle-*-all.jar -c /google_checks.xml *.java\nThe characters are wildcards that match whatever version of Checkstyle you have and whatever Java source files are present. The output indicates the file and line number of each problem. This example refers to a method beginning on line 93, column 5 of Hello.java:\nHello.java:93:5: Missing a Javadoc comment\nThe file /google_checks.xml is inside the JAR file and represents most of Google’s style rules. You can alternatively use /sun_checks.xml or provide your own configuration file. See Checkstyle’s website for more information.\nIf you apply Checkstyle to your source code often, you will likely internalize good style habits over time. But there are limits to what automatic style checkers can do. In particular, they can’t evaluate the quality of your comments, the meaning of your variable names, or the structure of your algorithms.\nGood comments make it easier for experienced developers to identify errors in your code. Good variable names communicate the intent of your program and how the data is organized. And good programs are designed to be efficient and demonstrably correct.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Tools</span>"
    ]
  },
  {
    "objectID": "appa.html#debugger",
    "href": "appa.html#debugger",
    "title": "18  Tools",
    "section": "18.6 Tracing with a Debugger",
    "text": "18.6 Tracing with a Debugger\nA great way to visualize the flow of execution, including how parameters and arguments work, is to use a debugger. Most debuggers make it possible to do the following:\n\nSet a breakpoint, a line where you want the program to pause.\nStep through the code one line at a time and watch what it does.\nCheck the values of variables and see when and how they change.\n\nFor example, open any program in DrJava and move the cursor to the first line of main. Press Ctrl+B to toggle a breakpoint on the current line; it should now be highlighted in red. Press Ctrl+Shift+D to turn on “Debug Mode”; a new pane should appear at the bottom of the window. These commands are also available from the Debugger menu, in case you forget the shortcut keys.\nWhen you run the program, execution pauses at the first breakpoint. The debugging pane displays the call stack, with the current method on top of the stack, as shown in Figure 18.5. You might be surprised to see how many methods were called before the main method!\n\n\n\n\n\nThe DrJava debugger. Execution is currently paused on the first line of printTwice. There is a breakpoint on the first line of main.\n\n\nTo the right are several buttons that allow you to step through the code at your own pace. You can also click Automatic Trace to watch DrJava run your code one line at a time.\nUsing a debugger is like having the computer proofread your code out loud. When the program is paused, you can examine (or even change) the value of any variable by using the Interactions pane.\nTracing allows you to follow the flow of execution and see how data passes from one method to another. You might expect the code do one thing, but then the debugger shows it doing something else. At that moment, you gain insight about what may be wrong with the code.\nYou can edit your code while debugging it, but we don’t recommend it. If you add or delete multiple lines of code while the program is paused, the results can be confusing.\nSee http://drjava.org/docs/user/ch09.html for more information about using the debugger feature of DrJava.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Tools</span>"
    ]
  },
  {
    "objectID": "appa.html#JUnit",
    "href": "appa.html#JUnit",
    "title": "18  Tools",
    "section": "18.7 Testing with JUnit",
    "text": "18.7 Testing with JUnit\nWhen beginners start writing methods, they usually test them by invoking them from main and checking the results by hand. For example, to test fibonacci from Section [fibonacci], we could write this:\npublic static void main(String[] args) {\n    if (fibonacci(1) != 1) {\n        System.err.println(\"fibonacci(1) is incorrect\");\n    }\n    if (fibonacci(2) != 1) {\n        System.err.println(\"fibonacci(2) is incorrect\");\n    }\n    if (fibonacci(3) != 2) {\n        System.err.println(\"fibonacci(3) is incorrect\");\n    }\n}\nThis test code is self-explanatory, but it’s longer than it needs to be, and it doesn’t scale very well. In addition, the error messages provide limited information. For cases where we know the right answer, we can do better by writing unit tests.\nJUnit (https://junit.org/) is a common testing tool for Java programs. To use it, you have to create a test class that contains test methods.\nFor example, suppose that the fibonacci method belongs to a class named Series. Here is a corresponding JUnit[^2] test class and test method:\nimport junit.framework.TestCase;\n\npublic class SeriesTest extends TestCase {\n\n    public void testFibonacci() {\n        assertEquals(1, Series.fibonacci(1));\n        assertEquals(1, Series.fibonacci(2));\n        assertEquals(2, Series.fibonacci(3));\n    }\n}\nThis example uses the keyword extends, which indicates that the new class, SeriesTest, is based on an existing class, TestCase. The TestCase class is imported from the package junit.framework.\nThe names in this example follow convention: if the name of your class is Something, the name of the test class should be SomethingTest. And if there is a method in Something named someMethod, there should be a method in SomethingTest named testSomeMethod.\nMany development environments can generate test classes and test methods automatically. In DrJava, you can select New JUnit Test Case from the File menu to generate an empty test class.\nassertEquals is provided by the TestCase class. It takes two arguments and checks whether they are equal. If so, it does nothing; otherwise, it displays a detailed error message. The first argument is the expected value, which we consider correct, and the second argument is the actual value we want to check. If they are not equal, the test fails.\nUsing assertEquals is more concise than writing your own if statements and System.err messages. JUnit provides additional assert methods, such as assertNull, assertSame, and assertTrue, which can be used to design a variety of tests.\nTo run JUnit directly from DrJava, click the Test button on the toolbar. If all your test methods pass, you will see a green bar in the lower-right corner. Otherwise, DrJava will take you directly to the first assertion that failed.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Tools</span>"
    ]
  },
  {
    "objectID": "appa.html#vocabulary",
    "href": "appa.html#vocabulary",
    "title": "18  Tools",
    "section": "18.8 Vocabulary",
    "text": "18.8 Vocabulary\n\nIDE:\n\nAn “integrated development environment” that includes tools for editing, compiling, and debugging programs.\n\nJDK:\n\nThe “Java Development Kit”, which contains the compiler, Javadoc, and other tools.\n\nJVM:\n\nThe “Java Virtual Machine”, which interprets the compiled byte code.\n\ntext editor:\n\nA program that edits plain text files, the format used by most programming languages.\n\nJAR:\n\nA “Java Archive”, which is essentially a ZIP file containing classes and other resources.\n\ncommand-line interface:\n\nA means of interacting with the computer by issuing commands in the form of successive lines of text.\n\nredirection operator:\n\nA command-line feature that substitutes System.in and/or System.out with a plain text file.\n\nwildcard:\n\nA command-line feature that allows you to specify a pattern of filenames by using the character.\n\ndebugger:\n\nA tool that allows you to run one statement at a time and see the contents of variables.\n\nbreakpoint:\n\nA line of code at which the debugger will pause a running program.\n\ncall stack:\n\nThe history of method calls and where to resume execution after each method returns.\n\nunit test:\n\nCode that exercises a single method of a program, testing for correctness and/or efficiency.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Tools</span>"
    ]
  },
  {
    "objectID": "appb.html",
    "href": "appb.html",
    "title": "19  Javadoc",
    "section": "",
    "text": "19.1 Reading Documentation\nAs an example, let’s look at the documentation for Scanner, a class we first used in Section 3.2. You can find the documentation quickly by doing a web search for “Java Scanner”. Figure 19.1 shows a screenshot of the page.\nDocumentation for other classes uses a similar format. The first line is the package that contains the class, such as java.util. The second line is the name of the class. The “All Implemented Interfaces” section lists some of the functionality a Scanner has.\nThe next section of the documentation is a narrative that explains the purpose of the class and includes examples of how to use it. This text can be difficult to read, because it may use terms you have not yet learned. But the examples are often very useful. A good way to get started with a new class is to paste the examples into a test file and see if you can compile and run them.\nOne of the examples shows how you can use a Scanner to read input from a String instead of System.in:\nAfter the narrative, code examples, and other details, you will find the following tables:\nFor example, here is the summary information for nextInt:\nThe first line is the method’s signature, which specifies the name of the method and its parameters (none). The type it returns (int) is not part of the signature. The next line is a short description of what it does.\nThe “Method Detail” explains more:\nThe “Returns” section describes the result when the method succeeds. In contrast, the “Throws” section describes possible errors and exceptions that may occur. Exceptions are said to be thrown, like a referee throwing a flag, or like a toddler throwing a fit.\nIt might take you some time to get comfortable reading documentation and learning which parts to ignore. But it’s worth the effort. Knowing what’s available in the library helps you avoid reinventing the wheel. And a little bit of documentation can save you a lot of debugging.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Javadoc</span>"
    ]
  },
  {
    "objectID": "appb.html#reading-documentation",
    "href": "appb.html#reading-documentation",
    "title": "19  Javadoc",
    "section": "",
    "text": "The documentation for Scanner.\n\n\n\n\n\nString input = \"1 fish 2 fish red fish blue fish\";\nScanner s = new Scanner(input);\n\n\nConstructor Summary:\n\nWays of creating, or constructing, a Scanner.\n\nMethod Summary:\n\nThe list of methods that the Scanner class provides.\n\nConstructor Detail:\n\nMore information about how to create a Scanner.\n\nMethod Detail:\n\nMore information about each method.\n\n\n\npublic int nextInt()\nScans the next token of the input as an int.\n\n\npublic int nextInt()\nScans the next token of the input as an int.\n\nAn invocation of this method of the form nextInt() behaves in\nexactly the same way as the invocation nextInt(radix), where\nradix is the default radix of this scanner.\n\nReturns:\nthe int scanned from the input\n\nThrows:\nInputMismatchException - if the next token does not match\n    the Integer regular expression, or is out of range\nNoSuchElementException - if input is exhausted\nIllegalStateException - if this scanner is closed",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Javadoc</span>"
    ]
  },
  {
    "objectID": "appb.html#writing-documentation",
    "href": "appb.html#writing-documentation",
    "title": "19  Javadoc",
    "section": "19.2 Writing Documentation",
    "text": "19.2 Writing Documentation\nAs you benefit from reading good documentation, you should “pay it forward” by writing good documentation.\nJavadoc scans your source files looking for documentation comments, also known as “Javadoc comments”. They begin with /** (two stars) and end with / (one star). Anything in between is considered part of the documentation.\nHere’s a class definition with two Javadoc comments, one for the Goodbye class and one for the main method:\n/**\n * Example program that demonstrates print vs println.\n */\npublic class Goodbye {\n\n    /**\n     * Prints a greeting.\n     */\n    public static void main(String[] args) {\n        System.out.print(\"Goodbye, \");  // note the space\n        System.out.println(\"cruel world\");\n    }\n}\nThe class comment explains the purpose of the class. The method comment explains what the method does.\nNotice that this example also has an end-of-line comment (//). In general, these comments are short phrases that help explain complex parts of a program. They are intended for other programmers reading and maintaining the source code.\nIn contrast, Javadoc comments are longer, usually complete sentences. They explain what each method does, but they omit details about how the method works. And they are intended for people who will use the methods without looking at the source code.\nAppropriate comments and documentation are essential for making source code readable. And remember that the person most likely to read your code in the future, and appreciate good documentation, is you.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Javadoc</span>"
    ]
  },
  {
    "objectID": "appb.html#javadoc-tags",
    "href": "appb.html#javadoc-tags",
    "title": "19  Javadoc",
    "section": "19.3 Javadoc Tags",
    "text": "19.3 Javadoc Tags\nIt’s generally a good idea to document each class and method, so that other programmers can understand what they do without having to read the code.\nTo organize the documentation into sections, Javadoc supports optional tags that begin with the at sign (@). For example, we can use @author and @version to provide information about the class:\n/**\n * Utility class for extracting digits from integers.\n *\n * @author Chris Mayfield\n * @version 1.0\n */\npublic class DigitUtil {\nDocumentation comments should begin with a description of the class or method, followed by the tags. These two sections are separated by a blank line (not counting the ).\nFor methods, we can use @param and @return to provide information about parameters and return values:\n/**\n * Tests whether x is a single digit integer.\n *\n * @param x the integer to test\n * @return true if x has one digit, false otherwise\n */\npublic static boolean isSingleDigit(int x) {\nFigure 19.2 shows part of the resulting HTML page generated by Javadoc. Notice the relationship between the Javadoc comment (in the source code) and the resulting documentation (in the HTML page).\n\n\n\n\n\nHTML documentation for isSingleDigit.\n\n\nWhen writing parameter comments, do not include a hyphen (-) after the @param tag. Otherwise, you will have two hyphens in the resulting HTML documentation.\nNotice also that the @return tag should not specify the type of the method. Comments like @return boolean are not useful, because you already know the return type from the method’s signature.\nMethods with multiple parameters should have separate @param tags that describe each one. Void methods should have no @return tag, since they do not return a value. Each tag should be on its own line in the source code.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Javadoc</span>"
    ]
  },
  {
    "objectID": "appb.html#example-source-file",
    "href": "appb.html#example-source-file",
    "title": "19  Javadoc",
    "section": "19.4 Example Source File",
    "text": "19.4 Example Source File\nNow let’s take a look at a more complete example. The code for this section is in the appb directory of ThinkJavaCode2. See page  for instructions on how to download the repository.\nProfessional-grade source files often begin with a copyright statement. This text spans multiple lines, but it is not part of the documentation. So we use a multiline comment (/*) rather than a documentation comment (/**). Our example source file, Convert.java, includes the MIT License (https://opensource.org/licenses/MIT):\n\n/*\n * Copyright (c) 2019 Allen Downey and Chris Mayfield\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nImport statements generally follow the copyright text. After that, we can define the class itself and begin writing the documentation (/**):\nimport java.util.Scanner;\n\n/**\n * Methods for converting to/from the metric system.\n *\n * @author Allen Downey\n * @author Chris Mayfield\n * @version 6.1.5\n */\npublic class Convert {\nA common mistake that beginners make is to put import statements between the documentation and the public class line. Doing so separates the documentation from the class itself. To avoid this issue, always make the end of the comment (the /) “touch” the word public.\nThis class has two constants and three methods. The constants are self-explanatory, so there is no need to write documentation for them:\npublic static final double CM_PER_INCH = 2.54;\n\npublic static final int IN_PER_FOOT = 12;\nThe methods, on the other hand, could use some explanation. Each documentation comment includes a description, followed by a blank line, followed by a @param tag for each parameter, followed by a @return tag:\n/**\n * Converts a measurement in centimeters to inches.\n *\n * @param cm length in centimeters\n * @return length in inches\n */\npublic static double toImperial(double cm) {\n    return cm / CM_PER_INCH;\n}\n/**\n * Converts a length in feet and inches to centimeters.\n *\n * @param feet how many feet\n * @param inches how many inches\n * @return length in centimeters\n */\npublic static double toMetric(int feet, int inches) {\n    int total = feet * IN_PER_FOOT + inches;\n    return total * CM_PER_INCH;\n}\nThe main method has a similar documentation comment, except there is no @return tag since the method is void:\n/**\n * Tests the conversion methods.\n *\n * @param args command-line arguments\n */\npublic static void main(String[] args) {\n    double cm, result;\n    int feet, inches;\n    Scanner in = new Scanner(System.in);\n\n    // test the Imperial conversion\n    System.out.print(\"Exactly how many cm? \");\n    cm = in.nextDouble();\n    result = toImperial(cm);\n    System.out.printf(\"That's %.2f inches\\n\", result);\n    System.out.println();\n\n    // test the Metric conversion\n    System.out.print(\"Now how many feet? \");\n    feet = in.nextInt();\n    System.out.print(\"And how many inches? \");\n    inches = in.nextInt();\n    result = toMetric(feet, inches);\n    System.out.printf(\"That's %.2f cm\\n\", result);\n}\nHere are two ways you can run the Javadoc tool on this example program:\n\nFrom the command line, go to the location for Convert.java. The -d option of javadoc indicates where to generate the HTML files:\njavadoc -d doc Convert.java\nFrom DrJava, click the Javadoc button on the toolbar. The IDE will then prompt you for a location to generate the HTML files.\n\nFor more examples of what you can do with Javadoc comments, see the source code of any Java library class (e.g., Scanner.java). Section 10.6 explains how to find the source files for the Java library on your computer.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Javadoc</span>"
    ]
  },
  {
    "objectID": "appb.html#vocabulary",
    "href": "appb.html#vocabulary",
    "title": "19  Javadoc",
    "section": "19.5 Vocabulary",
    "text": "19.5 Vocabulary\n\ndocumentation:\n\nComments that describe the technical operation of a class or method.\n\nJavadoc:\n\nA tool that reads Java source code and generates documentation in HTML format.\n\nsignature:\n\nThe first line of a method that defines its name and parameters.\n\ntag:\n\nA label that begins with an at sign (@) and is used by Javadoc to organize documentation into sections.\n\ndescription:\n\nThe first line of a documentation comment that explains what the class/method does.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Javadoc</span>"
    ]
  },
  {
    "objectID": "appc.html",
    "href": "appc.html",
    "title": "20  Graphics",
    "section": "",
    "text": "20.1 Creating Graphics\nThere are several ways to create graphics in Java; the simplest way is to use java.awt.Canvas and java.awt.Graphics. A Canvas is a blank rectangular area of the screen onto which the application can draw. The Graphics class provides basic drawing methods such as drawLine, drawRect, and drawString.\nHere is an example program that draws a circle by using the fillOval method:\nThe Drawing class extends Canvas, so it has all the methods provided by Canvas, including setSize. You can read about the other methods in the documentation, which you can find by doing a web search for “Java Canvas”.\nIn the main method, we do the following:\nOnce the frame is visible, the paint method is called whenever the canvas needs to be drawn; for example, when the window is moved or resized. If you run this code, you should see a black circle on a gray background.\nThe application doesn’t end after the main method returns; instead, it waits for the JFrame to close. When the JFrame closes, it calls System.exit, which ends the program.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Graphics</span>"
    ]
  },
  {
    "objectID": "appc.html#creating-graphics",
    "href": "appc.html#creating-graphics",
    "title": "20  Graphics",
    "section": "",
    "text": "import java.awt.Canvas;\nimport java.awt.Graphics;\nimport javax.swing.JFrame;\n\npublic class Drawing extends Canvas {\npublic static void main(String[] args) {\n        JFrame frame = new JFrame(\"My Drawing\");\n        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n        Drawing drawing = new Drawing();\n        drawing.setSize(400, 400);\n        frame.add(drawing);\n        frame.pack();\n        frame.setVisible(true);\n    }\n\n    public void paint(Graphics g) {\n        g.fillOval(100, 100, 200, 200);\n    }\n}\n\n\n\nCreate a JFrame object, which is the window that will contain the canvas.\nCreate a Drawing object (which is the canvas), set its width and height, and add it to the frame.\nPack the frame (resize it) to fit the canvas, and display it on the screen.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Graphics</span>"
    ]
  },
  {
    "objectID": "appc.html#graphics-methods",
    "href": "appc.html#graphics-methods",
    "title": "20  Graphics",
    "section": "20.2 Graphics Methods",
    "text": "20.2 Graphics Methods\nYou are probably used to Cartesian coordinates, where \\(x\\) and \\(y\\) values can be positive or negative. In contrast, Java uses a coordinate system where the origin is in the upper-left corner. That way, \\(x\\) and \\(y\\) can always be positive integers. Figure 20.1 shows these coordinate systems side by side.\n\n\n\n\n\nThe difference between Cartesian coordinates and Java graphical coordinates.\n\n\nGraphical coordinates are measured in pixels; each pixel corresponds to a dot on the screen.\nTo draw on the canvas, you invoke methods on a Graphics object. You don’t have to create the Graphics object; it gets created when you create the Canvas, and it gets passed as an argument to paint.\nThe previous example used fillOval, which has the following signature:\n/**\n * Fills an oval bounded by the specified rectangle with\n * the current color.\n */\npublic void fillOval(int x, int y, int width, int height)\nThe four parameters specify a bounding box, which is the rectangle in which the oval is drawn. x and y specify the location of the upper-left corner of the bounding box. The bounding box itself is not drawn (see Figure 20.2).\n\n\n\n\n\nAn oval inside its bounding box.\n\n\nTo choose the color of a shape, invoke setColor on the Graphics object:\ng.setColor(Color.RED);\nThe setColor method determines the color of everything that gets drawn afterward. Color.red is a constant provided by the Color class; to use it, you have to import java.awt.Color. Other colors include the following:\nBLACK       BLUE      CYAN     DARKGRAY   GRAY    LIGHTGRAY\nGREEN       MAGENTA   ORANGE   PINK       WHITE   YELLOW\nYou can create your own colors by specifying the red, green, and blue (RGB) components. For example:\nColor purple = new Color(128, 0, 128);\nEach value is an integer in the range 0 (darkest) to 255 (lightest). The color (0, 0, 0) is black, and (255, 255, 255) is white.\nYou can set the background color of the Canvas by invoking setBackground:\ncanvas.setBackground(Color.WHITE);",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Graphics</span>"
    ]
  },
  {
    "objectID": "appc.html#example-drawing",
    "href": "appc.html#example-drawing",
    "title": "20  Graphics",
    "section": "20.3 Example Drawing",
    "text": "20.3 Example Drawing\nSuppose we want to draw a “Hidden Mickey”, which is an icon that represents Mickey Mouse (see https://en.wikipedia.org/wiki/Hidden_Mickey). We can use the oval we just drew as the face, and then add two ears. To make the code more readable, let’s use Rectangle objects to represent bounding boxes.\nHere’s a method that takes a Rectangle and invokes fillOval:\npublic void boxOval(Graphics g, Rectangle bb) {\n    g.fillOval(bb.x, bb.y, bb.width, bb.height);\n}\nAnd here’s a method that draws Mickey Mouse:\npublic void mickey(Graphics g, Rectangle bb) {\n    boxOval(g, bb);\n\n    int hx = bb.width / 2;\n    int hy = bb.height / 2;\n    Rectangle half = new Rectangle(bb.x, bb.y, hx, hy);\n\n    half.translate(-hx / 2, -hy / 2);\n    boxOval(g, half);\n\n    half.translate(hx * 2, 0);\n    boxOval(g, half);\n}\nThe first line draws the face. The next three lines create a smaller rectangle for the ears. We translate the rectangle up and left for the first ear, then to the right for the second ear. The result is shown in Figure 20.3.\n\n\n\n\n\nA Hidden Mickey drawn using Java graphics.\n\n\nYou can read more about Rectangle and translate in Chapter 10. See the exercises at the end of this appendix for more example drawings.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Graphics</span>"
    ]
  },
  {
    "objectID": "appc.html#vocabulary",
    "href": "appc.html#vocabulary",
    "title": "20  Graphics",
    "section": "20.4 Vocabulary",
    "text": "20.4 Vocabulary\n\nAWT:\n\nThe “Abstract Window Toolkit”, a Java package for creating graphical user interfaces.\n\ncoordinate:\n\nA value that specifies a location in a 2D graphical window.\n\npixel:\n\nThe unit in which coordinates are measured.\n\nbounding box:\n\nA way to specify the coordinates of a rectangular area.\n\nRGB:\n\nA color model based on adding red, green, and blue light.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Graphics</span>"
    ]
  },
  {
    "objectID": "appc.html#exercises",
    "href": "appc.html#exercises",
    "title": "20  Graphics",
    "section": "20.5 Exercises",
    "text": "20.5 Exercises\nThe code for this chapter is in the appc directory of ThinkJavaCode2. See page  for instructions on how to download the repository. Before you start the exercises, we recommend that you compile and run the examples.\n\nExercise 20.1. Draw the flag of Japan: a red circle on a white background that is wider than it is tall.\n\n\nExercise 20.2. Modify Mickey.java* to draw ears on the ears, and ears on those ears, and more ears all the way down until the smallest ears are only 3 pixels wide. The result should look like Figure 20.4. Hint: You should have to add or modify only a few lines of code.*\n\n\n\n\n\nA recursive shape we call “Mickey Moose”.\n\n\n\n\nExercise 20.3. In this exercise, you will draw “Moiré patterns” that seem to shift around as you move. For an explanation of what is going on, see https://en.wikipedia.org/wiki/Moire_pattern.\n\nOpen Moire.java* and read the paint method. Draw a sketch of what you expect it to do. Now run it. Did you get what you expected?*\nModify the program so that the space between the circles is larger or smaller. See what happens to the image.\nModify the program so that the circles are drawn in the center of the screen and concentric, as in Figure 20.5 (left). The distance between the circles should be small enough that the Moiré interference is apparent.\n\n\n\n\n\nGraphical patterns that can exhibit Moiré interference.\n\n\nWrite a method named radial that draws a radial set of line segments as shown in Figure 20.5 (right), but they should be close enough together to create a Moiré pattern.\nJust about any kind of graphical pattern can generate Moiré-like interference patterns. Play around and see what you can create.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Graphics</span>"
    ]
  },
  {
    "objectID": "appd.html",
    "href": "appd.html",
    "title": "21  Debugging",
    "section": "",
    "text": "21.1 Compile-Time Errors\nThe best kind of debugging is the kind you don’t have to do because you avoid making errors in the first place. Incremental development, which we presented in Section 4.9, can help. The key is to start with a working program and add small amounts of code at a time. When there is an error, you will have a pretty good idea of where it is.\nNevertheless, you might find yourself in one of the following situations. For each situation, we have some suggestions about how to proceed.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Debugging</span>"
    ]
  },
  {
    "objectID": "appd.html#compile-time-errors",
    "href": "appd.html#compile-time-errors",
    "title": "21  Debugging",
    "section": "",
    "text": "The compiler is spewing error messages.\nIf the compiler reports 100 error messages, that doesn’t mean there are 100 errors in your program. When the compiler encounters an error, it often gets thrown off track for a while. It tries to recover and pick up again after the first error, but sometimes it reports spurious errors.\nOnly the first error message is truly reliable. We suggest that you fix only one error at a time and then recompile the program. You may find that one semicolon or brace “fixes” 100 errors.\n\n\nI’m getting a weird compiler message, and it won’t go away.\nFirst of all, read the error message carefully. It may be written in terse jargon, but often there is a carefully hidden kernel of information.\nIf nothing else, the message will tell you where in the program the problem occurred. Actually, it tells you where the compiler was when it noticed a problem, which is not necessarily where the error is. Use the information the compiler gives you as a guideline, but if you don’t see an error where the compiler is pointing, broaden the search.\nGenerally, the error will be prior to the location of the error message, but in some cases it will be somewhere else entirely. For example, if you get an error message at a method invocation, the actual error may be in the method definition itself.\nIf you don’t find the error quickly, take a breath and look more broadly at the entire program. Make sure the program is indented properly; that makes it easier to spot syntax errors.\nNow, start looking for common syntax errors:\n\nCheck that all parentheses and brackets are balanced and properly nested. All method definitions should be nested within a class definition. All program statements should be within a method definition.\nRemember that uppercase letters are not the same as lowercase letters.\nCheck for semicolons at the end of statements (and no semicolons after curly braces).\nMake sure that any strings in the code have matching quotation marks. Make sure that you use double quotes for strings, and single quotes for characters.\nFor each assignment statement, make sure that the type on the left is the same as the type on the right. Make sure that the expression on the left is a variable name or something else that you can assign a value to (like an element of an array).\nFor each method invocation, make sure that the arguments you provide are in the right order and have the right type, and that the object you are invoking the method on is the right type.\nIf you are invoking a value method, make sure you are doing something with the result. If you are invoking a void method, make sure you are not trying to do something with the result.\nIf you are invoking an instance method, make sure you are invoking it on an object with the right type. If you are invoking a static method from outside the class where it is defined, make sure you specify the class name (using dot notation).\nInside an instance method, you can refer to the instance variables without specifying an object. If you try that in a static method—with or without this—you get a message like “non-static variable x cannot be referenced from a static context.”\n\nIf nothing works, move on to the next section…\n\n\nI can’t get my program to compile no matter what I do.\nIf the compiler says there is an error and you don’t see it, that might be because you and the compiler are not looking at the same code. Check your development environment to make sure the program you are editing is the program the compiler is compiling.\nThis situation is often the result of having multiple copies of the same program. You might be editing one version of the file but compiling a different version.\nIf you are not sure, try putting an obvious and deliberate syntax error right at the beginning of the program. Now compile again. If the compiler doesn’t find the new error, there is probably something wrong with the way you set up the development environment.\nIf you have examined the code thoroughly, and you are sure the compiler is compiling the right source file, it is time for desperate measures—debugging by bisection:\n\nMake a backup of the file you are working on. If you are working on Bob.java, make a copy called Bob.java.old.\nDelete about half the code from Bob.java. Try compiling again.\n\nIf the program compiles now, you know the error is in the code you deleted. Bring back about half of what you deleted and repeat.\nIf the program still doesn’t compile, the error must be in the code that remains. Delete about half of the remaining code and repeat.\n\nOnce you have found and fixed the error, start bringing back the code you deleted, a little bit at a time.\n\nThis process is ugly, but it goes faster than you might think and is very reliable. It works for other programming languages too!\n\n\nI did what the compiler told me to do, but it still doesn’t work.\nSome error messages come with tidbits of advice, like “class Golfer must be declared abstract. It does not define int compareTo(java.lang.Object) from interface java.lang.Comparable.” It sounds like the compiler is telling you to declare Golfer as an abstract class, and if you are reading this book, you probably don’t know what that is or how to do it.\nFortunately, the compiler is wrong. The solution in this case is to make sure Golfer has a method called compareTo that takes an Object as a parameter.\nDon’t let the compiler lead you by the nose. Error messages give you evidence that something is wrong, but the remedies they suggest are unreliable.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Debugging</span>"
    ]
  },
  {
    "objectID": "appd.html#run-time-errors",
    "href": "appd.html#run-time-errors",
    "title": "21  Debugging",
    "section": "21.2 Run-Time Errors",
    "text": "21.2 Run-Time Errors\nIt’s not always clear what causes a run-time error, but you can often figure things out by adding print statements to your program.\n\nMy program hangs.\nIf a program stops and seems to be doing nothing, we say it is “hanging”. Often that means it is caught in an infinite loop or an infinite recursion.\n\nIf you suspect that a particular loop is the problem, add a print statement immediately before the loop that says \"entering the loop\" and another immediately after that says \"exiting the loop\".\nRun the program. If you get the first message and not the second, you know where the program is getting stuck. Go to the section titled “Infinite loop”.\nMost of the time, an infinite recursion will cause the program to run for a while and then produce a StackOverflowError. If that happens, go to the section titled “Infinite recursion”.\nIf you are not getting a StackOverflowError, but you suspect there is a problem with a recursive method, you can still use the techniques in the infinite recursion section.\nIf neither of the previous suggestions helps, you might not understand the flow of execution in your program. Go to the section titled “Flow of execution”.\n\n\nInfinite loop\nIf you think you have an infinite loop and you know which loop it is, add a print statement at the end of the loop that displays the values of the variables in the condition, and the value of the condition.\nFor example:\nwhile (x &gt; 0 && y &lt; 0) {\n    // do something to x\n    // do something to y\n\n    System.out.println(\"x: \" + x);\n    System.out.println(\"y: \" + y);\n    System.out.println(\"condition: \" + (x &gt; 0 && y &lt; 0));\n}\nNow when you run the program, you see three lines of output for each time through the loop. The last time through the loop, the condition should be false. If the loop keeps going, you will see the values of x and y, and you might figure out why they are not getting updated correctly.\n\n\nInfinite recursion\nMost of the time, an infinite recursion will cause the program to throw a StackOverflowError. But if the program is slow, it may take a long time to fill the stack.\nIf you know which method is causing an infinite recursion, check that there is a base case. There should be a condition that makes the method return without making a recursive invocation. If not, you need to rethink the algorithm and identify a base case.\nIf there is a base case, but the program doesn’t seem to be reaching it, add a print statement at the beginning of the method that displays the parameters.\nNow when you run the program, you see a few lines of output every time the method is invoked, and you can see the values of the parameters. If the parameters are not moving toward the base case, you might see why not.\n\n\nFlow of execution\nIf you are not sure how the flow of execution is moving through your program, add print statements to the beginning of each method with a message like \"entering method foo\", where foo is the name of the method. Now when you run the program, it displays a trace of each method as it is invoked.\nYou can also display the arguments each method receives. When you run the program, check whether the values are reasonable, and check for one of the most common errors—providing arguments in the wrong order.\n\n\n\nWhen I run the program, I get an exception.\nWhen an exception occurs, Java displays a message that includes the name of the exception, the line of the program where the exception occurred, and a stack trace. The stack trace includes the method that was running, the method that invoked it, the method that invoked that one, and so on.\nThe first step is to examine the place in the program where the error occurred and see if you can figure out what happened:\n\nNullPointerException:\n\nYou tried to access an instance variable or invoke a method on an object that is currently null. You should figure out which variable is null and then figure out how it got to be that way.\nRemember that when you declare a variable with an array type, its elements are initially null until you assign a value to them. For example, this code causes a NullPointerException:\nint[] array = new Point[5];\nSystem.out.println(array[0].x);\n\nArrayIndexOutOfBoundsException:\n\nThe index you are using to access an array is either negative or greater than array.length - 1. If you can find the site where the problem is, add a print statement immediately before it to display the value of the index and the length of the array. Is the array the right size? Is the index the right value?\nNow work your way backward through the program and see where the array and the index come from. Find the nearest assignment statement and see if it is doing the right thing. If either one is a parameter, go to the place where the method is invoked and see where the values are coming from.\n\nStackOverflowError:\n\nSee “Infinite recursion” on page .\n\nFileNotFoundException:\n\nThis means Java didn’t find the file it was looking for. If you are using a project-based development environment like Eclipse, you might have to import the file into the project. Otherwise, make sure the file exists and that the path is correct. This problem depends on your filesystem, so it can be hard to track down.\n\nArithmeticException:\n\nSomething went wrong during an arithmetic operation; for example, division by zero.\n\n\n\n\nI added so many print statements I get inundated with output.\nOne of the problems with using print statements for debugging is that you can end up buried in output. There are two ways to proceed: either simplify the output or simplify the program.\nTo simplify the output, you can remove or comment out print statements that aren’t helping, or combine them, or format the output so it is easier to understand. As you develop a program, you should write code to generate concise, informative traces of what the program is doing.\nTo simplify the program, scale down the problem the program is working on. For example, if you are sorting an array, sort a small array. If the program takes input from the user, give it the simplest input that causes the error.\nAlso, clean up the code. Remove unnecessary or experimental parts, and reorganize the program to make it easier to read. For example, if you suspect that the error is in a deeply nested part of the program, rewrite that part with a simpler structure. If you suspect a large method, split it into smaller methods and test them separately.\nThe process of finding the minimal test case often leads you to the bug. For example, if you find that a program works when the array has an even number of elements, but not when it has an odd number, that gives you a clue about what is going on.\nReorganizing the program can help you find subtle bugs. If you make a change that you think doesn’t affect the program, and it does, that can tip you off.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Debugging</span>"
    ]
  },
  {
    "objectID": "appd.html#logic-errors",
    "href": "appd.html#logic-errors",
    "title": "21  Debugging",
    "section": "21.3 Logic Errors",
    "text": "21.3 Logic Errors\n\nMy program doesn’t work.\nLogic errors are hard to find because the compiler and interpreter provide no information about what is wrong. Only you know what the program is supposed to do, and only you know that it isn’t doing it.\nThe first step is to make a connection between the code and the behavior you get. You need a hypothesis about what the program is actually doing. Here are some questions to ask yourself:\n\nIs there something the program was supposed to do that doesn’t seem to be happening? Find the section of the code that performs that function, and make sure it is executing when you think it should. See “Flow of execution” on page .\nIs something happening that shouldn’t? Find code in your program that performs that function, and see if it is executing when it shouldn’t.\nIs a section of code producing an unexpected effect? Make sure you understand the code, especially if it invokes methods in the Java library. Read the documentation for those methods, and try them out with simple test cases. They might not do what you think they do.\n\nTo program, you need a mental model of what your code does. If it doesn’t do what you expect, the problem might not actually be the program; it might be in your head.\nThe best way to correct your mental model is to break the program into components (usually the classes and methods) and test them independently. Once you find the discrepancy between your model and reality, you can solve the problem.\nHere are some common logic errors to check for:\n\nRemember that integer division always rounds toward zero. If you want fractions, use double. More generally, use integers for countable things and floating-point numbers for measurable things.\nFloating-point numbers are only approximate, so don’t rely on them to be perfectly accurate. You should probably never use the == operator with doubles. Instead of writing if (d == 1.23), do something like if (Math.abs(d - 1.23) &lt; .000001).\nWhen you apply the equality operator (==) to objects, it checks whether they are identical. If you meant to check equivalence, you should use the equals method instead.\nBy default for user-defined types, equals checks identity. If you want a different notion of equivalence, you have to override it.\nInheritance can lead to subtle logic errors, because you can run inherited code without realizing it. See “Flow of execution” on page .\n\n\n\nI’ve got a big, hairy expression and it doesn’t do what I expect.\nWriting complex expressions is fine as long as they are readable, but they can be hard to debug. It is often a good idea to break a complex expression into a series of assignments to temporary variables:\nrect.translate((int) Math.round(0.5 * rect.getWidth()),\n               (int) Math.round(0.5 * rect.getHeight()));\nThis example can be rewritten as follows:\ndouble halfWidth = 0.5 * rect.getWidth();\ndouble halfHeight = 0.5 * rect.getHeight();\nint dx = (int) Math.round(halfWidth);\nint dy = (int) Math.round(halfHeight);\nrect.translate(dx, dy);\nThe second version is easier to read, partly because the variable names provide additional documentation. It’s also easier to debug, because you can check the types of the temporary variables and display their values.\nAnother problem that can occur with big expressions is that the order of operations may not be what you expect. For example, to evaluate \\(\\frac{x}{2 \\pi}\\), you might write this:\ndouble y = x / 2 * Math.PI;\nThat is not correct, because multiplication and division have the same precedence, and they are evaluated from left to right. This code computes \\(\\frac{x}{2}\\pi\\).\nIf you are not sure of the order of operations, check the documentation, or use parentheses to make it explicit.\ndouble y = x / (2 * Math.PI);\nThis version is correct, and more readable for other people who haven’t memorized the order of operations.\n\n\nMy method doesn’t return what I expect.\nIf you have a return statement with a complex expression, you don’t have a chance to display the value before returning:\npublic Rectangle intersection(Rectangle a, Rectangle b) {\n    return new Rectangle(\n        Math.min(a.x, b.x), Math.min(a.y, b.y),\n        Math.max(a.x + a.width, b.x + b.width)\n            - Math.min(a.x, b.x)\n        Math.max(a.y + a.height, b.y + b.height)\n            - Math.min(a.y, b.y));\n}\nInstead of writing everything in one statement, use temporary variables:\npublic Rectangle intersection(Rectangle a, Rectangle b) {\n    int x1 = Math.min(a.x, b.x);\n    int y1 = Math.min(a.y, b.y);\n    int x2 = Math.max(a.x + a.width, b.x + b.width);\n    int y2 = Math.max(a.y + a.height, b.y + b.height);\n    Rectangle rect = new Rectangle(x1, y1, x2 - x1, y2 - y1);\n    return rect;\n}\nNow you have the opportunity to display any of the intermediate variables before returning. And by reusing x1 and y1, you made the code smaller too.\n\n\nMy print statement isn’t doing anything.\nIf you use the println method, the output is displayed immediately, but if you use print (at least in some environments), the output gets stored without being displayed until the next newline. If the program terminates without displaying a newline, you may never see the stored output. If you suspect that this is happening, change some or all of the print statements to println.\n\n\nI’m really, really stuck and I need help.\nFirst, get away from the computer for a few minutes. Computers emit waves that affect the brain, causing the following symptoms:\n\nFrustration and rage.\nSuperstitious beliefs (“the computer hates me”) and magical thinking (“the program works only when I wear my hat backward”).\nSour grapes (“this program is lame anyway”).\n\nIf you suffer from any of these symptoms, get up and go for a walk. When you are calm, think about the program. What is it doing? What are possible causes of that behavior? When was the last time you had a working program, and what did you do next?\nSometimes it just takes time to find a bug. People often find bugs when they let their mind wander. Good places to find bugs are buses, showers, and bed.\n\n\nNo, I really need help.\nIt happens. Even the best programmers get stuck. Sometimes you need another pair of eyes. Before you bring someone else in, make sure you have tried the techniques described in this appendix.\nYour program should be as simple as possible, and you should be working on the smallest input that causes the error. You should have print statements in the appropriate places (and the output they produce should be comprehensible). You should understand the problem well enough to describe it concisely.\nWhen you bring someone in to help, give them the information they need:\n\nWhat kind of bug is it? Compile-time, run-time, or logic?\nWhat was the last thing you did before this error occurred? What were the last lines of code that you wrote, or what is the test case that fails?\nIf the bug occurs at compile time or run time, what is the error message, and what part of the program does it indicate?\nWhat have you tried, and what have you learned?\n\nBy the time you explain the problem to someone, you might see the answer. This phenomenon is so common that some people recommend a debugging technique called “rubber ducking”. Here’s how it works:\n\nBuy a standard-issue rubber duck.\nWhen you are really stuck on a problem, put the rubber duck on the desk in front of you and say, “Rubber duck, I am stuck on a problem. Here’s what’s happening…”\nExplain the problem to the rubber duck.\nDiscover the solution.\nThank the rubber duck.\n\nWe’re not kidding, it works! See https://en.wikipedia.org/wiki/Rubber_duck_debugging.\n\n\nI found the bug!\nWhen you find the bug, the way to fix it is usually obvious. But not always. Sometimes what seems to be a bug is really an indication that you don’t understand the program, or your algorithm contains an error. In these cases, you might have to rethink the algorithm or adjust your mental model. Take some time away from the computer to think, work through test cases by hand, or draw diagrams to represent the computation.\nAfter you fix the bug, don’t just start in making new errors. Take a minute to think about what kind of bug it was, why you made the error, how the error manifested itself, and what you could have done to find it faster. Next time you see something similar, you will be able to find the bug more quickly. Or even better, you will learn to avoid that type of bug for good.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Debugging</span>"
    ]
  }
]